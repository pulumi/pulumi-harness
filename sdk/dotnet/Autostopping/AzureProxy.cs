// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Harness.Autostopping
{
    /// <summary>
    /// Resource for creating an Azure autostopping proxy
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Harness = Pulumi.Harness;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var test = new Harness.Autostopping.AzureProxy("test", new()
    ///     {
    ///         Name = "name",
    ///         CloudConnectorId = "cloud_connector_id",
    ///         HostName = "host_name",
    ///         Region = "eastus2",
    ///         ResourceGroup = "resource_group",
    ///         Vpc = "/subscriptions/subscription_id/resourceGroups/resource_group/providers/Microsoft.Network/virtualNetworks/virtual_network",
    ///         SubnetId = "/subscriptions/subscription_id/resourceGroups/resource_group/providers/Microsoft.Network/virtualNetworks/virtual_network/subnets/subnet_id",
    ///         SecurityGroups = new[]
    ///         {
    ///             "/subscriptions/subscription_id/resourceGroups/resource_group/providers/Microsoft.Network/networkSecurityGroups/network_security_group",
    ///         },
    ///         AllocateStaticIp = true,
    ///         MachineType = "Standard_D2s_v3",
    ///         Keypair = "",
    ///         ApiKey = "",
    ///         DeleteCloudResourcesOnDestroy = true,
    ///     });
    /// 
    /// });
    /// ```
    /// </summary>
    [HarnessResourceType("harness:autostopping/azureProxy:AzureProxy")]
    public partial class AzureProxy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Boolean value to indicate if proxy vm needs to have static IP
        /// </summary>
        [Output("allocateStaticIp")]
        public Output<bool?> AllocateStaticIp { get; private set; } = null!;

        /// <summary>
        /// Harness NG API key
        /// </summary>
        [Output("apiKey")]
        public Output<string> ApiKey { get; private set; } = null!;

        [Output("certificateId")]
        public Output<string?> CertificateId { get; private set; } = null!;

        [Output("certificates")]
        public Output<Outputs.AzureProxyCertificates?> Certificates { get; private set; } = null!;

        /// <summary>
        /// Id of the cloud connector
        /// </summary>
        [Output("cloudConnectorId")]
        public Output<string> CloudConnectorId { get; private set; } = null!;

        /// <summary>
        /// Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
        /// </summary>
        [Output("deleteCloudResourcesOnDestroy")]
        public Output<bool> DeleteCloudResourcesOnDestroy { get; private set; } = null!;

        /// <summary>
        /// Hostname for the proxy
        /// </summary>
        [Output("hostName")]
        public Output<string> HostName { get; private set; } = null!;

        /// <summary>
        /// Unique identifier of the resource
        /// </summary>
        [Output("identifier")]
        public Output<string> Identifier { get; private set; } = null!;

        /// <summary>
        /// Name of SSH Key to be used for proxy VM
        /// </summary>
        [Output("keypair")]
        public Output<string> Keypair { get; private set; } = null!;

        /// <summary>
        /// Type of instance to be used for proxy
        /// </summary>
        [Output("machineType")]
        public Output<string> MachineType { get; private set; } = null!;

        /// <summary>
        /// Name of the proxy
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Region in which cloud resources are hosted
        /// </summary>
        [Output("region")]
        public Output<string> Region { get; private set; } = null!;

        /// <summary>
        /// Resource group in which cloud resources are hosted
        /// </summary>
        [Output("resourceGroup")]
        public Output<string> ResourceGroup { get; private set; } = null!;

        /// <summary>
        /// Security Group to define the security rules that determine the inbound and outbound traffic
        /// </summary>
        [Output("securityGroups")]
        public Output<ImmutableArray<string>> SecurityGroups { get; private set; } = null!;

        /// <summary>
        /// Subnet in which cloud resources are hosted
        /// </summary>
        [Output("subnetId")]
        public Output<string> SubnetId { get; private set; } = null!;

        /// <summary>
        /// VPC in which cloud resources are hosted
        /// </summary>
        [Output("vpc")]
        public Output<string> Vpc { get; private set; } = null!;


        /// <summary>
        /// Create a AzureProxy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public AzureProxy(string name, AzureProxyArgs args, CustomResourceOptions? options = null)
            : base("harness:autostopping/azureProxy:AzureProxy", name, args ?? new AzureProxyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private AzureProxy(string name, Input<string> id, AzureProxyState? state = null, CustomResourceOptions? options = null)
            : base("harness:autostopping/azureProxy:AzureProxy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumi",
                AdditionalSecretOutputs =
                {
                    "apiKey",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing AzureProxy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static AzureProxy Get(string name, Input<string> id, AzureProxyState? state = null, CustomResourceOptions? options = null)
        {
            return new AzureProxy(name, id, state, options);
        }
    }

    public sealed class AzureProxyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Boolean value to indicate if proxy vm needs to have static IP
        /// </summary>
        [Input("allocateStaticIp")]
        public Input<bool>? AllocateStaticIp { get; set; }

        [Input("apiKey", required: true)]
        private Input<string>? _apiKey;

        /// <summary>
        /// Harness NG API key
        /// </summary>
        public Input<string>? ApiKey
        {
            get => _apiKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _apiKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("certificateId")]
        public Input<string>? CertificateId { get; set; }

        [Input("certificates")]
        public Input<Inputs.AzureProxyCertificatesArgs>? Certificates { get; set; }

        /// <summary>
        /// Id of the cloud connector
        /// </summary>
        [Input("cloudConnectorId", required: true)]
        public Input<string> CloudConnectorId { get; set; } = null!;

        /// <summary>
        /// Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
        /// </summary>
        [Input("deleteCloudResourcesOnDestroy", required: true)]
        public Input<bool> DeleteCloudResourcesOnDestroy { get; set; } = null!;

        /// <summary>
        /// Hostname for the proxy
        /// </summary>
        [Input("hostName", required: true)]
        public Input<string> HostName { get; set; } = null!;

        /// <summary>
        /// Name of SSH Key to be used for proxy VM
        /// </summary>
        [Input("keypair", required: true)]
        public Input<string> Keypair { get; set; } = null!;

        /// <summary>
        /// Type of instance to be used for proxy
        /// </summary>
        [Input("machineType", required: true)]
        public Input<string> MachineType { get; set; } = null!;

        /// <summary>
        /// Name of the proxy
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Region in which cloud resources are hosted
        /// </summary>
        [Input("region", required: true)]
        public Input<string> Region { get; set; } = null!;

        /// <summary>
        /// Resource group in which cloud resources are hosted
        /// </summary>
        [Input("resourceGroup", required: true)]
        public Input<string> ResourceGroup { get; set; } = null!;

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// Security Group to define the security rules that determine the inbound and outbound traffic
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        /// <summary>
        /// Subnet in which cloud resources are hosted
        /// </summary>
        [Input("subnetId", required: true)]
        public Input<string> SubnetId { get; set; } = null!;

        /// <summary>
        /// VPC in which cloud resources are hosted
        /// </summary>
        [Input("vpc", required: true)]
        public Input<string> Vpc { get; set; } = null!;

        public AzureProxyArgs()
        {
        }
        public static new AzureProxyArgs Empty => new AzureProxyArgs();
    }

    public sealed class AzureProxyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Boolean value to indicate if proxy vm needs to have static IP
        /// </summary>
        [Input("allocateStaticIp")]
        public Input<bool>? AllocateStaticIp { get; set; }

        [Input("apiKey")]
        private Input<string>? _apiKey;

        /// <summary>
        /// Harness NG API key
        /// </summary>
        public Input<string>? ApiKey
        {
            get => _apiKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _apiKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        [Input("certificateId")]
        public Input<string>? CertificateId { get; set; }

        [Input("certificates")]
        public Input<Inputs.AzureProxyCertificatesGetArgs>? Certificates { get; set; }

        /// <summary>
        /// Id of the cloud connector
        /// </summary>
        [Input("cloudConnectorId")]
        public Input<string>? CloudConnectorId { get; set; }

        /// <summary>
        /// Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
        /// </summary>
        [Input("deleteCloudResourcesOnDestroy")]
        public Input<bool>? DeleteCloudResourcesOnDestroy { get; set; }

        /// <summary>
        /// Hostname for the proxy
        /// </summary>
        [Input("hostName")]
        public Input<string>? HostName { get; set; }

        /// <summary>
        /// Unique identifier of the resource
        /// </summary>
        [Input("identifier")]
        public Input<string>? Identifier { get; set; }

        /// <summary>
        /// Name of SSH Key to be used for proxy VM
        /// </summary>
        [Input("keypair")]
        public Input<string>? Keypair { get; set; }

        /// <summary>
        /// Type of instance to be used for proxy
        /// </summary>
        [Input("machineType")]
        public Input<string>? MachineType { get; set; }

        /// <summary>
        /// Name of the proxy
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Region in which cloud resources are hosted
        /// </summary>
        [Input("region")]
        public Input<string>? Region { get; set; }

        /// <summary>
        /// Resource group in which cloud resources are hosted
        /// </summary>
        [Input("resourceGroup")]
        public Input<string>? ResourceGroup { get; set; }

        [Input("securityGroups")]
        private InputList<string>? _securityGroups;

        /// <summary>
        /// Security Group to define the security rules that determine the inbound and outbound traffic
        /// </summary>
        public InputList<string> SecurityGroups
        {
            get => _securityGroups ?? (_securityGroups = new InputList<string>());
            set => _securityGroups = value;
        }

        /// <summary>
        /// Subnet in which cloud resources are hosted
        /// </summary>
        [Input("subnetId")]
        public Input<string>? SubnetId { get; set; }

        /// <summary>
        /// VPC in which cloud resources are hosted
        /// </summary>
        [Input("vpc")]
        public Input<string>? Vpc { get; set; }

        public AzureProxyState()
        {
        }
        public static new AzureProxyState Empty => new AzureProxyState();
    }
}
