// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.harness.platform.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.harness.platform.inputs.GitOpsClusterRequestClusterConfigExecProviderConfigArgs;
import com.pulumi.harness.platform.inputs.GitOpsClusterRequestClusterConfigTlsClientConfigArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GitOpsClusterRequestClusterConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final GitOpsClusterRequestClusterConfigArgs Empty = new GitOpsClusterRequestClusterConfigArgs();

    /**
     * AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
     * 
     */
    @Import(name="awsClusterName")
    private @Nullable Output<String> awsClusterName;

    /**
     * @return AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
     * 
     */
    public Optional<Output<String>> awsClusterName() {
        return Optional.ofNullable(this.awsClusterName);
    }

    /**
     * Bearer authentication token the cluster.
     * 
     */
    @Import(name="bearerToken")
    private @Nullable Output<String> bearerToken;

    /**
     * @return Bearer authentication token the cluster.
     * 
     */
    public Optional<Output<String>> bearerToken() {
        return Optional.ofNullable(this.bearerToken);
    }

    /**
     * Identifies the authentication method used to connect to the cluster.
     * 
     */
    @Import(name="clusterConnectionType")
    private @Nullable Output<String> clusterConnectionType;

    /**
     * @return Identifies the authentication method used to connect to the cluster.
     * 
     */
    public Optional<Output<String>> clusterConnectionType() {
        return Optional.ofNullable(this.clusterConnectionType);
    }

    /**
     * DisableCompression bypasses automatic GZip compression requests to to the cluster&#39;s API server. Corresponds to running kubectl with --disable-compression
     * 
     */
    @Import(name="disableCompression")
    private @Nullable Output<Boolean> disableCompression;

    /**
     * @return DisableCompression bypasses automatic GZip compression requests to to the cluster&#39;s API server. Corresponds to running kubectl with --disable-compression
     * 
     */
    public Optional<Output<Boolean>> disableCompression() {
        return Optional.ofNullable(this.disableCompression);
    }

    /**
     * Configuration for an exec provider.
     * 
     */
    @Import(name="execProviderConfigs")
    private @Nullable Output<List<GitOpsClusterRequestClusterConfigExecProviderConfigArgs>> execProviderConfigs;

    /**
     * @return Configuration for an exec provider.
     * 
     */
    public Optional<Output<List<GitOpsClusterRequestClusterConfigExecProviderConfigArgs>>> execProviderConfigs() {
        return Optional.ofNullable(this.execProviderConfigs);
    }

    /**
     * Password of the server of the cluster.
     * 
     */
    @Import(name="password")
    private @Nullable Output<String> password;

    /**
     * @return Password of the server of the cluster.
     * 
     */
    public Optional<Output<String>> password() {
        return Optional.ofNullable(this.password);
    }

    /**
     * The URL to the proxy to be used for all requests send to the cluster&#39;s API server
     * 
     */
    @Import(name="proxyUrl")
    private @Nullable Output<String> proxyUrl;

    /**
     * @return The URL to the proxy to be used for all requests send to the cluster&#39;s API server
     * 
     */
    public Optional<Output<String>> proxyUrl() {
        return Optional.ofNullable(this.proxyUrl);
    }

    /**
     * Optional role ARN. If set then used for AWS IAM Authenticator.
     * 
     */
    @Import(name="roleARN")
    private @Nullable Output<String> roleARN;

    /**
     * @return Optional role ARN. If set then used for AWS IAM Authenticator.
     * 
     */
    public Optional<Output<String>> roleARN() {
        return Optional.ofNullable(this.roleARN);
    }

    /**
     * Settings to enable transport layer security.
     * 
     */
    @Import(name="tlsClientConfigs")
    private @Nullable Output<List<GitOpsClusterRequestClusterConfigTlsClientConfigArgs>> tlsClientConfigs;

    /**
     * @return Settings to enable transport layer security.
     * 
     */
    public Optional<Output<List<GitOpsClusterRequestClusterConfigTlsClientConfigArgs>>> tlsClientConfigs() {
        return Optional.ofNullable(this.tlsClientConfigs);
    }

    /**
     * Username of the server of the cluster.
     * 
     */
    @Import(name="username")
    private @Nullable Output<String> username;

    /**
     * @return Username of the server of the cluster.
     * 
     */
    public Optional<Output<String>> username() {
        return Optional.ofNullable(this.username);
    }

    private GitOpsClusterRequestClusterConfigArgs() {}

    private GitOpsClusterRequestClusterConfigArgs(GitOpsClusterRequestClusterConfigArgs $) {
        this.awsClusterName = $.awsClusterName;
        this.bearerToken = $.bearerToken;
        this.clusterConnectionType = $.clusterConnectionType;
        this.disableCompression = $.disableCompression;
        this.execProviderConfigs = $.execProviderConfigs;
        this.password = $.password;
        this.proxyUrl = $.proxyUrl;
        this.roleARN = $.roleARN;
        this.tlsClientConfigs = $.tlsClientConfigs;
        this.username = $.username;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GitOpsClusterRequestClusterConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GitOpsClusterRequestClusterConfigArgs $;

        public Builder() {
            $ = new GitOpsClusterRequestClusterConfigArgs();
        }

        public Builder(GitOpsClusterRequestClusterConfigArgs defaults) {
            $ = new GitOpsClusterRequestClusterConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param awsClusterName AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
         * 
         * @return builder
         * 
         */
        public Builder awsClusterName(@Nullable Output<String> awsClusterName) {
            $.awsClusterName = awsClusterName;
            return this;
        }

        /**
         * @param awsClusterName AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
         * 
         * @return builder
         * 
         */
        public Builder awsClusterName(String awsClusterName) {
            return awsClusterName(Output.of(awsClusterName));
        }

        /**
         * @param bearerToken Bearer authentication token the cluster.
         * 
         * @return builder
         * 
         */
        public Builder bearerToken(@Nullable Output<String> bearerToken) {
            $.bearerToken = bearerToken;
            return this;
        }

        /**
         * @param bearerToken Bearer authentication token the cluster.
         * 
         * @return builder
         * 
         */
        public Builder bearerToken(String bearerToken) {
            return bearerToken(Output.of(bearerToken));
        }

        /**
         * @param clusterConnectionType Identifies the authentication method used to connect to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder clusterConnectionType(@Nullable Output<String> clusterConnectionType) {
            $.clusterConnectionType = clusterConnectionType;
            return this;
        }

        /**
         * @param clusterConnectionType Identifies the authentication method used to connect to the cluster.
         * 
         * @return builder
         * 
         */
        public Builder clusterConnectionType(String clusterConnectionType) {
            return clusterConnectionType(Output.of(clusterConnectionType));
        }

        /**
         * @param disableCompression DisableCompression bypasses automatic GZip compression requests to to the cluster&#39;s API server. Corresponds to running kubectl with --disable-compression
         * 
         * @return builder
         * 
         */
        public Builder disableCompression(@Nullable Output<Boolean> disableCompression) {
            $.disableCompression = disableCompression;
            return this;
        }

        /**
         * @param disableCompression DisableCompression bypasses automatic GZip compression requests to to the cluster&#39;s API server. Corresponds to running kubectl with --disable-compression
         * 
         * @return builder
         * 
         */
        public Builder disableCompression(Boolean disableCompression) {
            return disableCompression(Output.of(disableCompression));
        }

        /**
         * @param execProviderConfigs Configuration for an exec provider.
         * 
         * @return builder
         * 
         */
        public Builder execProviderConfigs(@Nullable Output<List<GitOpsClusterRequestClusterConfigExecProviderConfigArgs>> execProviderConfigs) {
            $.execProviderConfigs = execProviderConfigs;
            return this;
        }

        /**
         * @param execProviderConfigs Configuration for an exec provider.
         * 
         * @return builder
         * 
         */
        public Builder execProviderConfigs(List<GitOpsClusterRequestClusterConfigExecProviderConfigArgs> execProviderConfigs) {
            return execProviderConfigs(Output.of(execProviderConfigs));
        }

        /**
         * @param execProviderConfigs Configuration for an exec provider.
         * 
         * @return builder
         * 
         */
        public Builder execProviderConfigs(GitOpsClusterRequestClusterConfigExecProviderConfigArgs... execProviderConfigs) {
            return execProviderConfigs(List.of(execProviderConfigs));
        }

        /**
         * @param password Password of the server of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder password(@Nullable Output<String> password) {
            $.password = password;
            return this;
        }

        /**
         * @param password Password of the server of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder password(String password) {
            return password(Output.of(password));
        }

        /**
         * @param proxyUrl The URL to the proxy to be used for all requests send to the cluster&#39;s API server
         * 
         * @return builder
         * 
         */
        public Builder proxyUrl(@Nullable Output<String> proxyUrl) {
            $.proxyUrl = proxyUrl;
            return this;
        }

        /**
         * @param proxyUrl The URL to the proxy to be used for all requests send to the cluster&#39;s API server
         * 
         * @return builder
         * 
         */
        public Builder proxyUrl(String proxyUrl) {
            return proxyUrl(Output.of(proxyUrl));
        }

        /**
         * @param roleARN Optional role ARN. If set then used for AWS IAM Authenticator.
         * 
         * @return builder
         * 
         */
        public Builder roleARN(@Nullable Output<String> roleARN) {
            $.roleARN = roleARN;
            return this;
        }

        /**
         * @param roleARN Optional role ARN. If set then used for AWS IAM Authenticator.
         * 
         * @return builder
         * 
         */
        public Builder roleARN(String roleARN) {
            return roleARN(Output.of(roleARN));
        }

        /**
         * @param tlsClientConfigs Settings to enable transport layer security.
         * 
         * @return builder
         * 
         */
        public Builder tlsClientConfigs(@Nullable Output<List<GitOpsClusterRequestClusterConfigTlsClientConfigArgs>> tlsClientConfigs) {
            $.tlsClientConfigs = tlsClientConfigs;
            return this;
        }

        /**
         * @param tlsClientConfigs Settings to enable transport layer security.
         * 
         * @return builder
         * 
         */
        public Builder tlsClientConfigs(List<GitOpsClusterRequestClusterConfigTlsClientConfigArgs> tlsClientConfigs) {
            return tlsClientConfigs(Output.of(tlsClientConfigs));
        }

        /**
         * @param tlsClientConfigs Settings to enable transport layer security.
         * 
         * @return builder
         * 
         */
        public Builder tlsClientConfigs(GitOpsClusterRequestClusterConfigTlsClientConfigArgs... tlsClientConfigs) {
            return tlsClientConfigs(List.of(tlsClientConfigs));
        }

        /**
         * @param username Username of the server of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder username(@Nullable Output<String> username) {
            $.username = username;
            return this;
        }

        /**
         * @param username Username of the server of the cluster.
         * 
         * @return builder
         * 
         */
        public Builder username(String username) {
            return username(Output.of(username));
        }

        public GitOpsClusterRequestClusterConfigArgs build() {
            return $;
        }
    }

}
