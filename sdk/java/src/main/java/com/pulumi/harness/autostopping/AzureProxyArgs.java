// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.harness.autostopping;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.harness.autostopping.inputs.AzureProxyCertificatesArgs;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class AzureProxyArgs extends com.pulumi.resources.ResourceArgs {

    public static final AzureProxyArgs Empty = new AzureProxyArgs();

    /**
     * Boolean value to indicate if proxy vm needs to have static IP
     * 
     */
    @Import(name="allocateStaticIp")
    private @Nullable Output<Boolean> allocateStaticIp;

    /**
     * @return Boolean value to indicate if proxy vm needs to have static IP
     * 
     */
    public Optional<Output<Boolean>> allocateStaticIp() {
        return Optional.ofNullable(this.allocateStaticIp);
    }

    /**
     * Harness NG API key
     * 
     */
    @Import(name="apiKey", required=true)
    private Output<String> apiKey;

    /**
     * @return Harness NG API key
     * 
     */
    public Output<String> apiKey() {
        return this.apiKey;
    }

    @Import(name="certificateId")
    private @Nullable Output<String> certificateId;

    public Optional<Output<String>> certificateId() {
        return Optional.ofNullable(this.certificateId);
    }

    @Import(name="certificates")
    private @Nullable Output<AzureProxyCertificatesArgs> certificates;

    public Optional<Output<AzureProxyCertificatesArgs>> certificates() {
        return Optional.ofNullable(this.certificates);
    }

    /**
     * Id of the cloud connector
     * 
     */
    @Import(name="cloudConnectorId", required=true)
    private Output<String> cloudConnectorId;

    /**
     * @return Id of the cloud connector
     * 
     */
    public Output<String> cloudConnectorId() {
        return this.cloudConnectorId;
    }

    /**
     * Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
     * 
     */
    @Import(name="deleteCloudResourcesOnDestroy", required=true)
    private Output<Boolean> deleteCloudResourcesOnDestroy;

    /**
     * @return Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
     * 
     */
    public Output<Boolean> deleteCloudResourcesOnDestroy() {
        return this.deleteCloudResourcesOnDestroy;
    }

    /**
     * Hostname for the proxy
     * 
     */
    @Import(name="hostName", required=true)
    private Output<String> hostName;

    /**
     * @return Hostname for the proxy
     * 
     */
    public Output<String> hostName() {
        return this.hostName;
    }

    /**
     * Name of SSH Key to be used for proxy VM
     * 
     */
    @Import(name="keypair", required=true)
    private Output<String> keypair;

    /**
     * @return Name of SSH Key to be used for proxy VM
     * 
     */
    public Output<String> keypair() {
        return this.keypair;
    }

    /**
     * Type of instance to be used for proxy
     * 
     */
    @Import(name="machineType", required=true)
    private Output<String> machineType;

    /**
     * @return Type of instance to be used for proxy
     * 
     */
    public Output<String> machineType() {
        return this.machineType;
    }

    /**
     * Name of the proxy
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return Name of the proxy
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Region in which cloud resources are hosted
     * 
     */
    @Import(name="region", required=true)
    private Output<String> region;

    /**
     * @return Region in which cloud resources are hosted
     * 
     */
    public Output<String> region() {
        return this.region;
    }

    /**
     * Resource group in which cloud resources are hosted
     * 
     */
    @Import(name="resourceGroup", required=true)
    private Output<String> resourceGroup;

    /**
     * @return Resource group in which cloud resources are hosted
     * 
     */
    public Output<String> resourceGroup() {
        return this.resourceGroup;
    }

    /**
     * Security Group to define the security rules that determine the inbound and outbound traffic
     * 
     */
    @Import(name="securityGroups")
    private @Nullable Output<List<String>> securityGroups;

    /**
     * @return Security Group to define the security rules that determine the inbound and outbound traffic
     * 
     */
    public Optional<Output<List<String>>> securityGroups() {
        return Optional.ofNullable(this.securityGroups);
    }

    /**
     * Subnet in which cloud resources are hosted
     * 
     */
    @Import(name="subnetId", required=true)
    private Output<String> subnetId;

    /**
     * @return Subnet in which cloud resources are hosted
     * 
     */
    public Output<String> subnetId() {
        return this.subnetId;
    }

    /**
     * VPC in which cloud resources are hosted
     * 
     */
    @Import(name="vpc", required=true)
    private Output<String> vpc;

    /**
     * @return VPC in which cloud resources are hosted
     * 
     */
    public Output<String> vpc() {
        return this.vpc;
    }

    private AzureProxyArgs() {}

    private AzureProxyArgs(AzureProxyArgs $) {
        this.allocateStaticIp = $.allocateStaticIp;
        this.apiKey = $.apiKey;
        this.certificateId = $.certificateId;
        this.certificates = $.certificates;
        this.cloudConnectorId = $.cloudConnectorId;
        this.deleteCloudResourcesOnDestroy = $.deleteCloudResourcesOnDestroy;
        this.hostName = $.hostName;
        this.keypair = $.keypair;
        this.machineType = $.machineType;
        this.name = $.name;
        this.region = $.region;
        this.resourceGroup = $.resourceGroup;
        this.securityGroups = $.securityGroups;
        this.subnetId = $.subnetId;
        this.vpc = $.vpc;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(AzureProxyArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private AzureProxyArgs $;

        public Builder() {
            $ = new AzureProxyArgs();
        }

        public Builder(AzureProxyArgs defaults) {
            $ = new AzureProxyArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allocateStaticIp Boolean value to indicate if proxy vm needs to have static IP
         * 
         * @return builder
         * 
         */
        public Builder allocateStaticIp(@Nullable Output<Boolean> allocateStaticIp) {
            $.allocateStaticIp = allocateStaticIp;
            return this;
        }

        /**
         * @param allocateStaticIp Boolean value to indicate if proxy vm needs to have static IP
         * 
         * @return builder
         * 
         */
        public Builder allocateStaticIp(Boolean allocateStaticIp) {
            return allocateStaticIp(Output.of(allocateStaticIp));
        }

        /**
         * @param apiKey Harness NG API key
         * 
         * @return builder
         * 
         */
        public Builder apiKey(Output<String> apiKey) {
            $.apiKey = apiKey;
            return this;
        }

        /**
         * @param apiKey Harness NG API key
         * 
         * @return builder
         * 
         */
        public Builder apiKey(String apiKey) {
            return apiKey(Output.of(apiKey));
        }

        public Builder certificateId(@Nullable Output<String> certificateId) {
            $.certificateId = certificateId;
            return this;
        }

        public Builder certificateId(String certificateId) {
            return certificateId(Output.of(certificateId));
        }

        public Builder certificates(@Nullable Output<AzureProxyCertificatesArgs> certificates) {
            $.certificates = certificates;
            return this;
        }

        public Builder certificates(AzureProxyCertificatesArgs certificates) {
            return certificates(Output.of(certificates));
        }

        /**
         * @param cloudConnectorId Id of the cloud connector
         * 
         * @return builder
         * 
         */
        public Builder cloudConnectorId(Output<String> cloudConnectorId) {
            $.cloudConnectorId = cloudConnectorId;
            return this;
        }

        /**
         * @param cloudConnectorId Id of the cloud connector
         * 
         * @return builder
         * 
         */
        public Builder cloudConnectorId(String cloudConnectorId) {
            return cloudConnectorId(Output.of(cloudConnectorId));
        }

        /**
         * @param deleteCloudResourcesOnDestroy Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
         * 
         * @return builder
         * 
         */
        public Builder deleteCloudResourcesOnDestroy(Output<Boolean> deleteCloudResourcesOnDestroy) {
            $.deleteCloudResourcesOnDestroy = deleteCloudResourcesOnDestroy;
            return this;
        }

        /**
         * @param deleteCloudResourcesOnDestroy Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from Azure account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in Azure account itself.
         * 
         * @return builder
         * 
         */
        public Builder deleteCloudResourcesOnDestroy(Boolean deleteCloudResourcesOnDestroy) {
            return deleteCloudResourcesOnDestroy(Output.of(deleteCloudResourcesOnDestroy));
        }

        /**
         * @param hostName Hostname for the proxy
         * 
         * @return builder
         * 
         */
        public Builder hostName(Output<String> hostName) {
            $.hostName = hostName;
            return this;
        }

        /**
         * @param hostName Hostname for the proxy
         * 
         * @return builder
         * 
         */
        public Builder hostName(String hostName) {
            return hostName(Output.of(hostName));
        }

        /**
         * @param keypair Name of SSH Key to be used for proxy VM
         * 
         * @return builder
         * 
         */
        public Builder keypair(Output<String> keypair) {
            $.keypair = keypair;
            return this;
        }

        /**
         * @param keypair Name of SSH Key to be used for proxy VM
         * 
         * @return builder
         * 
         */
        public Builder keypair(String keypair) {
            return keypair(Output.of(keypair));
        }

        /**
         * @param machineType Type of instance to be used for proxy
         * 
         * @return builder
         * 
         */
        public Builder machineType(Output<String> machineType) {
            $.machineType = machineType;
            return this;
        }

        /**
         * @param machineType Type of instance to be used for proxy
         * 
         * @return builder
         * 
         */
        public Builder machineType(String machineType) {
            return machineType(Output.of(machineType));
        }

        /**
         * @param name Name of the proxy
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name Name of the proxy
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param region Region in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder region(Output<String> region) {
            $.region = region;
            return this;
        }

        /**
         * @param region Region in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            return region(Output.of(region));
        }

        /**
         * @param resourceGroup Resource group in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder resourceGroup(Output<String> resourceGroup) {
            $.resourceGroup = resourceGroup;
            return this;
        }

        /**
         * @param resourceGroup Resource group in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder resourceGroup(String resourceGroup) {
            return resourceGroup(Output.of(resourceGroup));
        }

        /**
         * @param securityGroups Security Group to define the security rules that determine the inbound and outbound traffic
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(@Nullable Output<List<String>> securityGroups) {
            $.securityGroups = securityGroups;
            return this;
        }

        /**
         * @param securityGroups Security Group to define the security rules that determine the inbound and outbound traffic
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(List<String> securityGroups) {
            return securityGroups(Output.of(securityGroups));
        }

        /**
         * @param securityGroups Security Group to define the security rules that determine the inbound and outbound traffic
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(String... securityGroups) {
            return securityGroups(List.of(securityGroups));
        }

        /**
         * @param subnetId Subnet in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder subnetId(Output<String> subnetId) {
            $.subnetId = subnetId;
            return this;
        }

        /**
         * @param subnetId Subnet in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder subnetId(String subnetId) {
            return subnetId(Output.of(subnetId));
        }

        /**
         * @param vpc VPC in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder vpc(Output<String> vpc) {
            $.vpc = vpc;
            return this;
        }

        /**
         * @param vpc VPC in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder vpc(String vpc) {
            return vpc(Output.of(vpc));
        }

        public AzureProxyArgs build() {
            if ($.apiKey == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "apiKey");
            }
            if ($.cloudConnectorId == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "cloudConnectorId");
            }
            if ($.deleteCloudResourcesOnDestroy == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "deleteCloudResourcesOnDestroy");
            }
            if ($.hostName == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "hostName");
            }
            if ($.keypair == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "keypair");
            }
            if ($.machineType == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "machineType");
            }
            if ($.region == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "region");
            }
            if ($.resourceGroup == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "resourceGroup");
            }
            if ($.subnetId == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "subnetId");
            }
            if ($.vpc == null) {
                throw new MissingRequiredPropertyException("AzureProxyArgs", "vpc");
            }
            return $;
        }
    }

}
