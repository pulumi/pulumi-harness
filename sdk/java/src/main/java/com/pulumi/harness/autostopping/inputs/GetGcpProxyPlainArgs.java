// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.harness.autostopping.inputs;

import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.harness.autostopping.inputs.GetGcpProxyCertificates;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class GetGcpProxyPlainArgs extends com.pulumi.resources.InvokeArgs {

    public static final GetGcpProxyPlainArgs Empty = new GetGcpProxyPlainArgs();

    /**
     * Boolean value to indicate if proxy vm needs to have static IP
     * 
     */
    @Import(name="allocateStaticIp")
    private @Nullable Boolean allocateStaticIp;

    /**
     * @return Boolean value to indicate if proxy vm needs to have static IP
     * 
     */
    public Optional<Boolean> allocateStaticIp() {
        return Optional.ofNullable(this.allocateStaticIp);
    }

    /**
     * Harness NG API key
     * 
     */
    @Import(name="apiKey", required=true)
    private String apiKey;

    /**
     * @return Harness NG API key
     * 
     */
    public String apiKey() {
        return this.apiKey;
    }

    @Import(name="certificates")
    private @Nullable GetGcpProxyCertificates certificates;

    public Optional<GetGcpProxyCertificates> certificates() {
        return Optional.ofNullable(this.certificates);
    }

    /**
     * Id of the cloud connector
     * 
     */
    @Import(name="cloudConnectorId", required=true)
    private String cloudConnectorId;

    /**
     * @return Id of the cloud connector
     * 
     */
    public String cloudConnectorId() {
        return this.cloudConnectorId;
    }

    /**
     * Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from GCP account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in GCP account itself.
     * 
     */
    @Import(name="deleteCloudResourcesOnDestroy", required=true)
    private Boolean deleteCloudResourcesOnDestroy;

    /**
     * @return Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from GCP account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in GCP account itself.
     * 
     */
    public Boolean deleteCloudResourcesOnDestroy() {
        return this.deleteCloudResourcesOnDestroy;
    }

    /**
     * Machine instance type
     * 
     */
    @Import(name="machineType", required=true)
    private String machineType;

    /**
     * @return Machine instance type
     * 
     */
    public String machineType() {
        return this.machineType;
    }

    /**
     * Name of the proxy
     * 
     */
    @Import(name="name", required=true)
    private String name;

    /**
     * @return Name of the proxy
     * 
     */
    public String name() {
        return this.name;
    }

    /**
     * Region in which cloud resources are hosted
     * 
     */
    @Import(name="region", required=true)
    private String region;

    /**
     * @return Region in which cloud resources are hosted
     * 
     */
    public String region() {
        return this.region;
    }

    /**
     * Security Group to define the security rules that determine the inbound and outbound traffic
     * 
     */
    @Import(name="securityGroups")
    private @Nullable List<String> securityGroups;

    /**
     * @return Security Group to define the security rules that determine the inbound and outbound traffic
     * 
     */
    public Optional<List<String>> securityGroups() {
        return Optional.ofNullable(this.securityGroups);
    }

    /**
     * VPC in which cloud resources are hosted
     * 
     */
    @Import(name="subnetId", required=true)
    private String subnetId;

    /**
     * @return VPC in which cloud resources are hosted
     * 
     */
    public String subnetId() {
        return this.subnetId;
    }

    /**
     * VPC in which cloud resources are hosted
     * 
     */
    @Import(name="vpc", required=true)
    private String vpc;

    /**
     * @return VPC in which cloud resources are hosted
     * 
     */
    public String vpc() {
        return this.vpc;
    }

    /**
     * Zone in which cloud resources are hosted
     * 
     */
    @Import(name="zone", required=true)
    private String zone;

    /**
     * @return Zone in which cloud resources are hosted
     * 
     */
    public String zone() {
        return this.zone;
    }

    private GetGcpProxyPlainArgs() {}

    private GetGcpProxyPlainArgs(GetGcpProxyPlainArgs $) {
        this.allocateStaticIp = $.allocateStaticIp;
        this.apiKey = $.apiKey;
        this.certificates = $.certificates;
        this.cloudConnectorId = $.cloudConnectorId;
        this.deleteCloudResourcesOnDestroy = $.deleteCloudResourcesOnDestroy;
        this.machineType = $.machineType;
        this.name = $.name;
        this.region = $.region;
        this.securityGroups = $.securityGroups;
        this.subnetId = $.subnetId;
        this.vpc = $.vpc;
        this.zone = $.zone;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(GetGcpProxyPlainArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private GetGcpProxyPlainArgs $;

        public Builder() {
            $ = new GetGcpProxyPlainArgs();
        }

        public Builder(GetGcpProxyPlainArgs defaults) {
            $ = new GetGcpProxyPlainArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param allocateStaticIp Boolean value to indicate if proxy vm needs to have static IP
         * 
         * @return builder
         * 
         */
        public Builder allocateStaticIp(@Nullable Boolean allocateStaticIp) {
            $.allocateStaticIp = allocateStaticIp;
            return this;
        }

        /**
         * @param apiKey Harness NG API key
         * 
         * @return builder
         * 
         */
        public Builder apiKey(String apiKey) {
            $.apiKey = apiKey;
            return this;
        }

        public Builder certificates(@Nullable GetGcpProxyCertificates certificates) {
            $.certificates = certificates;
            return this;
        }

        /**
         * @param cloudConnectorId Id of the cloud connector
         * 
         * @return builder
         * 
         */
        public Builder cloudConnectorId(String cloudConnectorId) {
            $.cloudConnectorId = cloudConnectorId;
            return this;
        }

        /**
         * @param deleteCloudResourcesOnDestroy Governs how the proxy entity will be deleted on Terraform destroy. When set to true, the associated VM will be deleted permanently from GCP account. Be fully aware of the consequneces of settting this to true, as the action is irreversible. When set to false, solely the Harness LB representation will be deleted, which leaves the proxy VM in GCP account itself.
         * 
         * @return builder
         * 
         */
        public Builder deleteCloudResourcesOnDestroy(Boolean deleteCloudResourcesOnDestroy) {
            $.deleteCloudResourcesOnDestroy = deleteCloudResourcesOnDestroy;
            return this;
        }

        /**
         * @param machineType Machine instance type
         * 
         * @return builder
         * 
         */
        public Builder machineType(String machineType) {
            $.machineType = machineType;
            return this;
        }

        /**
         * @param name Name of the proxy
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            $.name = name;
            return this;
        }

        /**
         * @param region Region in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder region(String region) {
            $.region = region;
            return this;
        }

        /**
         * @param securityGroups Security Group to define the security rules that determine the inbound and outbound traffic
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(@Nullable List<String> securityGroups) {
            $.securityGroups = securityGroups;
            return this;
        }

        /**
         * @param securityGroups Security Group to define the security rules that determine the inbound and outbound traffic
         * 
         * @return builder
         * 
         */
        public Builder securityGroups(String... securityGroups) {
            return securityGroups(List.of(securityGroups));
        }

        /**
         * @param subnetId VPC in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder subnetId(String subnetId) {
            $.subnetId = subnetId;
            return this;
        }

        /**
         * @param vpc VPC in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder vpc(String vpc) {
            $.vpc = vpc;
            return this;
        }

        /**
         * @param zone Zone in which cloud resources are hosted
         * 
         * @return builder
         * 
         */
        public Builder zone(String zone) {
            $.zone = zone;
            return this;
        }

        public GetGcpProxyPlainArgs build() {
            if ($.apiKey == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "apiKey");
            }
            if ($.cloudConnectorId == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "cloudConnectorId");
            }
            if ($.deleteCloudResourcesOnDestroy == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "deleteCloudResourcesOnDestroy");
            }
            if ($.machineType == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "machineType");
            }
            if ($.name == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "name");
            }
            if ($.region == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "region");
            }
            if ($.subnetId == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "subnetId");
            }
            if ($.vpc == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "vpc");
            }
            if ($.zone == null) {
                throw new MissingRequiredPropertyException("GetGcpProxyPlainArgs", "zone");
            }
            return $;
        }
    }

}
