// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package autostopping

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-harness/sdk/go/harness/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for creating a AutoStopping rule for VMs.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-harness/sdk/go/harness/autostopping"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := autostopping.NewRuleVm(ctx, "test", &autostopping.RuleVmArgs{
//				Name:             pulumi.String("name"),
//				CloudConnectorId: pulumi.String("cloud_connector_id"),
//				IdleTimeMins:     pulumi.Int(10),
//				DryRun:           pulumi.Bool(true),
//				Filter: &autostopping.RuleVmFilterArgs{
//					VmIds: pulumi.StringArray{
//						pulumi.String("/subscriptions/subscription_id/resourceGroups/resource_group/providers/Microsoft.Compute/virtualMachines/virtual_machine"),
//					},
//					Regions: pulumi.StringArray{
//						pulumi.String("useast2"),
//					},
//				},
//				Https: autostopping.RuleVmHttpArray{
//					&autostopping.RuleVmHttpArgs{
//						ProxyId: pulumi.String("proxy_id"),
//						Routings: autostopping.RuleVmHttpRoutingArray{
//							&autostopping.RuleVmHttpRoutingArgs{
//								SourceProtocol: pulumi.String("https"),
//								TargetProtocol: pulumi.String("https"),
//								SourcePort:     pulumi.Int(443),
//								TargetPort:     pulumi.Int(443),
//								Action:         pulumi.String("forward"),
//							},
//							&autostopping.RuleVmHttpRoutingArgs{
//								SourceProtocol: pulumi.String("http"),
//								TargetProtocol: pulumi.String("http"),
//								SourcePort:     pulumi.Int(80),
//								TargetPort:     pulumi.Int(80),
//								Action:         pulumi.String("forward"),
//							},
//						},
//						Healths: autostopping.RuleVmHttpHealthArray{
//							&autostopping.RuleVmHttpHealthArgs{
//								Protocol:       pulumi.String("http"),
//								Port:           pulumi.Int(80),
//								Path:           pulumi.String("/"),
//								Timeout:        pulumi.Int(30),
//								StatusCodeFrom: pulumi.Int(200),
//								StatusCodeTo:   pulumi.Int(299),
//							},
//						},
//					},
//				},
//				Tcps: autostopping.RuleVmTcpArray{
//					&autostopping.RuleVmTcpArgs{
//						ProxyId: pulumi.String("proxy_id"),
//						Sshes: autostopping.RuleVmTcpSshArray{
//							&autostopping.RuleVmTcpSshArgs{
//								Port: pulumi.Int(22),
//							},
//						},
//						Rdps: autostopping.RuleVmTcpRdpArray{
//							&autostopping.RuleVmTcpRdpArgs{
//								Port: pulumi.Int(3389),
//							},
//						},
//						ForwardRules: autostopping.RuleVmTcpForwardRuleArray{
//							&autostopping.RuleVmTcpForwardRuleArgs{
//								Port: pulumi.Int(2233),
//							},
//						},
//					},
//				},
//				Depends: autostopping.RuleVmDependArray{
//					&autostopping.RuleVmDependArgs{
//						RuleId:     pulumi.Int(24576),
//						DelayInSec: pulumi.Int(5),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type RuleVm struct {
	pulumi.CustomResourceState

	// Id of the cloud connector
	CloudConnectorId pulumi.StringOutput `pulumi:"cloudConnectorId"`
	// Custom URLs used to access the instances
	CustomDomains pulumi.StringArrayOutput `pulumi:"customDomains"`
	// Dependent rules
	Depends RuleVmDependArrayOutput `pulumi:"depends"`
	// Boolean that indicates whether the AutoStopping rule should be created in DryRun mode
	DryRun pulumi.BoolPtrOutput `pulumi:"dryRun"`
	Filter RuleVmFilterOutput   `pulumi:"filter"`
	// Http routing configuration
	Https RuleVmHttpArrayOutput `pulumi:"https"`
	// Unique identifier of the resource
	Identifier pulumi.Float64Output `pulumi:"identifier"`
	// Idle time in minutes. This is the time that the AutoStopping rule waits before stopping the idle instances.
	IdleTimeMins pulumi.IntPtrOutput `pulumi:"idleTimeMins"`
	// Name of the rule
	Name pulumi.StringOutput `pulumi:"name"`
	// TCP routing configuration
	Tcps RuleVmTcpArrayOutput `pulumi:"tcps"`
	// Boolean that indicates whether the selected instances should be converted to spot vm
	UseSpot pulumi.BoolPtrOutput `pulumi:"useSpot"`
}

// NewRuleVm registers a new resource with the given unique name, arguments, and options.
func NewRuleVm(ctx *pulumi.Context,
	name string, args *RuleVmArgs, opts ...pulumi.ResourceOption) (*RuleVm, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CloudConnectorId == nil {
		return nil, errors.New("invalid value for required argument 'CloudConnectorId'")
	}
	if args.Filter == nil {
		return nil, errors.New("invalid value for required argument 'Filter'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource RuleVm
	err := ctx.RegisterResource("harness:autostopping/ruleVm:RuleVm", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRuleVm gets an existing RuleVm resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRuleVm(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RuleVmState, opts ...pulumi.ResourceOption) (*RuleVm, error) {
	var resource RuleVm
	err := ctx.ReadResource("harness:autostopping/ruleVm:RuleVm", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RuleVm resources.
type ruleVmState struct {
	// Id of the cloud connector
	CloudConnectorId *string `pulumi:"cloudConnectorId"`
	// Custom URLs used to access the instances
	CustomDomains []string `pulumi:"customDomains"`
	// Dependent rules
	Depends []RuleVmDepend `pulumi:"depends"`
	// Boolean that indicates whether the AutoStopping rule should be created in DryRun mode
	DryRun *bool         `pulumi:"dryRun"`
	Filter *RuleVmFilter `pulumi:"filter"`
	// Http routing configuration
	Https []RuleVmHttp `pulumi:"https"`
	// Unique identifier of the resource
	Identifier *float64 `pulumi:"identifier"`
	// Idle time in minutes. This is the time that the AutoStopping rule waits before stopping the idle instances.
	IdleTimeMins *int `pulumi:"idleTimeMins"`
	// Name of the rule
	Name *string `pulumi:"name"`
	// TCP routing configuration
	Tcps []RuleVmTcp `pulumi:"tcps"`
	// Boolean that indicates whether the selected instances should be converted to spot vm
	UseSpot *bool `pulumi:"useSpot"`
}

type RuleVmState struct {
	// Id of the cloud connector
	CloudConnectorId pulumi.StringPtrInput
	// Custom URLs used to access the instances
	CustomDomains pulumi.StringArrayInput
	// Dependent rules
	Depends RuleVmDependArrayInput
	// Boolean that indicates whether the AutoStopping rule should be created in DryRun mode
	DryRun pulumi.BoolPtrInput
	Filter RuleVmFilterPtrInput
	// Http routing configuration
	Https RuleVmHttpArrayInput
	// Unique identifier of the resource
	Identifier pulumi.Float64PtrInput
	// Idle time in minutes. This is the time that the AutoStopping rule waits before stopping the idle instances.
	IdleTimeMins pulumi.IntPtrInput
	// Name of the rule
	Name pulumi.StringPtrInput
	// TCP routing configuration
	Tcps RuleVmTcpArrayInput
	// Boolean that indicates whether the selected instances should be converted to spot vm
	UseSpot pulumi.BoolPtrInput
}

func (RuleVmState) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleVmState)(nil)).Elem()
}

type ruleVmArgs struct {
	// Id of the cloud connector
	CloudConnectorId string `pulumi:"cloudConnectorId"`
	// Custom URLs used to access the instances
	CustomDomains []string `pulumi:"customDomains"`
	// Dependent rules
	Depends []RuleVmDepend `pulumi:"depends"`
	// Boolean that indicates whether the AutoStopping rule should be created in DryRun mode
	DryRun *bool        `pulumi:"dryRun"`
	Filter RuleVmFilter `pulumi:"filter"`
	// Http routing configuration
	Https []RuleVmHttp `pulumi:"https"`
	// Idle time in minutes. This is the time that the AutoStopping rule waits before stopping the idle instances.
	IdleTimeMins *int `pulumi:"idleTimeMins"`
	// Name of the rule
	Name *string `pulumi:"name"`
	// TCP routing configuration
	Tcps []RuleVmTcp `pulumi:"tcps"`
	// Boolean that indicates whether the selected instances should be converted to spot vm
	UseSpot *bool `pulumi:"useSpot"`
}

// The set of arguments for constructing a RuleVm resource.
type RuleVmArgs struct {
	// Id of the cloud connector
	CloudConnectorId pulumi.StringInput
	// Custom URLs used to access the instances
	CustomDomains pulumi.StringArrayInput
	// Dependent rules
	Depends RuleVmDependArrayInput
	// Boolean that indicates whether the AutoStopping rule should be created in DryRun mode
	DryRun pulumi.BoolPtrInput
	Filter RuleVmFilterInput
	// Http routing configuration
	Https RuleVmHttpArrayInput
	// Idle time in minutes. This is the time that the AutoStopping rule waits before stopping the idle instances.
	IdleTimeMins pulumi.IntPtrInput
	// Name of the rule
	Name pulumi.StringPtrInput
	// TCP routing configuration
	Tcps RuleVmTcpArrayInput
	// Boolean that indicates whether the selected instances should be converted to spot vm
	UseSpot pulumi.BoolPtrInput
}

func (RuleVmArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ruleVmArgs)(nil)).Elem()
}

type RuleVmInput interface {
	pulumi.Input

	ToRuleVmOutput() RuleVmOutput
	ToRuleVmOutputWithContext(ctx context.Context) RuleVmOutput
}

func (*RuleVm) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleVm)(nil)).Elem()
}

func (i *RuleVm) ToRuleVmOutput() RuleVmOutput {
	return i.ToRuleVmOutputWithContext(context.Background())
}

func (i *RuleVm) ToRuleVmOutputWithContext(ctx context.Context) RuleVmOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleVmOutput)
}

// RuleVmArrayInput is an input type that accepts RuleVmArray and RuleVmArrayOutput values.
// You can construct a concrete instance of `RuleVmArrayInput` via:
//
//	RuleVmArray{ RuleVmArgs{...} }
type RuleVmArrayInput interface {
	pulumi.Input

	ToRuleVmArrayOutput() RuleVmArrayOutput
	ToRuleVmArrayOutputWithContext(context.Context) RuleVmArrayOutput
}

type RuleVmArray []RuleVmInput

func (RuleVmArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RuleVm)(nil)).Elem()
}

func (i RuleVmArray) ToRuleVmArrayOutput() RuleVmArrayOutput {
	return i.ToRuleVmArrayOutputWithContext(context.Background())
}

func (i RuleVmArray) ToRuleVmArrayOutputWithContext(ctx context.Context) RuleVmArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleVmArrayOutput)
}

// RuleVmMapInput is an input type that accepts RuleVmMap and RuleVmMapOutput values.
// You can construct a concrete instance of `RuleVmMapInput` via:
//
//	RuleVmMap{ "key": RuleVmArgs{...} }
type RuleVmMapInput interface {
	pulumi.Input

	ToRuleVmMapOutput() RuleVmMapOutput
	ToRuleVmMapOutputWithContext(context.Context) RuleVmMapOutput
}

type RuleVmMap map[string]RuleVmInput

func (RuleVmMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RuleVm)(nil)).Elem()
}

func (i RuleVmMap) ToRuleVmMapOutput() RuleVmMapOutput {
	return i.ToRuleVmMapOutputWithContext(context.Background())
}

func (i RuleVmMap) ToRuleVmMapOutputWithContext(ctx context.Context) RuleVmMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RuleVmMapOutput)
}

type RuleVmOutput struct{ *pulumi.OutputState }

func (RuleVmOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RuleVm)(nil)).Elem()
}

func (o RuleVmOutput) ToRuleVmOutput() RuleVmOutput {
	return o
}

func (o RuleVmOutput) ToRuleVmOutputWithContext(ctx context.Context) RuleVmOutput {
	return o
}

// Id of the cloud connector
func (o RuleVmOutput) CloudConnectorId() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleVm) pulumi.StringOutput { return v.CloudConnectorId }).(pulumi.StringOutput)
}

// Custom URLs used to access the instances
func (o RuleVmOutput) CustomDomains() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RuleVm) pulumi.StringArrayOutput { return v.CustomDomains }).(pulumi.StringArrayOutput)
}

// Dependent rules
func (o RuleVmOutput) Depends() RuleVmDependArrayOutput {
	return o.ApplyT(func(v *RuleVm) RuleVmDependArrayOutput { return v.Depends }).(RuleVmDependArrayOutput)
}

// Boolean that indicates whether the AutoStopping rule should be created in DryRun mode
func (o RuleVmOutput) DryRun() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleVm) pulumi.BoolPtrOutput { return v.DryRun }).(pulumi.BoolPtrOutput)
}

func (o RuleVmOutput) Filter() RuleVmFilterOutput {
	return o.ApplyT(func(v *RuleVm) RuleVmFilterOutput { return v.Filter }).(RuleVmFilterOutput)
}

// Http routing configuration
func (o RuleVmOutput) Https() RuleVmHttpArrayOutput {
	return o.ApplyT(func(v *RuleVm) RuleVmHttpArrayOutput { return v.Https }).(RuleVmHttpArrayOutput)
}

// Unique identifier of the resource
func (o RuleVmOutput) Identifier() pulumi.Float64Output {
	return o.ApplyT(func(v *RuleVm) pulumi.Float64Output { return v.Identifier }).(pulumi.Float64Output)
}

// Idle time in minutes. This is the time that the AutoStopping rule waits before stopping the idle instances.
func (o RuleVmOutput) IdleTimeMins() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RuleVm) pulumi.IntPtrOutput { return v.IdleTimeMins }).(pulumi.IntPtrOutput)
}

// Name of the rule
func (o RuleVmOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RuleVm) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// TCP routing configuration
func (o RuleVmOutput) Tcps() RuleVmTcpArrayOutput {
	return o.ApplyT(func(v *RuleVm) RuleVmTcpArrayOutput { return v.Tcps }).(RuleVmTcpArrayOutput)
}

// Boolean that indicates whether the selected instances should be converted to spot vm
func (o RuleVmOutput) UseSpot() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RuleVm) pulumi.BoolPtrOutput { return v.UseSpot }).(pulumi.BoolPtrOutput)
}

type RuleVmArrayOutput struct{ *pulumi.OutputState }

func (RuleVmArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RuleVm)(nil)).Elem()
}

func (o RuleVmArrayOutput) ToRuleVmArrayOutput() RuleVmArrayOutput {
	return o
}

func (o RuleVmArrayOutput) ToRuleVmArrayOutputWithContext(ctx context.Context) RuleVmArrayOutput {
	return o
}

func (o RuleVmArrayOutput) Index(i pulumi.IntInput) RuleVmOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RuleVm {
		return vs[0].([]*RuleVm)[vs[1].(int)]
	}).(RuleVmOutput)
}

type RuleVmMapOutput struct{ *pulumi.OutputState }

func (RuleVmMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RuleVm)(nil)).Elem()
}

func (o RuleVmMapOutput) ToRuleVmMapOutput() RuleVmMapOutput {
	return o
}

func (o RuleVmMapOutput) ToRuleVmMapOutputWithContext(ctx context.Context) RuleVmMapOutput {
	return o
}

func (o RuleVmMapOutput) MapIndex(k pulumi.StringInput) RuleVmOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RuleVm {
		return vs[0].(map[string]*RuleVm)[vs[1].(string)]
	}).(RuleVmOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RuleVmInput)(nil)).Elem(), &RuleVm{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleVmArrayInput)(nil)).Elem(), RuleVmArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RuleVmMapInput)(nil)).Elem(), RuleVmMap{})
	pulumi.RegisterOutputType(RuleVmOutput{})
	pulumi.RegisterOutputType(RuleVmArrayOutput{})
	pulumi.RegisterOutputType(RuleVmMapOutput{})
}
