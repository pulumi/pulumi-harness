// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package harness

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-harness/sdk/go/harness/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for creating a Harness user
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-harness/sdk/go/harness"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := harness.NewUser(ctx, "john_doe", &harness.UserArgs{
//				Name:  pulumi.String("John Doe"),
//				Email: pulumi.String("john.doe@example.com"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// # Import using the email address of the user
//
// ```sh
// $ pulumi import harness:index/user:User john_doe john.doe@example.com
// ```
type User struct {
	pulumi.CustomResourceState

	// The email of the user.
	Email pulumi.StringOutput `pulumi:"email"`
	// The groups the user belongs to. This is only used during the creation of the user. The groups are not updated after the user is created. When using this option you should also set `lifecycle = { ignoreChanges = ["groupIds"] }`.
	GroupIds pulumi.StringArrayOutput `pulumi:"groupIds"`
	// Flag indicating whether or not the users email has been verified.
	IsEmailVerified pulumi.BoolOutput `pulumi:"isEmailVerified"`
	// Flag indicating whether or not the user was imported from an identity provider.
	IsImportedFromIdentityProvider pulumi.BoolOutput `pulumi:"isImportedFromIdentityProvider"`
	// Flag indicating whether or not the users password has expired.
	IsPasswordExpired pulumi.BoolOutput `pulumi:"isPasswordExpired"`
	// Flag indicating whether or not two-factor authentication is enabled for the user.
	IsTwoFactorAuthEnabled pulumi.BoolOutput `pulumi:"isTwoFactorAuthEnabled"`
	// Flag indicating whether or not the user is locked out.
	IsUserLocked pulumi.BoolOutput `pulumi:"isUserLocked"`
	// The name of the user.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewUser registers a new resource with the given unique name, arguments, and options.
func NewUser(ctx *pulumi.Context,
	name string, args *UserArgs, opts ...pulumi.ResourceOption) (*User, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Email == nil {
		return nil, errors.New("invalid value for required argument 'Email'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource User
	err := ctx.RegisterResource("harness:index/user:User", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetUser gets an existing User resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetUser(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *UserState, opts ...pulumi.ResourceOption) (*User, error) {
	var resource User
	err := ctx.ReadResource("harness:index/user:User", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering User resources.
type userState struct {
	// The email of the user.
	Email *string `pulumi:"email"`
	// The groups the user belongs to. This is only used during the creation of the user. The groups are not updated after the user is created. When using this option you should also set `lifecycle = { ignoreChanges = ["groupIds"] }`.
	GroupIds []string `pulumi:"groupIds"`
	// Flag indicating whether or not the users email has been verified.
	IsEmailVerified *bool `pulumi:"isEmailVerified"`
	// Flag indicating whether or not the user was imported from an identity provider.
	IsImportedFromIdentityProvider *bool `pulumi:"isImportedFromIdentityProvider"`
	// Flag indicating whether or not the users password has expired.
	IsPasswordExpired *bool `pulumi:"isPasswordExpired"`
	// Flag indicating whether or not two-factor authentication is enabled for the user.
	IsTwoFactorAuthEnabled *bool `pulumi:"isTwoFactorAuthEnabled"`
	// Flag indicating whether or not the user is locked out.
	IsUserLocked *bool `pulumi:"isUserLocked"`
	// The name of the user.
	Name *string `pulumi:"name"`
}

type UserState struct {
	// The email of the user.
	Email pulumi.StringPtrInput
	// The groups the user belongs to. This is only used during the creation of the user. The groups are not updated after the user is created. When using this option you should also set `lifecycle = { ignoreChanges = ["groupIds"] }`.
	GroupIds pulumi.StringArrayInput
	// Flag indicating whether or not the users email has been verified.
	IsEmailVerified pulumi.BoolPtrInput
	// Flag indicating whether or not the user was imported from an identity provider.
	IsImportedFromIdentityProvider pulumi.BoolPtrInput
	// Flag indicating whether or not the users password has expired.
	IsPasswordExpired pulumi.BoolPtrInput
	// Flag indicating whether or not two-factor authentication is enabled for the user.
	IsTwoFactorAuthEnabled pulumi.BoolPtrInput
	// Flag indicating whether or not the user is locked out.
	IsUserLocked pulumi.BoolPtrInput
	// The name of the user.
	Name pulumi.StringPtrInput
}

func (UserState) ElementType() reflect.Type {
	return reflect.TypeOf((*userState)(nil)).Elem()
}

type userArgs struct {
	// The email of the user.
	Email string `pulumi:"email"`
	// The groups the user belongs to. This is only used during the creation of the user. The groups are not updated after the user is created. When using this option you should also set `lifecycle = { ignoreChanges = ["groupIds"] }`.
	GroupIds []string `pulumi:"groupIds"`
	// The name of the user.
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a User resource.
type UserArgs struct {
	// The email of the user.
	Email pulumi.StringInput
	// The groups the user belongs to. This is only used during the creation of the user. The groups are not updated after the user is created. When using this option you should also set `lifecycle = { ignoreChanges = ["groupIds"] }`.
	GroupIds pulumi.StringArrayInput
	// The name of the user.
	Name pulumi.StringPtrInput
}

func (UserArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*userArgs)(nil)).Elem()
}

type UserInput interface {
	pulumi.Input

	ToUserOutput() UserOutput
	ToUserOutputWithContext(ctx context.Context) UserOutput
}

func (*User) ElementType() reflect.Type {
	return reflect.TypeOf((**User)(nil)).Elem()
}

func (i *User) ToUserOutput() UserOutput {
	return i.ToUserOutputWithContext(context.Background())
}

func (i *User) ToUserOutputWithContext(ctx context.Context) UserOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserOutput)
}

// UserArrayInput is an input type that accepts UserArray and UserArrayOutput values.
// You can construct a concrete instance of `UserArrayInput` via:
//
//	UserArray{ UserArgs{...} }
type UserArrayInput interface {
	pulumi.Input

	ToUserArrayOutput() UserArrayOutput
	ToUserArrayOutputWithContext(context.Context) UserArrayOutput
}

type UserArray []UserInput

func (UserArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*User)(nil)).Elem()
}

func (i UserArray) ToUserArrayOutput() UserArrayOutput {
	return i.ToUserArrayOutputWithContext(context.Background())
}

func (i UserArray) ToUserArrayOutputWithContext(ctx context.Context) UserArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserArrayOutput)
}

// UserMapInput is an input type that accepts UserMap and UserMapOutput values.
// You can construct a concrete instance of `UserMapInput` via:
//
//	UserMap{ "key": UserArgs{...} }
type UserMapInput interface {
	pulumi.Input

	ToUserMapOutput() UserMapOutput
	ToUserMapOutputWithContext(context.Context) UserMapOutput
}

type UserMap map[string]UserInput

func (UserMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*User)(nil)).Elem()
}

func (i UserMap) ToUserMapOutput() UserMapOutput {
	return i.ToUserMapOutputWithContext(context.Background())
}

func (i UserMap) ToUserMapOutputWithContext(ctx context.Context) UserMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(UserMapOutput)
}

type UserOutput struct{ *pulumi.OutputState }

func (UserOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**User)(nil)).Elem()
}

func (o UserOutput) ToUserOutput() UserOutput {
	return o
}

func (o UserOutput) ToUserOutputWithContext(ctx context.Context) UserOutput {
	return o
}

// The email of the user.
func (o UserOutput) Email() pulumi.StringOutput {
	return o.ApplyT(func(v *User) pulumi.StringOutput { return v.Email }).(pulumi.StringOutput)
}

// The groups the user belongs to. This is only used during the creation of the user. The groups are not updated after the user is created. When using this option you should also set `lifecycle = { ignoreChanges = ["groupIds"] }`.
func (o UserOutput) GroupIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *User) pulumi.StringArrayOutput { return v.GroupIds }).(pulumi.StringArrayOutput)
}

// Flag indicating whether or not the users email has been verified.
func (o UserOutput) IsEmailVerified() pulumi.BoolOutput {
	return o.ApplyT(func(v *User) pulumi.BoolOutput { return v.IsEmailVerified }).(pulumi.BoolOutput)
}

// Flag indicating whether or not the user was imported from an identity provider.
func (o UserOutput) IsImportedFromIdentityProvider() pulumi.BoolOutput {
	return o.ApplyT(func(v *User) pulumi.BoolOutput { return v.IsImportedFromIdentityProvider }).(pulumi.BoolOutput)
}

// Flag indicating whether or not the users password has expired.
func (o UserOutput) IsPasswordExpired() pulumi.BoolOutput {
	return o.ApplyT(func(v *User) pulumi.BoolOutput { return v.IsPasswordExpired }).(pulumi.BoolOutput)
}

// Flag indicating whether or not two-factor authentication is enabled for the user.
func (o UserOutput) IsTwoFactorAuthEnabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *User) pulumi.BoolOutput { return v.IsTwoFactorAuthEnabled }).(pulumi.BoolOutput)
}

// Flag indicating whether or not the user is locked out.
func (o UserOutput) IsUserLocked() pulumi.BoolOutput {
	return o.ApplyT(func(v *User) pulumi.BoolOutput { return v.IsUserLocked }).(pulumi.BoolOutput)
}

// The name of the user.
func (o UserOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *User) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type UserArrayOutput struct{ *pulumi.OutputState }

func (UserArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*User)(nil)).Elem()
}

func (o UserArrayOutput) ToUserArrayOutput() UserArrayOutput {
	return o
}

func (o UserArrayOutput) ToUserArrayOutputWithContext(ctx context.Context) UserArrayOutput {
	return o
}

func (o UserArrayOutput) Index(i pulumi.IntInput) UserOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *User {
		return vs[0].([]*User)[vs[1].(int)]
	}).(UserOutput)
}

type UserMapOutput struct{ *pulumi.OutputState }

func (UserMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*User)(nil)).Elem()
}

func (o UserMapOutput) ToUserMapOutput() UserMapOutput {
	return o
}

func (o UserMapOutput) ToUserMapOutputWithContext(ctx context.Context) UserMapOutput {
	return o
}

func (o UserMapOutput) MapIndex(k pulumi.StringInput) UserOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *User {
		return vs[0].(map[string]*User)[vs[1].(string)]
	}).(UserOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*UserInput)(nil)).Elem(), &User{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserArrayInput)(nil)).Elem(), UserArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*UserMapInput)(nil)).Elem(), UserMap{})
	pulumi.RegisterOutputType(UserOutput{})
	pulumi.RegisterOutputType(UserArrayOutput{})
	pulumi.RegisterOutputType(UserMapOutput{})
}
