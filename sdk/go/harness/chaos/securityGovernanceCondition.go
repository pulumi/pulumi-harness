// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package chaos

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-harness/sdk/go/harness/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for managing a Harness Chaos Security Governance Condition
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-harness/sdk/go/harness/chaos"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Example of a Kubernetes Security Governance Condition
//			k8sCondition, err := chaos.NewSecurityGovernanceCondition(ctx, "k8s_condition", &chaos.SecurityGovernanceConditionArgs{
//				OrgId:       pulumi.Any(orgId),
//				ProjectId:   pulumi.Any(projectId),
//				Name:        pulumi.String("k8s-security-condition"),
//				Description: pulumi.String("Security governance condition for Kubernetes workloads"),
//				InfraType:   pulumi.String("KubernetesV2"),
//				FaultSpec: &chaos.SecurityGovernanceConditionFaultSpecArgs{
//					Operator: pulumi.String("NOT_EQUAL_TO"),
//					Faults: chaos.SecurityGovernanceConditionFaultSpecFaultArray{
//						&chaos.SecurityGovernanceConditionFaultSpecFaultArgs{
//							FaultType: pulumi.String("FAULT"),
//							Name:      pulumi.String("pod-delete"),
//						},
//						&chaos.SecurityGovernanceConditionFaultSpecFaultArgs{
//							FaultType: pulumi.String("FAULT"),
//							Name:      pulumi.String("pod-dns"),
//						},
//					},
//				},
//				K8sSpec: &chaos.SecurityGovernanceConditionK8sSpecArgs{
//					InfraSpec: &chaos.SecurityGovernanceConditionK8sSpecInfraSpecArgs{
//						Operator: pulumi.String("EQUAL_TO"),
//						InfraIds: pulumi.StringArray{
//							k8sInfraId,
//						},
//					},
//					ApplicationSpec: &chaos.SecurityGovernanceConditionK8sSpecApplicationSpecArgs{
//						Operator: pulumi.String("EQUAL_TO"),
//						Workloads: chaos.SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArray{
//							&chaos.SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs{
//								Namespace: pulumi.String("default"),
//								Kind:      pulumi.String("deployment"),
//								Label:     pulumi.String("app=nginx"),
//								Services: pulumi.StringArray{
//									pulumi.String("nginx-service"),
//								},
//								ApplicationMapId: pulumi.String("nginx-app"),
//							},
//						},
//					},
//					ChaosServiceAccountSpec: &chaos.SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs{
//						Operator: pulumi.String("EQUAL_TO"),
//						ServiceAccounts: pulumi.StringArray{
//							pulumi.String("default"),
//							pulumi.String("chaos-service-account"),
//						},
//					},
//				},
//				Tags: pulumi.StringArray{
//					pulumi.String("env:prod"),
//					pulumi.String("team:security"),
//					pulumi.String("platform:k8s"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example of a Windows Security Governance Condition
//			windowsCondition, err := chaos.NewSecurityGovernanceCondition(ctx, "windows_condition", &chaos.SecurityGovernanceConditionArgs{
//				OrgId:       pulumi.Any(orgId),
//				ProjectId:   pulumi.Any(projectId),
//				Name:        pulumi.String("windows-security-condition"),
//				Description: pulumi.String("Security governance condition for Windows hosts"),
//				InfraType:   pulumi.String("Windows"),
//				FaultSpec: &chaos.SecurityGovernanceConditionFaultSpecArgs{
//					Operator: pulumi.String("NOT_EQUAL_TO"),
//					Faults: chaos.SecurityGovernanceConditionFaultSpecFaultArray{
//						&chaos.SecurityGovernanceConditionFaultSpecFaultArgs{
//							FaultType: pulumi.String("FAULT"),
//							Name:      pulumi.String("process-kill"),
//						},
//						&chaos.SecurityGovernanceConditionFaultSpecFaultArgs{
//							FaultType: pulumi.String("FAULT"),
//							Name:      pulumi.String("cpu-hog"),
//						},
//					},
//				},
//				MachineSpec: &chaos.SecurityGovernanceConditionMachineSpecArgs{
//					InfraSpec: &chaos.SecurityGovernanceConditionMachineSpecInfraSpecArgs{
//						Operator: pulumi.String("EQUAL_TO"),
//						InfraIds: pulumi.StringArray{
//							windowsInfraId,
//						},
//					},
//				},
//				Tags: pulumi.StringArray{
//					pulumi.String("env:prod"),
//					pulumi.String("team:security"),
//					pulumi.String("platform:windows"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Example of a Linux Security Governance Condition
//			linuxCondition, err := chaos.NewSecurityGovernanceCondition(ctx, "linux_condition", &chaos.SecurityGovernanceConditionArgs{
//				OrgId:       pulumi.Any(orgId),
//				ProjectId:   pulumi.Any(projectId),
//				Name:        pulumi.String("linux-security-condition"),
//				Description: pulumi.String("Security governance condition for Linux hosts"),
//				InfraType:   pulumi.String("Linux"),
//				FaultSpec: &chaos.SecurityGovernanceConditionFaultSpecArgs{
//					Operator: pulumi.String("NOT_EQUAL_TO"),
//					Faults: chaos.SecurityGovernanceConditionFaultSpecFaultArray{
//						&chaos.SecurityGovernanceConditionFaultSpecFaultArgs{
//							FaultType: pulumi.String("FAULT"),
//							Name:      pulumi.String("process-kill"),
//						},
//						&chaos.SecurityGovernanceConditionFaultSpecFaultArgs{
//							FaultType: pulumi.String("FAULT"),
//							Name:      pulumi.String("memory-hog"),
//						},
//					},
//				},
//				MachineSpec: &chaos.SecurityGovernanceConditionMachineSpecArgs{
//					InfraSpec: &chaos.SecurityGovernanceConditionMachineSpecInfraSpecArgs{
//						Operator: pulumi.String("EQUAL_TO"),
//						InfraIds: pulumi.StringArray{
//							linuxInfraId,
//						},
//					},
//				},
//				Tags: pulumi.StringArray{
//					pulumi.String("env:prod"),
//					pulumi.String("team:security"),
//					pulumi.String("platform:linux"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			ctx.Export("k8sConditionId", k8sCondition.ID())
//			ctx.Export("windowsConditionId", windowsCondition.ID())
//			ctx.Export("linuxConditionId", linuxCondition.ID())
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// # Import Project level Chaos Security Governance Condition
//
// ```sh
// $ pulumi import harness:chaos/securityGovernanceCondition:SecurityGovernanceCondition example org_id/project_id/condition_id
// ```
type SecurityGovernanceCondition struct {
	pulumi.CustomResourceState

	// Description of the security governance condition
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Specification for faults to be included in the condition
	FaultSpec SecurityGovernanceConditionFaultSpecOutput `pulumi:"faultSpec"`
	// Type of infrastructure (Kubernetes, KubernetesV2, Linux, Windows, CloudFoundry, Container)
	InfraType pulumi.StringOutput `pulumi:"infraType"`
	// Kubernetes specific configuration (required when infra*type is KUBERNETES or KUBERNETESV2)
	K8sSpec SecurityGovernanceConditionK8sSpecPtrOutput `pulumi:"k8sSpec"`
	// Machine specific configuration (required when infra*type is LINUX or WINDOWS)
	MachineSpec SecurityGovernanceConditionMachineSpecPtrOutput `pulumi:"machineSpec"`
	// Name of the security governance condition
	Name pulumi.StringOutput `pulumi:"name"`
	// The organization ID of the security governance condition
	OrgId pulumi.StringOutput `pulumi:"orgId"`
	// The project ID of the security governance condition
	ProjectId pulumi.StringOutput `pulumi:"projectId"`
	// Tags for the security governance condition
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
}

// NewSecurityGovernanceCondition registers a new resource with the given unique name, arguments, and options.
func NewSecurityGovernanceCondition(ctx *pulumi.Context,
	name string, args *SecurityGovernanceConditionArgs, opts ...pulumi.ResourceOption) (*SecurityGovernanceCondition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FaultSpec == nil {
		return nil, errors.New("invalid value for required argument 'FaultSpec'")
	}
	if args.InfraType == nil {
		return nil, errors.New("invalid value for required argument 'InfraType'")
	}
	if args.OrgId == nil {
		return nil, errors.New("invalid value for required argument 'OrgId'")
	}
	if args.ProjectId == nil {
		return nil, errors.New("invalid value for required argument 'ProjectId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SecurityGovernanceCondition
	err := ctx.RegisterResource("harness:chaos/securityGovernanceCondition:SecurityGovernanceCondition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSecurityGovernanceCondition gets an existing SecurityGovernanceCondition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSecurityGovernanceCondition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SecurityGovernanceConditionState, opts ...pulumi.ResourceOption) (*SecurityGovernanceCondition, error) {
	var resource SecurityGovernanceCondition
	err := ctx.ReadResource("harness:chaos/securityGovernanceCondition:SecurityGovernanceCondition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SecurityGovernanceCondition resources.
type securityGovernanceConditionState struct {
	// Description of the security governance condition
	Description *string `pulumi:"description"`
	// Specification for faults to be included in the condition
	FaultSpec *SecurityGovernanceConditionFaultSpec `pulumi:"faultSpec"`
	// Type of infrastructure (Kubernetes, KubernetesV2, Linux, Windows, CloudFoundry, Container)
	InfraType *string `pulumi:"infraType"`
	// Kubernetes specific configuration (required when infra*type is KUBERNETES or KUBERNETESV2)
	K8sSpec *SecurityGovernanceConditionK8sSpec `pulumi:"k8sSpec"`
	// Machine specific configuration (required when infra*type is LINUX or WINDOWS)
	MachineSpec *SecurityGovernanceConditionMachineSpec `pulumi:"machineSpec"`
	// Name of the security governance condition
	Name *string `pulumi:"name"`
	// The organization ID of the security governance condition
	OrgId *string `pulumi:"orgId"`
	// The project ID of the security governance condition
	ProjectId *string `pulumi:"projectId"`
	// Tags for the security governance condition
	Tags []string `pulumi:"tags"`
}

type SecurityGovernanceConditionState struct {
	// Description of the security governance condition
	Description pulumi.StringPtrInput
	// Specification for faults to be included in the condition
	FaultSpec SecurityGovernanceConditionFaultSpecPtrInput
	// Type of infrastructure (Kubernetes, KubernetesV2, Linux, Windows, CloudFoundry, Container)
	InfraType pulumi.StringPtrInput
	// Kubernetes specific configuration (required when infra*type is KUBERNETES or KUBERNETESV2)
	K8sSpec SecurityGovernanceConditionK8sSpecPtrInput
	// Machine specific configuration (required when infra*type is LINUX or WINDOWS)
	MachineSpec SecurityGovernanceConditionMachineSpecPtrInput
	// Name of the security governance condition
	Name pulumi.StringPtrInput
	// The organization ID of the security governance condition
	OrgId pulumi.StringPtrInput
	// The project ID of the security governance condition
	ProjectId pulumi.StringPtrInput
	// Tags for the security governance condition
	Tags pulumi.StringArrayInput
}

func (SecurityGovernanceConditionState) ElementType() reflect.Type {
	return reflect.TypeOf((*securityGovernanceConditionState)(nil)).Elem()
}

type securityGovernanceConditionArgs struct {
	// Description of the security governance condition
	Description *string `pulumi:"description"`
	// Specification for faults to be included in the condition
	FaultSpec SecurityGovernanceConditionFaultSpec `pulumi:"faultSpec"`
	// Type of infrastructure (Kubernetes, KubernetesV2, Linux, Windows, CloudFoundry, Container)
	InfraType string `pulumi:"infraType"`
	// Kubernetes specific configuration (required when infra*type is KUBERNETES or KUBERNETESV2)
	K8sSpec *SecurityGovernanceConditionK8sSpec `pulumi:"k8sSpec"`
	// Machine specific configuration (required when infra*type is LINUX or WINDOWS)
	MachineSpec *SecurityGovernanceConditionMachineSpec `pulumi:"machineSpec"`
	// Name of the security governance condition
	Name *string `pulumi:"name"`
	// The organization ID of the security governance condition
	OrgId string `pulumi:"orgId"`
	// The project ID of the security governance condition
	ProjectId string `pulumi:"projectId"`
	// Tags for the security governance condition
	Tags []string `pulumi:"tags"`
}

// The set of arguments for constructing a SecurityGovernanceCondition resource.
type SecurityGovernanceConditionArgs struct {
	// Description of the security governance condition
	Description pulumi.StringPtrInput
	// Specification for faults to be included in the condition
	FaultSpec SecurityGovernanceConditionFaultSpecInput
	// Type of infrastructure (Kubernetes, KubernetesV2, Linux, Windows, CloudFoundry, Container)
	InfraType pulumi.StringInput
	// Kubernetes specific configuration (required when infra*type is KUBERNETES or KUBERNETESV2)
	K8sSpec SecurityGovernanceConditionK8sSpecPtrInput
	// Machine specific configuration (required when infra*type is LINUX or WINDOWS)
	MachineSpec SecurityGovernanceConditionMachineSpecPtrInput
	// Name of the security governance condition
	Name pulumi.StringPtrInput
	// The organization ID of the security governance condition
	OrgId pulumi.StringInput
	// The project ID of the security governance condition
	ProjectId pulumi.StringInput
	// Tags for the security governance condition
	Tags pulumi.StringArrayInput
}

func (SecurityGovernanceConditionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*securityGovernanceConditionArgs)(nil)).Elem()
}

type SecurityGovernanceConditionInput interface {
	pulumi.Input

	ToSecurityGovernanceConditionOutput() SecurityGovernanceConditionOutput
	ToSecurityGovernanceConditionOutputWithContext(ctx context.Context) SecurityGovernanceConditionOutput
}

func (*SecurityGovernanceCondition) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityGovernanceCondition)(nil)).Elem()
}

func (i *SecurityGovernanceCondition) ToSecurityGovernanceConditionOutput() SecurityGovernanceConditionOutput {
	return i.ToSecurityGovernanceConditionOutputWithContext(context.Background())
}

func (i *SecurityGovernanceCondition) ToSecurityGovernanceConditionOutputWithContext(ctx context.Context) SecurityGovernanceConditionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityGovernanceConditionOutput)
}

// SecurityGovernanceConditionArrayInput is an input type that accepts SecurityGovernanceConditionArray and SecurityGovernanceConditionArrayOutput values.
// You can construct a concrete instance of `SecurityGovernanceConditionArrayInput` via:
//
//	SecurityGovernanceConditionArray{ SecurityGovernanceConditionArgs{...} }
type SecurityGovernanceConditionArrayInput interface {
	pulumi.Input

	ToSecurityGovernanceConditionArrayOutput() SecurityGovernanceConditionArrayOutput
	ToSecurityGovernanceConditionArrayOutputWithContext(context.Context) SecurityGovernanceConditionArrayOutput
}

type SecurityGovernanceConditionArray []SecurityGovernanceConditionInput

func (SecurityGovernanceConditionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SecurityGovernanceCondition)(nil)).Elem()
}

func (i SecurityGovernanceConditionArray) ToSecurityGovernanceConditionArrayOutput() SecurityGovernanceConditionArrayOutput {
	return i.ToSecurityGovernanceConditionArrayOutputWithContext(context.Background())
}

func (i SecurityGovernanceConditionArray) ToSecurityGovernanceConditionArrayOutputWithContext(ctx context.Context) SecurityGovernanceConditionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityGovernanceConditionArrayOutput)
}

// SecurityGovernanceConditionMapInput is an input type that accepts SecurityGovernanceConditionMap and SecurityGovernanceConditionMapOutput values.
// You can construct a concrete instance of `SecurityGovernanceConditionMapInput` via:
//
//	SecurityGovernanceConditionMap{ "key": SecurityGovernanceConditionArgs{...} }
type SecurityGovernanceConditionMapInput interface {
	pulumi.Input

	ToSecurityGovernanceConditionMapOutput() SecurityGovernanceConditionMapOutput
	ToSecurityGovernanceConditionMapOutputWithContext(context.Context) SecurityGovernanceConditionMapOutput
}

type SecurityGovernanceConditionMap map[string]SecurityGovernanceConditionInput

func (SecurityGovernanceConditionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SecurityGovernanceCondition)(nil)).Elem()
}

func (i SecurityGovernanceConditionMap) ToSecurityGovernanceConditionMapOutput() SecurityGovernanceConditionMapOutput {
	return i.ToSecurityGovernanceConditionMapOutputWithContext(context.Background())
}

func (i SecurityGovernanceConditionMap) ToSecurityGovernanceConditionMapOutputWithContext(ctx context.Context) SecurityGovernanceConditionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SecurityGovernanceConditionMapOutput)
}

type SecurityGovernanceConditionOutput struct{ *pulumi.OutputState }

func (SecurityGovernanceConditionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SecurityGovernanceCondition)(nil)).Elem()
}

func (o SecurityGovernanceConditionOutput) ToSecurityGovernanceConditionOutput() SecurityGovernanceConditionOutput {
	return o
}

func (o SecurityGovernanceConditionOutput) ToSecurityGovernanceConditionOutputWithContext(ctx context.Context) SecurityGovernanceConditionOutput {
	return o
}

// Description of the security governance condition
func (o SecurityGovernanceConditionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Specification for faults to be included in the condition
func (o SecurityGovernanceConditionOutput) FaultSpec() SecurityGovernanceConditionFaultSpecOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) SecurityGovernanceConditionFaultSpecOutput { return v.FaultSpec }).(SecurityGovernanceConditionFaultSpecOutput)
}

// Type of infrastructure (Kubernetes, KubernetesV2, Linux, Windows, CloudFoundry, Container)
func (o SecurityGovernanceConditionOutput) InfraType() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) pulumi.StringOutput { return v.InfraType }).(pulumi.StringOutput)
}

// Kubernetes specific configuration (required when infra*type is KUBERNETES or KUBERNETESV2)
func (o SecurityGovernanceConditionOutput) K8sSpec() SecurityGovernanceConditionK8sSpecPtrOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) SecurityGovernanceConditionK8sSpecPtrOutput { return v.K8sSpec }).(SecurityGovernanceConditionK8sSpecPtrOutput)
}

// Machine specific configuration (required when infra*type is LINUX or WINDOWS)
func (o SecurityGovernanceConditionOutput) MachineSpec() SecurityGovernanceConditionMachineSpecPtrOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) SecurityGovernanceConditionMachineSpecPtrOutput {
		return v.MachineSpec
	}).(SecurityGovernanceConditionMachineSpecPtrOutput)
}

// Name of the security governance condition
func (o SecurityGovernanceConditionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The organization ID of the security governance condition
func (o SecurityGovernanceConditionOutput) OrgId() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) pulumi.StringOutput { return v.OrgId }).(pulumi.StringOutput)
}

// The project ID of the security governance condition
func (o SecurityGovernanceConditionOutput) ProjectId() pulumi.StringOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) pulumi.StringOutput { return v.ProjectId }).(pulumi.StringOutput)
}

// Tags for the security governance condition
func (o SecurityGovernanceConditionOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *SecurityGovernanceCondition) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

type SecurityGovernanceConditionArrayOutput struct{ *pulumi.OutputState }

func (SecurityGovernanceConditionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SecurityGovernanceCondition)(nil)).Elem()
}

func (o SecurityGovernanceConditionArrayOutput) ToSecurityGovernanceConditionArrayOutput() SecurityGovernanceConditionArrayOutput {
	return o
}

func (o SecurityGovernanceConditionArrayOutput) ToSecurityGovernanceConditionArrayOutputWithContext(ctx context.Context) SecurityGovernanceConditionArrayOutput {
	return o
}

func (o SecurityGovernanceConditionArrayOutput) Index(i pulumi.IntInput) SecurityGovernanceConditionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SecurityGovernanceCondition {
		return vs[0].([]*SecurityGovernanceCondition)[vs[1].(int)]
	}).(SecurityGovernanceConditionOutput)
}

type SecurityGovernanceConditionMapOutput struct{ *pulumi.OutputState }

func (SecurityGovernanceConditionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SecurityGovernanceCondition)(nil)).Elem()
}

func (o SecurityGovernanceConditionMapOutput) ToSecurityGovernanceConditionMapOutput() SecurityGovernanceConditionMapOutput {
	return o
}

func (o SecurityGovernanceConditionMapOutput) ToSecurityGovernanceConditionMapOutputWithContext(ctx context.Context) SecurityGovernanceConditionMapOutput {
	return o
}

func (o SecurityGovernanceConditionMapOutput) MapIndex(k pulumi.StringInput) SecurityGovernanceConditionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SecurityGovernanceCondition {
		return vs[0].(map[string]*SecurityGovernanceCondition)[vs[1].(string)]
	}).(SecurityGovernanceConditionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityGovernanceConditionInput)(nil)).Elem(), &SecurityGovernanceCondition{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityGovernanceConditionArrayInput)(nil)).Elem(), SecurityGovernanceConditionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SecurityGovernanceConditionMapInput)(nil)).Elem(), SecurityGovernanceConditionMap{})
	pulumi.RegisterOutputType(SecurityGovernanceConditionOutput{})
	pulumi.RegisterOutputType(SecurityGovernanceConditionArrayOutput{})
	pulumi.RegisterOutputType(SecurityGovernanceConditionMapOutput{})
}
