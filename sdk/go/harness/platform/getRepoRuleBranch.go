// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package platform

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi-harness/sdk/go/harness/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Data source for retrieving a Harness repo branch rule.
func LookupRepoRuleBranch(ctx *pulumi.Context, args *LookupRepoRuleBranchArgs, opts ...pulumi.InvokeOption) (*LookupRepoRuleBranchResult, error) {
	opts = internal.PkgInvokeDefaultOpts(opts)
	var rv LookupRepoRuleBranchResult
	err := ctx.Invoke("harness:platform/getRepoRuleBranch:getRepoRuleBranch", args, &rv, opts...)
	if err != nil {
		return nil, err
	}
	return &rv, nil
}

// A collection of arguments for invoking getRepoRuleBranch.
type LookupRepoRuleBranchArgs struct {
	// List of users who can bypass this rule.
	Bypasses []GetRepoRuleBranchBypass `pulumi:"bypasses"`
	// Description of the rule.
	Description *string `pulumi:"description"`
	// Identifier of the rule.
	Identifier string `pulumi:"identifier"`
	// Unique identifier of the organization.
	OrgId *string `pulumi:"orgId"`
	// Pattern of branch to which rule will apply.
	Patterns []GetRepoRuleBranchPattern `pulumi:"patterns"`
	// Policies to be applied for this rule.
	Policies []GetRepoRuleBranchPolicy `pulumi:"policies"`
	// Unique identifier of the project.
	ProjectId *string `pulumi:"projectId"`
	// Repo identifier of the repository.
	RepoIdentifier string `pulumi:"repoIdentifier"`
	// State of the rule (active, disable, monitor).
	State string `pulumi:"state"`
}

// A collection of values returned by getRepoRuleBranch.
type LookupRepoRuleBranchResult struct {
	// List of users who can bypass this rule.
	Bypasses []GetRepoRuleBranchBypass `pulumi:"bypasses"`
	// Timestamp when the rule was created.
	Created int `pulumi:"created"`
	// ID of the user who created the rule.
	CreatedBy int `pulumi:"createdBy"`
	// Description of the rule.
	Description *string `pulumi:"description"`
	// The provider-assigned unique ID for this managed resource.
	Id string `pulumi:"id"`
	// Identifier of the rule.
	Identifier string `pulumi:"identifier"`
	// Unique identifier of the organization.
	OrgId *string `pulumi:"orgId"`
	// Pattern of branch to which rule will apply.
	Patterns []GetRepoRuleBranchPattern `pulumi:"patterns"`
	// Policies to be applied for this rule.
	Policies []GetRepoRuleBranchPolicy `pulumi:"policies"`
	// Unique identifier of the project.
	ProjectId *string `pulumi:"projectId"`
	// Repo identifier of the repository.
	RepoIdentifier string `pulumi:"repoIdentifier"`
	// State of the rule (active, disable, monitor).
	State string `pulumi:"state"`
	// Timestamp when the rule was updated.
	Updated int `pulumi:"updated"`
	// ID of the user who updated the rule.
	UpdatedBy int `pulumi:"updatedBy"`
}

func LookupRepoRuleBranchOutput(ctx *pulumi.Context, args LookupRepoRuleBranchOutputArgs, opts ...pulumi.InvokeOption) LookupRepoRuleBranchResultOutput {
	return pulumi.ToOutputWithContext(context.Background(), args).
		ApplyT(func(v interface{}) (LookupRepoRuleBranchResultOutput, error) {
			args := v.(LookupRepoRuleBranchArgs)
			opts = internal.PkgInvokeDefaultOpts(opts)
			var rv LookupRepoRuleBranchResult
			secret, err := ctx.InvokePackageRaw("harness:platform/getRepoRuleBranch:getRepoRuleBranch", args, &rv, "", opts...)
			if err != nil {
				return LookupRepoRuleBranchResultOutput{}, err
			}

			output := pulumi.ToOutput(rv).(LookupRepoRuleBranchResultOutput)
			if secret {
				return pulumi.ToSecret(output).(LookupRepoRuleBranchResultOutput), nil
			}
			return output, nil
		}).(LookupRepoRuleBranchResultOutput)
}

// A collection of arguments for invoking getRepoRuleBranch.
type LookupRepoRuleBranchOutputArgs struct {
	// List of users who can bypass this rule.
	Bypasses GetRepoRuleBranchBypassArrayInput `pulumi:"bypasses"`
	// Description of the rule.
	Description pulumi.StringPtrInput `pulumi:"description"`
	// Identifier of the rule.
	Identifier pulumi.StringInput `pulumi:"identifier"`
	// Unique identifier of the organization.
	OrgId pulumi.StringPtrInput `pulumi:"orgId"`
	// Pattern of branch to which rule will apply.
	Patterns GetRepoRuleBranchPatternArrayInput `pulumi:"patterns"`
	// Policies to be applied for this rule.
	Policies GetRepoRuleBranchPolicyArrayInput `pulumi:"policies"`
	// Unique identifier of the project.
	ProjectId pulumi.StringPtrInput `pulumi:"projectId"`
	// Repo identifier of the repository.
	RepoIdentifier pulumi.StringInput `pulumi:"repoIdentifier"`
	// State of the rule (active, disable, monitor).
	State pulumi.StringInput `pulumi:"state"`
}

func (LookupRepoRuleBranchOutputArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupRepoRuleBranchArgs)(nil)).Elem()
}

// A collection of values returned by getRepoRuleBranch.
type LookupRepoRuleBranchResultOutput struct{ *pulumi.OutputState }

func (LookupRepoRuleBranchResultOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LookupRepoRuleBranchResult)(nil)).Elem()
}

func (o LookupRepoRuleBranchResultOutput) ToLookupRepoRuleBranchResultOutput() LookupRepoRuleBranchResultOutput {
	return o
}

func (o LookupRepoRuleBranchResultOutput) ToLookupRepoRuleBranchResultOutputWithContext(ctx context.Context) LookupRepoRuleBranchResultOutput {
	return o
}

// List of users who can bypass this rule.
func (o LookupRepoRuleBranchResultOutput) Bypasses() GetRepoRuleBranchBypassArrayOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) []GetRepoRuleBranchBypass { return v.Bypasses }).(GetRepoRuleBranchBypassArrayOutput)
}

// Timestamp when the rule was created.
func (o LookupRepoRuleBranchResultOutput) Created() pulumi.IntOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) int { return v.Created }).(pulumi.IntOutput)
}

// ID of the user who created the rule.
func (o LookupRepoRuleBranchResultOutput) CreatedBy() pulumi.IntOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) int { return v.CreatedBy }).(pulumi.IntOutput)
}

// Description of the rule.
func (o LookupRepoRuleBranchResultOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) *string { return v.Description }).(pulumi.StringPtrOutput)
}

// The provider-assigned unique ID for this managed resource.
func (o LookupRepoRuleBranchResultOutput) Id() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) string { return v.Id }).(pulumi.StringOutput)
}

// Identifier of the rule.
func (o LookupRepoRuleBranchResultOutput) Identifier() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) string { return v.Identifier }).(pulumi.StringOutput)
}

// Unique identifier of the organization.
func (o LookupRepoRuleBranchResultOutput) OrgId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) *string { return v.OrgId }).(pulumi.StringPtrOutput)
}

// Pattern of branch to which rule will apply.
func (o LookupRepoRuleBranchResultOutput) Patterns() GetRepoRuleBranchPatternArrayOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) []GetRepoRuleBranchPattern { return v.Patterns }).(GetRepoRuleBranchPatternArrayOutput)
}

// Policies to be applied for this rule.
func (o LookupRepoRuleBranchResultOutput) Policies() GetRepoRuleBranchPolicyArrayOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) []GetRepoRuleBranchPolicy { return v.Policies }).(GetRepoRuleBranchPolicyArrayOutput)
}

// Unique identifier of the project.
func (o LookupRepoRuleBranchResultOutput) ProjectId() pulumi.StringPtrOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) *string { return v.ProjectId }).(pulumi.StringPtrOutput)
}

// Repo identifier of the repository.
func (o LookupRepoRuleBranchResultOutput) RepoIdentifier() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) string { return v.RepoIdentifier }).(pulumi.StringOutput)
}

// State of the rule (active, disable, monitor).
func (o LookupRepoRuleBranchResultOutput) State() pulumi.StringOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) string { return v.State }).(pulumi.StringOutput)
}

// Timestamp when the rule was updated.
func (o LookupRepoRuleBranchResultOutput) Updated() pulumi.IntOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) int { return v.Updated }).(pulumi.IntOutput)
}

// ID of the user who updated the rule.
func (o LookupRepoRuleBranchResultOutput) UpdatedBy() pulumi.IntOutput {
	return o.ApplyT(func(v LookupRepoRuleBranchResult) int { return v.UpdatedBy }).(pulumi.IntOutput)
}

func init() {
	pulumi.RegisterOutputType(LookupRepoRuleBranchResultOutput{})
}
