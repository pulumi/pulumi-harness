// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * The name of the service
     */
    serviceName?: pulumi.Input<string>;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: pulumi.Input<string>;
    /**
     * The value of the service variable
     */
    value: pulumi.Input<string>;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetEncryptedTextUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetEnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name?: string;
    /**
     * The name of the service
     */
    serviceName?: string;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type?: string;
    /**
     * The value of the service variable
     */
    value?: string;
}

export interface GetEnvironmentVariableOverrideArgs {
    /**
     * The name of the variable
     */
    name?: pulumi.Input<string>;
    /**
     * The name of the service
     */
    serviceName?: pulumi.Input<string>;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type?: pulumi.Input<string>;
    /**
     * The value of the service variable
     */
    value?: pulumi.Input<string>;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSecretManagerUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: pulumi.Input<string>;
    /**
     * The name of the author
     */
    authorName?: pulumi.Input<string>;
    /**
     * Commit message
     */
    message?: pulumi.Input<string>;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: pulumi.Input<string>;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: pulumi.Input<boolean>;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: pulumi.Input<string>;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: pulumi.Input<string>;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: pulumi.Input<boolean>;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: pulumi.Input<boolean>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: pulumi.Input<string>;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The IAM role to use.
     */
    iamRole?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: pulumi.Input<pulumi.Input<inputs.InfrastructureDefinitionAwsSshTag>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionAwsSshTag {
    /**
     * The key of the tag.
     */
    key: pulumi.Input<string>;
    /**
     * The value of the tag.
     */
    value: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: pulumi.Input<string>;
    /**
     * Base name.
     */
    baseName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: pulumi.Input<string>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
    /**
     * The username to connect with.
     */
    username: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroup: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
}

export interface InfrastructureDefinitionCustom {
    /**
     * The template version
     */
    deploymentTypeTemplateVersion: pulumi.Input<string>;
    /**
     * Variables to be used in the service
     */
    variables?: pulumi.Input<pulumi.Input<inputs.InfrastructureDefinitionCustomVariable>[]>;
}

export interface InfrastructureDefinitionCustomVariable {
    /**
     * Name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Value of the variable
     */
    value: pulumi.Input<string>;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release.
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The PCF organization to use.
     */
    organization: pulumi.Input<string>;
    /**
     * The PCF space to deploy to.
     */
    space: pulumi.Input<string>;
}

export interface PlatformCcmFiltersFilterProperties {
    /**
     * Type of CCM filters.
     */
    filterType: pulumi.Input<string>;
    /**
     * Tags to associate with the resource. Tags should be in the form `name:value`.
     */
    tags?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: pulumi.Input<number>;
    /**
     * Name of the principal for authentication
     */
    principal: pulumi.Input<string>;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: pulumi.Input<string>;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: pulumi.Input<inputs.SshCredentialKerberosAuthenticationTgtGenerationMethod>;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    /**
     * The id of the encrypted text secret
     */
    kerberosPasswordId?: pulumi.Input<string>;
    /**
     * The path to the key tab file
     */
    keyTabFilePath?: pulumi.Input<string>;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: pulumi.Input<inputs.SshCredentialSshAuthenticationInlineSsh>;
    /**
     * The port to connect to
     */
    port: pulumi.Input<number>;
    /**
     * Server password authentication configuration
     */
    serverPassword?: pulumi.Input<inputs.SshCredentialSshAuthenticationServerPassword>;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: pulumi.Input<inputs.SshCredentialSshAuthenticationSshKeyFile>;
    /**
     * The username to use when connecting to ssh
     */
    username: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    /**
     * The id of the encrypted secret to use
     */
    passphraseSecretId?: pulumi.Input<string>;
    /**
     * The id of the secret containing the SSH key
     */
    sshKeyFileId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationServerPassword {
    /**
     * The id of the encrypted secret
     */
    passwordSecretId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    /**
     * The id of the secret containing the password to use for the ssh key
     */
    passphraseSecretId?: pulumi.Input<string>;
    /**
     * The path to the key file on the delegate
     */
    path: pulumi.Input<string>;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: pulumi.Input<string>;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: pulumi.Input<string>;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: pulumi.Input<boolean>;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: pulumi.Input<boolean>;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: pulumi.Input<string>;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: pulumi.Input<string>;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Application specific permissions
     */
    appPermissions?: pulumi.Input<inputs.UserGroupPermissionsAppPermissions>;
}

export interface UserGroupPermissionsAppPermissions {
    /**
     * The permission to perform actions against all resources.
     */
    alls?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsAll>[]>;
    /**
     * Permission configuration to perform actions against deployments.
     */
    deployments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsDeployment>[]>;
    /**
     * Permission configuration to perform actions against workflows.
     */
    environments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsEnvironment>[]>;
    /**
     * Permission configuration to perform actions against pipelines.
     */
    pipelines?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsPipeline>[]>;
    /**
     * Permission configuration to perform actions against provisioners.
     */
    provisioners?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsProvisioner>[]>;
    /**
     * Permission configuration to perform actions against services.
     */
    services?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsService>[]>;
    /**
     * Permission configuration to perform actions against templates.
     */
    templates?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsTemplate>[]>;
    /**
     * Permission configuration to perform actions against workflows.
     */
    workflows?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsWorkflow>[]>;
}

export interface UserGroupPermissionsAppPermissionsAll {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK_WORKFLOW
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    /**
     * The actions allowed to be performed. Valid options are READ, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK*WORKFLOW, ABORT*WORKFLOW
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The environment IDs to which the permission applies. Leave empty to apply to all environments.
     */
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The environment IDs to which the permission applies. Leave empty to apply to all environments.
     */
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    /**
     * The actions allowed to be performed. Valid options are [CREATE READ UPDATE DELETE]
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The environment IDs to which the permission applies. Leave empty to apply to all environments.
     */
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The filters to apply to the action. Valid options are: NON*PRODUCTION*PIPELINES, PRODUCTION_PIPELINES.
     */
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The provisioner IDs to which the permission applies. Leave empty to apply to all provisioners.
     */
    provisionerIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsService {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The service IDs to which the permission applies. Leave empty to apply to all services.
     */
    serviceIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The template IDs to which the permission applies. Leave empty to apply to all environments.
     */
    templateIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    /**
     * The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The application IDs to which the permission applies. Leave empty to apply to all applications.
     */
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The filters to apply to the action. Valid options are: NON*PRODUCTION*WORKFLOWS, PRODUCTION*WORKFLOWS, WORKFLOW*TEMPLATES.
     */
    filters?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}
export namespace autostopping {
    export interface AwsProxyCertificates {
        /**
         * Certificate secret ID
         */
        certSecretId: pulumi.Input<string>;
        /**
         * Private key secret ID
         */
        keySecretId: pulumi.Input<string>;
    }

    export interface AzureProxyCertificates {
        /**
         * ID of certificate secret uploaded to vault
         */
        certSecretId: pulumi.Input<string>;
        /**
         * ID of certificate key uploaded to vault
         */
        keySecretId: pulumi.Input<string>;
    }

    export interface GcpProxyCertificates {
        /**
         * Certificate secret ID
         */
        certSecretId: pulumi.Input<string>;
        /**
         * Private key secret ID
         */
        keySecretId: pulumi.Input<string>;
    }

    export interface GetAwsProxyCertificates {
        /**
         * Certificate secret ID
         */
        certSecretId: string;
        /**
         * Private key secret ID
         */
        keySecretId: string;
    }

    export interface GetAwsProxyCertificatesArgs {
        /**
         * Certificate secret ID
         */
        certSecretId: pulumi.Input<string>;
        /**
         * Private key secret ID
         */
        keySecretId: pulumi.Input<string>;
    }

    export interface GetAzureProxyCertificates {
        /**
         * ID of certificate secret uploaded to vault
         */
        certSecretId: string;
        /**
         * ID of certificate key uploaded to vault
         */
        keySecretId: string;
    }

    export interface GetAzureProxyCertificatesArgs {
        /**
         * ID of certificate secret uploaded to vault
         */
        certSecretId: pulumi.Input<string>;
        /**
         * ID of certificate key uploaded to vault
         */
        keySecretId: pulumi.Input<string>;
    }

    export interface GetGcpProxyCertificates {
        /**
         * Certificate secret ID
         */
        certSecretId: string;
        /**
         * Private key secret ID
         */
        keySecretId: string;
    }

    export interface GetGcpProxyCertificatesArgs {
        /**
         * Certificate secret ID
         */
        certSecretId: pulumi.Input<string>;
        /**
         * Private key secret ID
         */
        keySecretId: pulumi.Input<string>;
    }

    export interface GetRuleEcsContainer {
        /**
         * Name of cluster in which service belong to
         */
        cluster: string;
        /**
         * Region of cluster
         */
        region: string;
        /**
         * Name of service to be onboarded
         */
        service: string;
        /**
         * Desired number of tasks on warming up a rule
         */
        taskCount?: number;
    }

    export interface GetRuleEcsContainerArgs {
        /**
         * Name of cluster in which service belong to
         */
        cluster: pulumi.Input<string>;
        /**
         * Region of cluster
         */
        region: pulumi.Input<string>;
        /**
         * Name of service to be onboarded
         */
        service: pulumi.Input<string>;
        /**
         * Desired number of tasks on warming up a rule
         */
        taskCount?: pulumi.Input<number>;
    }

    export interface GetRuleEcsDepend {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: number;
        /**
         * Rule id of the dependent rule
         */
        ruleId: number;
    }

    export interface GetRuleEcsDependArgs {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: pulumi.Input<number>;
        /**
         * Rule id of the dependent rule
         */
        ruleId: pulumi.Input<number>;
    }

    export interface GetRuleEcsHttp {
        /**
         * Id of the proxy
         */
        proxyId: string;
    }

    export interface GetRuleEcsHttpArgs {
        /**
         * Id of the proxy
         */
        proxyId: pulumi.Input<string>;
    }

    export interface GetRuleRdsDatabase {
        /**
         * ID of the database
         */
        id: string;
        /**
         * Region to which database belong to
         */
        region: string;
    }

    export interface GetRuleRdsDatabaseArgs {
        /**
         * ID of the database
         */
        id: pulumi.Input<string>;
        /**
         * Region to which database belong to
         */
        region: pulumi.Input<string>;
    }

    export interface GetRuleRdsDepend {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: number;
        /**
         * Rule id of the dependent rule
         */
        ruleId: number;
    }

    export interface GetRuleRdsDependArgs {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: pulumi.Input<number>;
        /**
         * Rule id of the dependent rule
         */
        ruleId: pulumi.Input<number>;
    }

    export interface GetRuleRdsTcp {
        /**
         * Additional tcp forwarding rules
         */
        forwardRules?: inputs.autostopping.GetRuleRdsTcpForwardRule[];
        /**
         * Id of the Proxy
         */
        proxyId: string;
    }

    export interface GetRuleRdsTcpArgs {
        /**
         * Additional tcp forwarding rules
         */
        forwardRules?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleRdsTcpForwardRuleArgs>[]>;
        /**
         * Id of the Proxy
         */
        proxyId: pulumi.Input<string>;
    }

    export interface GetRuleRdsTcpForwardRule {
        /**
         * Port to listen on the proxy
         */
        connectOn?: number;
        /**
         * Port to listen on the vm
         */
        port: number;
    }

    export interface GetRuleRdsTcpForwardRuleArgs {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port: pulumi.Input<number>;
    }

    export interface GetRuleVmDepend {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: number;
        /**
         * Rule id of the dependent rule
         */
        ruleId: number;
    }

    export interface GetRuleVmDependArgs {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: pulumi.Input<number>;
        /**
         * Rule id of the dependent rule
         */
        ruleId: pulumi.Input<number>;
    }

    export interface GetRuleVmFilter {
        /**
         * Regions of instances that needs to be managed using the AutoStopping rules
         */
        regions?: string[];
        /**
         * Tags of instances that needs to be managed using the AutoStopping rules
         */
        tags?: inputs.autostopping.GetRuleVmFilterTag[];
        /**
         * Ids of instances that needs to be managed using the AutoStopping rules
         */
        vmIds: string[];
        /**
         * Zones of instances that needs to be managed using the AutoStopping rules
         */
        zones?: string[];
    }

    export interface GetRuleVmFilterArgs {
        /**
         * Regions of instances that needs to be managed using the AutoStopping rules
         */
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Tags of instances that needs to be managed using the AutoStopping rules
         */
        tags?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleVmFilterTagArgs>[]>;
        /**
         * Ids of instances that needs to be managed using the AutoStopping rules
         */
        vmIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Zones of instances that needs to be managed using the AutoStopping rules
         */
        zones?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetRuleVmFilterTag {
        key: string;
        value: string;
    }

    export interface GetRuleVmFilterTagArgs {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface GetRuleVmHttp {
        /**
         * Health Check Details
         */
        healths?: inputs.autostopping.GetRuleVmHttpHealth[];
        /**
         * Id of the proxy
         */
        proxyId: string;
        /**
         * Routing configuration used to access the instances
         */
        routings?: inputs.autostopping.GetRuleVmHttpRouting[];
    }

    export interface GetRuleVmHttpArgs {
        /**
         * Health Check Details
         */
        healths?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleVmHttpHealthArgs>[]>;
        /**
         * Id of the proxy
         */
        proxyId: pulumi.Input<string>;
        /**
         * Routing configuration used to access the instances
         */
        routings?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleVmHttpRoutingArgs>[]>;
    }

    export interface GetRuleVmHttpHealth {
        /**
         * API path to use for health check
         */
        path?: string;
        /**
         * Health check port on the VM
         */
        port: number;
        /**
         * Protocol can be http or https
         */
        protocol: string;
        /**
         * Lower limit for acceptable status code
         */
        statusCodeFrom?: number;
        /**
         * Upper limit for acceptable status code
         */
        statusCodeTo?: number;
        /**
         * Health check timeout
         */
        timeout?: number;
    }

    export interface GetRuleVmHttpHealthArgs {
        /**
         * API path to use for health check
         */
        path?: pulumi.Input<string>;
        /**
         * Health check port on the VM
         */
        port: pulumi.Input<number>;
        /**
         * Protocol can be http or https
         */
        protocol: pulumi.Input<string>;
        /**
         * Lower limit for acceptable status code
         */
        statusCodeFrom?: pulumi.Input<number>;
        /**
         * Upper limit for acceptable status code
         */
        statusCodeTo?: pulumi.Input<number>;
        /**
         * Health check timeout
         */
        timeout?: pulumi.Input<number>;
    }

    export interface GetRuleVmHttpRouting {
        /**
         * Organization Identifier for the Entity
         */
        action?: string;
        /**
         * Port on the proxy
         */
        sourcePort?: number;
        /**
         * Source protocol of the proxy can be http or https
         */
        sourceProtocol: string;
        /**
         * Port on the VM
         */
        targetPort?: number;
        /**
         * Target protocol of the instance can be http or https
         */
        targetProtocol: string;
    }

    export interface GetRuleVmHttpRoutingArgs {
        /**
         * Organization Identifier for the Entity
         */
        action?: pulumi.Input<string>;
        /**
         * Port on the proxy
         */
        sourcePort?: pulumi.Input<number>;
        /**
         * Source protocol of the proxy can be http or https
         */
        sourceProtocol: pulumi.Input<string>;
        /**
         * Port on the VM
         */
        targetPort?: pulumi.Input<number>;
        /**
         * Target protocol of the instance can be http or https
         */
        targetProtocol: pulumi.Input<string>;
    }

    export interface GetRuleVmTcp {
        /**
         * Additional tcp forwarding rules
         */
        forwardRules?: inputs.autostopping.GetRuleVmTcpForwardRule[];
        /**
         * Id of the Proxy
         */
        proxyId: string;
        /**
         * RDP configuration
         */
        rdps?: inputs.autostopping.GetRuleVmTcpRdp[];
        /**
         * SSH configuration
         */
        sshes?: inputs.autostopping.GetRuleVmTcpSsh[];
    }

    export interface GetRuleVmTcpArgs {
        /**
         * Additional tcp forwarding rules
         */
        forwardRules?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleVmTcpForwardRuleArgs>[]>;
        /**
         * Id of the Proxy
         */
        proxyId: pulumi.Input<string>;
        /**
         * RDP configuration
         */
        rdps?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleVmTcpRdpArgs>[]>;
        /**
         * SSH configuration
         */
        sshes?: pulumi.Input<pulumi.Input<inputs.autostopping.GetRuleVmTcpSshArgs>[]>;
    }

    export interface GetRuleVmTcpForwardRule {
        /**
         * Port to listen on the proxy
         */
        connectOn?: number;
        /**
         * Port to listen on the vm
         */
        port: number;
    }

    export interface GetRuleVmTcpForwardRuleArgs {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port: pulumi.Input<number>;
    }

    export interface GetRuleVmTcpRdp {
        /**
         * Port to listen on the proxy
         */
        connectOn?: number;
        /**
         * Port to listen on the vm
         */
        port?: number;
    }

    export interface GetRuleVmTcpRdpArgs {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port?: pulumi.Input<number>;
    }

    export interface GetRuleVmTcpSsh {
        /**
         * Port to listen on the proxy
         */
        connectOn?: number;
        /**
         * Port to listen on the vm
         */
        port?: number;
    }

    export interface GetRuleVmTcpSshArgs {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port?: pulumi.Input<number>;
    }

    export interface RuleEcsContainer {
        /**
         * Name of cluster in which service belong to
         */
        cluster: pulumi.Input<string>;
        /**
         * Region of cluster
         */
        region: pulumi.Input<string>;
        /**
         * Name of service to be onboarded
         */
        service: pulumi.Input<string>;
        /**
         * Desired number of tasks on warming up a rule
         */
        taskCount?: pulumi.Input<number>;
    }

    export interface RuleEcsDepend {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: pulumi.Input<number>;
        /**
         * Rule id of the dependent rule
         */
        ruleId: pulumi.Input<number>;
    }

    export interface RuleEcsHttp {
        /**
         * Id of the proxy
         */
        proxyId: pulumi.Input<string>;
    }

    export interface RuleRdsDatabase {
        /**
         * ID of the database
         */
        id: pulumi.Input<string>;
        /**
         * Region to which database belong to
         */
        region: pulumi.Input<string>;
    }

    export interface RuleRdsDepend {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: pulumi.Input<number>;
        /**
         * Rule id of the dependent rule
         */
        ruleId: pulumi.Input<number>;
    }

    export interface RuleRdsTcp {
        /**
         * Additional tcp forwarding rules
         */
        forwardRules?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleRdsTcpForwardRule>[]>;
        /**
         * Id of the Proxy
         */
        proxyId: pulumi.Input<string>;
    }

    export interface RuleRdsTcpForwardRule {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port: pulumi.Input<number>;
    }

    export interface RuleVmDepend {
        /**
         * Number of seconds the rule should wait after warming up the dependent rule
         */
        delayInSec?: pulumi.Input<number>;
        /**
         * Rule id of the dependent rule
         */
        ruleId: pulumi.Input<number>;
    }

    export interface RuleVmFilter {
        /**
         * Regions of instances that needs to be managed using the AutoStopping rules
         */
        regions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Tags of instances that needs to be managed using the AutoStopping rules
         */
        tags?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleVmFilterTag>[]>;
        /**
         * Ids of instances that needs to be managed using the AutoStopping rules
         */
        vmIds: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Zones of instances that needs to be managed using the AutoStopping rules
         */
        zones?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RuleVmFilterTag {
        key: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface RuleVmHttp {
        /**
         * Health Check Details
         */
        healths?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleVmHttpHealth>[]>;
        /**
         * Id of the proxy
         */
        proxyId: pulumi.Input<string>;
        /**
         * Routing configuration used to access the instances
         */
        routings?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleVmHttpRouting>[]>;
    }

    export interface RuleVmHttpHealth {
        /**
         * API path to use for health check
         */
        path?: pulumi.Input<string>;
        /**
         * Health check port on the VM
         */
        port: pulumi.Input<number>;
        /**
         * Protocol can be http or https
         */
        protocol: pulumi.Input<string>;
        /**
         * Lower limit for acceptable status code
         */
        statusCodeFrom?: pulumi.Input<number>;
        /**
         * Upper limit for acceptable status code
         */
        statusCodeTo?: pulumi.Input<number>;
        /**
         * Health check timeout
         */
        timeout?: pulumi.Input<number>;
    }

    export interface RuleVmHttpRouting {
        /**
         * Organization Identifier for the Entity
         */
        action?: pulumi.Input<string>;
        /**
         * Port on the proxy
         */
        sourcePort?: pulumi.Input<number>;
        /**
         * Source protocol of the proxy can be http or https
         */
        sourceProtocol: pulumi.Input<string>;
        /**
         * Port on the VM
         */
        targetPort?: pulumi.Input<number>;
        /**
         * Target protocol of the instance can be http or https
         */
        targetProtocol: pulumi.Input<string>;
    }

    export interface RuleVmTcp {
        /**
         * Additional tcp forwarding rules
         */
        forwardRules?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleVmTcpForwardRule>[]>;
        /**
         * Id of the Proxy
         */
        proxyId: pulumi.Input<string>;
        /**
         * RDP configuration
         */
        rdps?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleVmTcpRdp>[]>;
        /**
         * SSH configuration
         */
        sshes?: pulumi.Input<pulumi.Input<inputs.autostopping.RuleVmTcpSsh>[]>;
    }

    export interface RuleVmTcpForwardRule {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port: pulumi.Input<number>;
    }

    export interface RuleVmTcpRdp {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port?: pulumi.Input<number>;
    }

    export interface RuleVmTcpSsh {
        /**
         * Port to listen on the proxy
         */
        connectOn?: pulumi.Input<number>;
        /**
         * Port to listen on the vm
         */
        port?: pulumi.Input<number>;
    }

    export interface ScheduleRepeat {
        /**
         * List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
         */
        days: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Ending time of schedule action on the day. Defaults to 24:00Hrs unless specified. Accepted format is HH:MM. Eg : 20:00 for 8pm
         */
        endTime?: pulumi.Input<string>;
        /**
         * Starting time of schedule action on the day. Defaults to 00:00Hrs unless specified. Accepted format is HH:MM. Eg : 13:15 for 01:15pm
         */
        startTime?: pulumi.Input<string>;
    }
}

export namespace cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationOidc>;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationServiceAccount>;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: pulumi.Input<inputs.cloudprovider.KubernetesAuthenticationUsernamePassword>;
    }

    export interface KubernetesAuthenticationOidc {
        /**
         * Name of the Harness secret containing the client ID for the cluster.
         */
        clientIdSecretName: pulumi.Input<string>;
        /**
         * Name of the Harness secret containing the client secret for the cluster.
         */
        clientSecretSecretName?: pulumi.Input<string>;
        /**
         * URL of the identity provider to use.
         */
        identityProviderUrl: pulumi.Input<string>;
        /**
         * URL of the Kubernetes master to connect to.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Name of the Harness secret containing the password for the cluster.
         */
        passwordSecretName: pulumi.Input<string>;
        /**
         * Scopes to request from the identity provider.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Username for authentication to the cluster. This can be the username itself or the ID of a harness secret.
         */
        username: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationServiceAccount {
        /**
         * Name of the Harness secret containing the CA certificate for the cluster.
         */
        caCertificateSecretName?: pulumi.Input<string>;
        /**
         * URL of the Kubernetes master to connect to.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Name of the Harness secret containing the service account token for the cluster.
         */
        serviceAccountTokenSecretName: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        /**
         * URL of the Kubernetes master to connect to.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Name of the Harness secret containing the password for the cluster.
         */
        passwordSecretName: pulumi.Input<string>;
        /**
         * Username for authentication to the cluster
         */
        username?: pulumi.Input<string>;
        /**
         * Name of the Harness secret containing the username for authentication to the cluster
         */
        usernameSecretName?: pulumi.Input<string>;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }
}

export namespace platform {
    export interface AppDynamicsConnectorApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: pulumi.Input<string>;
    }

    export interface AppDynamicsConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface ArtifactoryConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface AwsCCConnectorCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: pulumi.Input<string>;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsConnectorCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsConnectorEqualJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay?: pulumi.Input<number>;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime?: pulumi.Input<number>;
        /**
         * Retry Count.
         */
        retryCount?: pulumi.Input<number>;
    }

    export interface AwsConnectorFixedDelayBackoffStrategy {
        /**
         * Fixed Backoff.
         */
        fixedBackoff?: pulumi.Input<number>;
        /**
         * Retry Count.
         */
        retryCount?: pulumi.Input<number>;
    }

    export interface AwsConnectorFullJitterBackoffStrategy {
        /**
         * Base delay.
         */
        baseDelay?: pulumi.Input<number>;
        /**
         * Max BackOff Time.
         */
        maxBackoffTime?: pulumi.Input<number>;
        /**
         * Retry Count.
         */
        retryCount?: pulumi.Input<number>;
    }

    export interface AwsConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Test Region to perform Connection test of AWS Connector.
         */
        region?: pulumi.Input<string>;
    }

    export interface AwsConnectorIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Test Region to perform Connection test of AWS Connector.
         */
        region?: pulumi.Input<string>;
    }

    export interface AwsConnectorManual {
        /**
         * AWS access key.
         */
        accessKey?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        accessKeyRef?: pulumi.Input<string>;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Test Region to perform Connection test of AWS Connector.
         */
        region?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsConnectorOidcAuthentication {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The IAM Role to assume the credentials from.
         */
        iamRoleArn: pulumi.Input<string>;
        /**
         * Test Region to perform Connection test of AWS Connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        region?: pulumi.Input<string>;
    }

    export interface AwsKmsConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.platform.AwsKmsConnectorCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.platform.AwsKmsConnectorCredentialsManual>;
    }

    export interface AwsKmsConnectorCredentialsAssumeRole {
        /**
         * The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
         */
        duration: pulumi.Input<number>;
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * The ARN of the role to assume.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsKmsConnectorCredentialsManual {
        /**
         * The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        accessKeyRef: pulumi.Input<string>;
        /**
         * The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsSecretManagerConnectorCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.platform.AwsSecretManagerConnectorCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.platform.AwsSecretManagerConnectorCredentialsManual>;
    }

    export interface AwsSecretManagerConnectorCredentialsAssumeRole {
        /**
         * The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
         */
        duration: pulumi.Input<number>;
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * The ARN of the role to assume.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsSecretManagerConnectorCredentialsManual {
        /**
         * The plain text AWS access key.
         */
        accessKeyPlainText?: pulumi.Input<string>;
        /**
         * The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        accessKeyRef?: pulumi.Input<string>;
        /**
         * The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AzureCloudCostConnectorBillingExportSpec {
        /**
         * Name of the container.
         */
        containerName: pulumi.Input<string>;
        /**
         * Name of the directory.
         */
        directoryName: pulumi.Input<string>;
        /**
         * Name of the report.
         */
        reportName: pulumi.Input<string>;
        /**
         * Name of the storage account.
         */
        storageAccountName: pulumi.Input<string>;
        /**
         * Subsription Id.
         */
        subscriptionId: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentials {
        /**
         * Authenticate to Azure Cloud Provider using details inheriting from delegate.
         */
        azureInheritFromDelegateDetails?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails>;
        /**
         * Authenticate to Azure Cloud Provider using manual details.
         */
        azureManualDetails?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetails>;
        /**
         * Type can either be InheritFromDelegate or ManualConfig.
         */
        type: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails {
        /**
         * Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
         */
        auth?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth {
        /**
         * Azure UserAssigned MSI auth details.
         */
        azureMsiAuthUa?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa>;
        /**
         * Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
         */
        type: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa {
        /**
         * Client Id of the ManagedIdentity resource.
         */
        clientId?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetails {
        /**
         * Application ID of the Azure App.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Contains Azure auth details.
         */
        auth?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth>;
        /**
         * The Azure Active Directory (AAD) directory ID where you created your application.
         */
        tenantId?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth {
        /**
         * Azure client key certificate details.
         */
        azureClientKeyCert?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert>;
        /**
         * Azure Client Secret Key details.
         */
        azureClientSecretKey?: pulumi.Input<inputs.platform.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey>;
        /**
         * Type can either be Certificate or Secret.
         */
        type?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert {
        /**
         * Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        certificateRef?: pulumi.Input<string>;
    }

    export interface AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey {
        /**
         * Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: pulumi.Input<string>;
        /**
         * The username used for connecting to the api.
         */
        username?: pulumi.Input<string>;
        /**
         * The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.BitbucketConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.BitbucketConnectorCredentialsSsh>;
    }

    export interface BitbucketConnectorCredentialsHttp {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef?: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketConnectorCredentialsSsh {
        /**
         * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        sshKeyRef: pulumi.Input<string>;
    }

    export interface ConnectorCustomSecretManagerTemplateInput {
        environmentVariables?: pulumi.Input<pulumi.Input<inputs.platform.ConnectorCustomSecretManagerTemplateInputEnvironmentVariable>[]>;
    }

    export interface ConnectorCustomSecretManagerTemplateInputEnvironmentVariable {
        default?: pulumi.Input<boolean>;
        /**
         * : Name of the resource.
         */
        name: pulumi.Input<string>;
        /**
         * : Type of the custom secrets manager, typically set to `CustomSecretManager`.
         */
        type: pulumi.Input<string>;
        value: pulumi.Input<string>;
    }

    export interface ConnectorCustomhealthsourceHeader {
        /**
         * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        encryptedValueRef?: pulumi.Input<string>;
        /**
         * Key.
         */
        key: pulumi.Input<string>;
        /**
         * Value.
         */
        value?: pulumi.Input<string>;
        /**
         * Encrypted value.
         */
        valueEncrypted?: pulumi.Input<boolean>;
    }

    export interface ConnectorCustomhealthsourceParam {
        /**
         * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        encryptedValueRef?: pulumi.Input<string>;
        /**
         * Key.
         */
        key: pulumi.Input<string>;
        /**
         * Value.
         */
        value?: pulumi.Input<string>;
        /**
         * Encrypted value.
         */
        valueEncrypted?: pulumi.Input<boolean>;
    }

    export interface ConnectorJdbcCredentials {
        /**
         * The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * The username to use for the database server.
         */
        username?: pulumi.Input<string>;
        /**
         * The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface ConnectorPdcHost {
        /**
         * Host attributes with values. e.g. type, region, name, ip, etc.
         */
        attributes?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Hostname e.g. 87.23.66.11:80
         */
        hostname: pulumi.Input<string>;
    }

    export interface ConnectorRancherBearerToken {
        /**
         * Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        bearerTokenRef: pulumi.Input<string>;
    }

    export interface DbSchemaSchemaSource {
        /**
         * Connector to repository at which to find details about the database schema
         */
        connector: pulumi.Input<string>;
        /**
         * The path within the specified repository at which to find details about the database schema
         */
        location: pulumi.Input<string>;
        /**
         * If connector url is of account, which repository to connect to using the connector
         */
        repo?: pulumi.Input<string>;
    }

    export interface DockerConnectorCredentials {
        /**
         * The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * The username to use for the docker registry.
         */
        username?: pulumi.Input<string>;
        /**
         * The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface ElasticsearchConnectorApiToken {
        /**
         * The client id used for connecting to ElasticSearch.
         */
        clientId: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef: pulumi.Input<string>;
    }

    export interface ElasticsearchConnectorNoAuthentication {
    }

    export interface ElasticsearchConnectorUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface EnvironmentClustersMappingCluster {
        /**
         * agent identifier of the cluster (include scope prefix)
         */
        agentIdentifier?: pulumi.Input<string>;
        /**
         * identifier of the cluster
         */
        identifier?: pulumi.Input<string>;
        /**
         * name of the cluster
         */
        name?: pulumi.Input<string>;
        /**
         * scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
         */
        scope?: pulumi.Input<string>;
    }

    export interface EnvironmentGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * message for the commit in Git Repo.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Flag to set if importing from Git
         */
        importFromGit?: pulumi.Input<boolean>;
        /**
         * Flag to set if force importing from Git
         */
        isForceImport?: pulumi.Input<boolean>;
        /**
         * If the gitProvider is HarnessCode
         */
        isHarnesscodeRepo?: pulumi.Input<boolean>;
        /**
         * If a new branch creation is requested.
         */
        isNewBranch?: pulumi.Input<boolean>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Environment.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Environment.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * If the Entity is to be fetched from cache
         */
        loadFromCache?: pulumi.Input<string>;
        /**
         * Whether the file has to be get from fallback_branch.
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        parentEntityConnectorRef?: pulumi.Input<string>;
        /**
         * Name of the repository where parent entity lies.
         */
        parentEntityRepoName?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * store type of the entity.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface FeatureFlagEnvironment {
        /**
         * The targeting rules for the flag
         */
        addTargetRules?: pulumi.Input<pulumi.Input<inputs.platform.FeatureFlagEnvironmentAddTargetRule>[]>;
        /**
         * Default variation to be served when flag is 'off'
         */
        defaultOffVariation?: pulumi.Input<string>;
        /**
         * Default variation to be served when flag is 'on'
         */
        defaultOnVariation?: pulumi.Input<string>;
        /**
         * Identifier of the Environment
         */
        identifier: pulumi.Input<string>;
        /**
         * State of the flag in this environment. Possible values are 'on' and 'off'
         */
        state?: pulumi.Input<string>;
    }

    export interface FeatureFlagEnvironmentAddTargetRule {
        /**
         * The targets of the rule
         */
        targets?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The identifier of the variation. Valid values are `enabled`, `disabled`
         */
        variation?: pulumi.Input<string>;
    }

    export interface FeatureFlagTag {
        /**
         * The identifier of the tag
         */
        identifier: pulumi.Input<string>;
    }

    export interface FeatureFlagTargetGroupRule {
        /**
         * The attribute to use in the clause.  This can be any target attribute
         */
        attribute?: pulumi.Input<string>;
        /**
         * Is the operation negated?
         */
        negate?: pulumi.Input<boolean>;
        /**
         * The type of operation such as equals, starts_with, contains
         */
        op?: pulumi.Input<string>;
        /**
         * The values that are compared against the operator
         */
        values?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface FeatureFlagVariation {
        /**
         * The description of the variation
         */
        description: pulumi.Input<string>;
        /**
         * The identifier of the variation
         */
        identifier: pulumi.Input<string>;
        /**
         * The user friendly name of the variation
         */
        name: pulumi.Input<string>;
        /**
         * The value of the variation
         */
        value: pulumi.Input<string>;
    }

    export interface FileStoreFileCreatedBy {
        /**
         * User email
         */
        email?: pulumi.Input<string>;
        /**
         * User name
         */
        name?: pulumi.Input<string>;
    }

    export interface FileStoreFileLastModifiedBy {
        /**
         * User email
         */
        email?: pulumi.Input<string>;
        /**
         * User name
         */
        name?: pulumi.Input<string>;
    }

    export interface FileStoreFolderCreatedBy {
        /**
         * User email
         */
        email?: pulumi.Input<string>;
        /**
         * User name
         */
        name?: pulumi.Input<string>;
    }

    export interface FileStoreFolderLastModifiedBy {
        /**
         * User email
         */
        email?: pulumi.Input<string>;
        /**
         * User name
         */
        name?: pulumi.Input<string>;
    }

    export interface FiltersFilterProperties {
        /**
         * Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
         */
        filterType: pulumi.Input<string>;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GcpCloudCostConnectorBillingExportSpec {
        /**
         * Data Set Id.
         */
        dataSetId: pulumi.Input<string>;
        /**
         * Table Id.
         */
        tableId: pulumi.Input<string>;
    }

    export interface GcpConnectorInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GcpConnectorManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface GcpConnectorOidcAuthentication {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The project number of the GCP project that is used to create the workload identity.
         */
        gcpProjectId: pulumi.Input<string>;
        /**
         * The OIDC provider ID value configured in GCP.
         */
        providerId: pulumi.Input<string>;
        /**
         * The service account linked to workload identity pool while setting GCP workload identity provider.
         */
        serviceAccountEmail: pulumi.Input<string>;
        /**
         * The workload pool ID value created in GCP.
         */
        workloadPoolId: pulumi.Input<string>;
    }

    export interface GetConnectorRancherBearerToken {
        /**
         * Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: string;
        /**
         * The URL of the Rancher cluster.
         */
        rancherUrl: string;
    }

    export interface GetConnectorRancherBearerTokenArgs {
        /**
         * Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * The URL of the Rancher cluster.
         */
        rancherUrl: pulumi.Input<string>;
    }

    export interface GetEnvironmentClustersMappingCluster {
        /**
         * agent identifier of the cluster (include scope prefix)
         */
        agentIdentifier?: string;
        /**
         * identifier of the cluster
         */
        identifier?: string;
        /**
         * name of the cluster
         */
        name?: string;
        /**
         * scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
         */
        scope?: string;
    }

    export interface GetEnvironmentClustersMappingClusterArgs {
        /**
         * agent identifier of the cluster (include scope prefix)
         */
        agentIdentifier?: pulumi.Input<string>;
        /**
         * identifier of the cluster
         */
        identifier?: pulumi.Input<string>;
        /**
         * name of the cluster
         */
        name?: pulumi.Input<string>;
        /**
         * scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
         */
        scope?: pulumi.Input<string>;
    }

    export interface GetEnvironmentGitDetails {
        /**
         * Name of the branch.
         */
        branch?: string;
        /**
         * Load environment yaml from fallback branch
         */
        loadFromFallbackBranch?: boolean;
        /**
         * Repo name of remote environment
         */
        repoName?: string;
    }

    export interface GetEnvironmentGitDetailsArgs {
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Load environment yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Repo name of remote environment
         */
        repoName?: pulumi.Input<string>;
    }

    export interface GetGitopsAgentDeployYamlProxy {
        /**
         * HTTP proxy settings for the GitOps agent.
         */
        http?: string;
        /**
         * HTTPS proxy settings for the GitOps agent.
         */
        https?: string;
        /**
         * Password for the proxy.
         */
        password?: string;
        /**
         * Username for the proxy.
         */
        username?: string;
    }

    export interface GetGitopsAgentDeployYamlProxyArgs {
        /**
         * HTTP proxy settings for the GitOps agent.
         */
        http?: pulumi.Input<string>;
        /**
         * HTTPS proxy settings for the GitOps agent.
         */
        https?: pulumi.Input<string>;
        /**
         * Password for the proxy.
         */
        password?: pulumi.Input<string>;
        /**
         * Username for the proxy.
         */
        username?: pulumi.Input<string>;
    }

    export interface GetGitopsGnupgRequest {
        /**
         * Public key details.
         */
        publickeys?: inputs.platform.GetGitopsGnupgRequestPublickey[];
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert?: boolean;
    }

    export interface GetGitopsGnupgRequestArgs {
        /**
         * Public key details.
         */
        publickeys?: pulumi.Input<pulumi.Input<inputs.platform.GetGitopsGnupgRequestPublickeyArgs>[]>;
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert?: pulumi.Input<boolean>;
    }

    export interface GetGitopsGnupgRequestPublickey {
        /**
         * Fingerprint is the fingerprint of the key
         */
        fingerprint?: string;
        /**
         * KeyData holds the raw key data, in base64 encoded format.
         */
        keyData?: string;
        /**
         * KeyID specifies the key ID, in hexadecimal string format.
         */
        keyId?: string;
        /**
         * Owner holds the owner identification, e.g. a name and e-mail address
         */
        owner?: string;
        /**
         * SubType holds the key's sub type
         */
        subType?: string;
        /**
         * Trust holds the level of trust assigned to this key
         */
        trust?: string;
    }

    export interface GetGitopsGnupgRequestPublickeyArgs {
        /**
         * Fingerprint is the fingerprint of the key
         */
        fingerprint?: pulumi.Input<string>;
        /**
         * KeyData holds the raw key data, in base64 encoded format.
         */
        keyData?: pulumi.Input<string>;
        /**
         * KeyID specifies the key ID, in hexadecimal string format.
         */
        keyId?: pulumi.Input<string>;
        /**
         * Owner holds the owner identification, e.g. a name and e-mail address
         */
        owner?: pulumi.Input<string>;
        /**
         * SubType holds the key's sub type
         */
        subType?: pulumi.Input<string>;
        /**
         * Trust holds the level of trust assigned to this key
         */
        trust?: pulumi.Input<string>;
    }

    export interface GetGitopsRepoCredCred {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: boolean;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: string;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: string;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: string;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: string;
        /**
         * Password or PAT to be used for authenticating the remote repository.
         */
        password?: string;
        /**
         * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
         */
        sshPrivateKey?: string;
        /**
         * Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
         */
        tlsClientCertData?: string;
        /**
         * Private key in PEM format for authenticating at the repo server. This is used for mTLS.
         */
        tlsClientCertKey?: string;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: string;
        /**
         * URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
         */
        url?: string;
        /**
         * Username to be used for authenticating the remote repository.
         */
        username?: string;
    }

    export interface GetGitopsRepoCredCredArgs {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: pulumi.Input<boolean>;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: pulumi.Input<string>;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: pulumi.Input<string>;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: pulumi.Input<string>;
        /**
         * Password or PAT to be used for authenticating the remote repository.
         */
        password?: pulumi.Input<string>;
        /**
         * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
         */
        sshPrivateKey?: pulumi.Input<string>;
        /**
         * Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
         */
        tlsClientCertData?: pulumi.Input<string>;
        /**
         * Private key in PEM format for authenticating at the repo server. This is used for mTLS.
         */
        tlsClientCertKey?: pulumi.Input<string>;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: pulumi.Input<string>;
        /**
         * URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
         */
        url?: pulumi.Input<string>;
        /**
         * Username to be used for authenticating the remote repository.
         */
        username?: pulumi.Input<string>;
    }

    export interface GetInfrastructureGitDetails {
        /**
         * Name of the branch.
         */
        branch?: string;
        /**
         * If the Entity is to be fetched from cache
         */
        loadFromCache?: string;
        /**
         * Load Infrastructure yaml from fallback branch
         */
        loadFromFallbackBranch?: boolean;
        /**
         * Repo name of remote Infrastructure
         */
        repoName?: string;
    }

    export interface GetInfrastructureGitDetailsArgs {
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * If the Entity is to be fetched from cache
         */
        loadFromCache?: pulumi.Input<string>;
        /**
         * Load Infrastructure yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Repo name of remote Infrastructure
         */
        repoName?: pulumi.Input<string>;
    }

    export interface GetInputSetGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: string;
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: string;
        /**
         * Connector reference for Parent Entity (Pipeline).
         */
        parentEntityConnectorRef?: string;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName?: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: string;
    }

    export interface GetInputSetGitDetailsArgs {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Connector reference for Parent Entity (Pipeline).
         */
        parentEntityConnectorRef?: pulumi.Input<string>;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface GetOverridesGitDetails {
        /**
         * Name of the branch.
         */
        branch?: string;
        /**
         * Load service yaml from fallback branch
         */
        loadFromCache?: boolean;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: boolean;
        /**
         * Repo name of remote service override
         */
        repoName?: string;
    }

    export interface GetOverridesGitDetailsArgs {
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromCache?: pulumi.Input<boolean>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Repo name of remote service override
         */
        repoName?: pulumi.Input<string>;
    }

    export interface GetPipelineGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: string;
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: string;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: string;
    }

    export interface GetPipelineGitDetailsArgs {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface GetPolicySetPolicy {
        /**
         * Account Identifier of the account
         */
        identifier: string;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: string;
    }

    export interface GetPolicySetPolicyArgs {
        /**
         * Account Identifier of the account
         */
        identifier: pulumi.Input<string>;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: pulumi.Input<string>;
    }

    export interface GetRepoRuleBranchBypass {
        /**
         * Allow users with repository edit permission to bypass.
         */
        repoOwners?: boolean;
        /**
         * List of user ids with who can bypass.
         */
        userIds?: string[];
    }

    export interface GetRepoRuleBranchBypassArgs {
        /**
         * Allow users with repository edit permission to bypass.
         */
        repoOwners?: pulumi.Input<boolean>;
        /**
         * List of user ids with who can bypass.
         */
        userIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetRepoRuleBranchPattern {
        /**
         * Should rule apply to default branch of the repository.
         */
        defaultBranch?: boolean;
        /**
         * Globstar branch patterns on which rules will NOT be applied.
         */
        excludes?: string[];
        /**
         * Globstar branch patterns on which rules will be applied.
         */
        includes?: string[];
    }

    export interface GetRepoRuleBranchPatternArgs {
        /**
         * Should rule apply to default branch of the repository.
         */
        defaultBranch?: pulumi.Input<boolean>;
        /**
         * Globstar branch patterns on which rules will NOT be applied.
         */
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Globstar branch patterns on which rules will be applied.
         */
        includes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetRepoRuleBranchPolicy {
        /**
         * Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
         */
        allowMergeStrategies?: string[];
        /**
         * Only allow users with bypass permission to create matching branches.
         */
        blockBranchCreation?: boolean;
        /**
         * Only allow users with bypass permission to delete matching branches.
         */
        blockBranchDeletion?: boolean;
        /**
         * Automatically delete the source branch of a pull request after it is merged.
         */
        deleteBranchOnMerge?: boolean;
        /**
         * Require approval on pull requests from one reviewer for each codeowner rule.
         */
        requireCodeOwners?: boolean;
        /**
         * Require re-approval when there are new changes in the pull request.
         */
        requireLatestCommitApproval?: boolean;
        /**
         * Require approval on pull requests from a minimum number of reviewers.
         */
        requireMinimumApprovalCount?: number;
        /**
         * Require all request for changes have been resolved.
         */
        requireNoChangeRequest?: boolean;
        /**
         * Do not allow any changes to matching branches without a pull request.
         */
        requirePullRequest?: boolean;
        /**
         * All comments on a pull request must be resolved before it can be merged.
         */
        requireResolveAllComments?: boolean;
        /**
         * Selected status checks must pass before a pull request can be merged.
         */
        requireStatusChecks?: string[];
    }

    export interface GetRepoRuleBranchPolicyArgs {
        /**
         * Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
         */
        allowMergeStrategies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only allow users with bypass permission to create matching branches.
         */
        blockBranchCreation?: pulumi.Input<boolean>;
        /**
         * Only allow users with bypass permission to delete matching branches.
         */
        blockBranchDeletion?: pulumi.Input<boolean>;
        /**
         * Automatically delete the source branch of a pull request after it is merged.
         */
        deleteBranchOnMerge?: pulumi.Input<boolean>;
        /**
         * Require approval on pull requests from one reviewer for each codeowner rule.
         */
        requireCodeOwners?: pulumi.Input<boolean>;
        /**
         * Require re-approval when there are new changes in the pull request.
         */
        requireLatestCommitApproval?: pulumi.Input<boolean>;
        /**
         * Require approval on pull requests from a minimum number of reviewers.
         */
        requireMinimumApprovalCount?: pulumi.Input<number>;
        /**
         * Require all request for changes have been resolved.
         */
        requireNoChangeRequest?: pulumi.Input<boolean>;
        /**
         * Do not allow any changes to matching branches without a pull request.
         */
        requirePullRequest?: pulumi.Input<boolean>;
        /**
         * All comments on a pull request must be resolved before it can be merged.
         */
        requireResolveAllComments?: pulumi.Input<boolean>;
        /**
         * Selected status checks must pass before a pull request can be merged.
         */
        requireStatusChecks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GetRepoSource {
        /**
         * The host URL for the import source.
         */
        host?: string;
        /**
         * The password for authentication when importing.
         */
        password?: string;
        /**
         * The full identifier of the repository on the SCM provider's platform.
         */
        repo?: string;
        /**
         * The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
         */
        type?: string;
        /**
         * The username for authentication when importing.
         */
        username?: string;
    }

    export interface GetRepoSourceArgs {
        /**
         * The host URL for the import source.
         */
        host?: pulumi.Input<string>;
        /**
         * The password for authentication when importing.
         */
        password?: pulumi.Input<string>;
        /**
         * The full identifier of the repository on the SCM provider's platform.
         */
        repo?: pulumi.Input<string>;
        /**
         * The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
         */
        type?: pulumi.Input<string>;
        /**
         * The username for authentication when importing.
         */
        username?: pulumi.Input<string>;
    }

    export interface GetSecretTextAdditionalMetadata {
        values?: inputs.platform.GetSecretTextAdditionalMetadataValue[];
    }

    export interface GetSecretTextAdditionalMetadataArgs {
        values?: pulumi.Input<pulumi.Input<inputs.platform.GetSecretTextAdditionalMetadataValueArgs>[]>;
    }

    export interface GetSecretTextAdditionalMetadataValue {
        version?: string;
    }

    export interface GetSecretTextAdditionalMetadataValueArgs {
        version?: pulumi.Input<string>;
    }

    export interface GetServiceGitDetails {
        /**
         * Name of the branch.
         */
        branch?: string;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: boolean;
        /**
         * Repo name of remote service
         */
        repoName?: string;
    }

    export interface GetServiceGitDetailsArgs {
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Repo name of remote service
         */
        repoName?: pulumi.Input<string>;
    }

    export interface GetServiceOverridesV2GitDetails {
        /**
         * Name of the branch.
         */
        branch?: string;
        /**
         * Load service yaml from fallback branch
         */
        loadFromCache?: boolean;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: boolean;
        /**
         * Repo name of remote service override
         */
        repoName?: string;
    }

    export interface GetServiceOverridesV2GitDetailsArgs {
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromCache?: pulumi.Input<boolean>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Repo name of remote service override
         */
        repoName?: pulumi.Input<string>;
    }

    export interface GetTemplateGitDetails {
        /**
         * Name of the branch.
         */
        branchName?: string;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: string;
        /**
         * File url of the Entity in the repository.
         */
        fileUrl?: string;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: string;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: string;
        /**
         * Name of the repository.
         */
        repoName?: string;
        /**
         * Repo url of the Entity in the repository.
         */
        repoUrl?: string;
    }

    export interface GetTemplateGitDetailsArgs {
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * File url of the Entity in the repository.
         */
        fileUrl?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Repo url of the Entity in the repository.
         */
        repoUrl?: pulumi.Input<string>;
    }

    export interface GetUsergroupNotificationConfig {
        /**
         * Group email.
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: string;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers?: boolean;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: string;
    }

    export interface GetUsergroupNotificationConfigArgs {
        /**
         * Group email.
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers?: pulumi.Input<boolean>;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: pulumi.Input<string>;
    }

    export interface GetWorkspaceEnvironmentVariable {
        /**
         * Key is the identifier for the variable`
         */
        key?: string;
        /**
         * value is the value of the variable
         */
        value?: string;
        /**
         * Value type indicates the value type of the variable, text or secret
         */
        valueType?: string;
    }

    export interface GetWorkspaceEnvironmentVariableArgs {
        /**
         * Key is the identifier for the variable`
         */
        key?: pulumi.Input<string>;
        /**
         * value is the value of the variable
         */
        value?: pulumi.Input<string>;
        /**
         * Value type indicates the value type of the variable, text or secret
         */
        valueType?: pulumi.Input<string>;
    }

    export interface GetWorkspaceTerraformVariable {
        /**
         * Key is the identifier for the variable`
         */
        key?: string;
        /**
         * value is the value of the variable
         */
        value?: string;
        /**
         * Value type indicates the value type of the variable, text or secret
         */
        valueType?: string;
    }

    export interface GetWorkspaceTerraformVariableArgs {
        /**
         * Key is the identifier for the variable`
         */
        key?: pulumi.Input<string>;
        /**
         * value is the value of the variable
         */
        value?: pulumi.Input<string>;
        /**
         * Value type indicates the value type of the variable, text or secret
         */
        valueType?: pulumi.Input<string>;
    }

    export interface GetWorkspaceTerraformVariableFile {
        /**
         * Repository is the name of the repository to fetch the code from.
         */
        repository?: string;
        /**
         * Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
         */
        repositoryBranch?: string;
        /**
         * Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
         */
        repositoryCommit?: string;
        /**
         * Repository connector is the reference to the connector used to fetch the variables.
         */
        repositoryConnector?: string;
        /**
         * Repository path is the path in which the variables reside.
         */
        repositoryPath?: string;
        /**
         * Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
         */
        repositorySha?: string;
    }

    export interface GetWorkspaceTerraformVariableFileArgs {
        /**
         * Repository is the name of the repository to fetch the code from.
         */
        repository?: pulumi.Input<string>;
        /**
         * Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
         */
        repositoryBranch?: pulumi.Input<string>;
        /**
         * Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
         */
        repositoryCommit?: pulumi.Input<string>;
        /**
         * Repository connector is the reference to the connector used to fetch the variables.
         */
        repositoryConnector?: pulumi.Input<string>;
        /**
         * Repository path is the path in which the variables reside.
         */
        repositoryPath?: pulumi.Input<string>;
        /**
         * Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
         */
        repositorySha?: pulumi.Input<string>;
    }

    export interface GitConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GitConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GitConnectorCredentialsSsh>;
    }

    export interface GitConnectorCredentialsHttp {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitConnectorCredentialsSsh {
        /**
         * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitOpsAgentMetadata {
        /**
         * Indicates if the agent is deployed in HA mode.
         */
        highAvailability?: pulumi.Input<boolean>;
        /**
         * Indicates if the agent is namespaced.
         */
        isNamespaced?: pulumi.Input<boolean>;
        /**
         * The kubernetes namespace where the agent should be installed.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplication {
        /**
         * Metadata corresponding to the resources. This includes all the objects a user must create.
         */
        metadatas: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationMetadata>[]>;
        /**
         * Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
         */
        specs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpec>[]>;
    }

    export interface GitOpsApplicationsApplicationMetadata {
        /**
         * Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
         */
        clusterName?: pulumi.Input<string>;
        /**
         * Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
         */
        finalizers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
         */
        generateName?: pulumi.Input<string>;
        /**
         * A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
         */
        generation?: pulumi.Input<string>;
        /**
         * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
         */
        name?: pulumi.Input<string>;
        /**
         * Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
         */
        namespace?: pulumi.Input<string>;
        /**
         * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
         */
        ownerReferences?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationMetadataOwnerReference>[]>;
        /**
         * UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
         */
        uid?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationMetadataOwnerReference {
        /**
         * API version of the referent.
         */
        apiVersion?: pulumi.Input<string>;
        /**
         * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
         */
        blockOwnerDeletion?: pulumi.Input<boolean>;
        /**
         * Indicates if the reference points to the managing controller.
         */
        controller?: pulumi.Input<boolean>;
        /**
         * Kind of the referent.
         */
        kind?: pulumi.Input<string>;
        /**
         * Name of the referent.
         */
        name?: pulumi.Input<string>;
        /**
         * UID of the referent.
         */
        uid?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpec {
        /**
         * Information about the GitOps application's destination.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecDestination>[]>;
        /**
         * The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
         */
        project?: pulumi.Input<string>;
        /**
         * Contains all information about the source of the GitOps application.
         */
        sources?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSource>[]>;
        /**
         * Controls when a sync will be performed in response to updates in git.
         */
        syncPolicies?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicy>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecDestination {
        /**
         * URL of the target cluster and must be set to the kubernetes control plane API.
         */
        name?: pulumi.Input<string>;
        /**
         * Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
         */
        namespace?: pulumi.Input<string>;
        /**
         * URL of the target cluster server for the GitOps application.
         */
        server?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSource {
        /**
         * Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
         */
        chart?: pulumi.Input<string>;
        /**
         * Options for applications of type plain YAML or Jsonnet.
         */
        directories?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectory>[]>;
        /**
         * Holds helm specific options.
         */
        helms?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceHelm>[]>;
        /**
         * Ksonnet specific options.
         */
        ksonnets?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceKsonnet>[]>;
        /**
         * Options specific to a GitOps application source specific to Kustomize.
         */
        kustomizes?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceKustomize>[]>;
        /**
         * Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
         */
        path?: pulumi.Input<string>;
        /**
         * Options specific to config management plugins.
         */
        plugins?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourcePlugin>[]>;
        /**
         * URL to the repository (git or helm) that contains the GitOps application manifests.
         */
        repoUrl: pulumi.Input<string>;
        /**
         * Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
         */
        targetRevision: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectory {
        /**
         * Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
         */
        exclude?: pulumi.Input<string>;
        /**
         * Glob pattern to match paths against that should be explicitly included during manifest generation.
         */
        include?: pulumi.Input<string>;
        /**
         * Options specific to applications of type Jsonnet.
         */
        jsonnets?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet>[]>;
        /**
         * Indicates to scan a directory recursively for manifests.
         */
        recurse?: pulumi.Input<boolean>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet {
        /**
         * List of jsonnet external variables.
         */
        extVars?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar>[]>;
        /**
         * Additional library search dirs.
         */
        libs?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * List of jsonnet top-level arguments(TLAS).
         */
        tlas?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar {
        /**
         * Code of the external variables of jsonnet application.
         */
        code?: pulumi.Input<boolean>;
        /**
         * Name of the external variables of jsonnet application.
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the external variables of jsonnet application.
         */
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla {
        /**
         * Code of the TLAS of the jsonnet application.
         */
        code?: pulumi.Input<boolean>;
        /**
         * Name of the TLAS of the jsonnet application.
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the TLAS of the jsonnet application.
         */
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelm {
        /**
         * File parameters to the helm template.
         */
        fileParameters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceHelmFileParameter>[]>;
        /**
         * List of helm parameters which are passed to the helm template command upon manifest generation.
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceHelmParameter>[]>;
        /**
         * Indicates if to pass credentials to all domains (helm's --pass-credentials)
         */
        passCredentials?: pulumi.Input<boolean>;
        /**
         * Helm release name to use. If omitted it will use the GitOps application name.
         */
        releaseName?: pulumi.Input<string>;
        /**
         * List of helm value files to use when generating a template.
         */
        valueFiles?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Helm values to be passed to helm template, typically defined as a block.
         */
        values?: pulumi.Input<string>;
        /**
         * Helm version to use for templating (either "2" or "3")
         */
        version?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelmFileParameter {
        /**
         * Name of the helm parameter.
         */
        name?: pulumi.Input<string>;
        /**
         * Path to the file containing the values of the helm parameter.
         */
        path?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceHelmParameter {
        /**
         * Indicates if helm should interpret booleans and numbers as strings.
         */
        forceString?: pulumi.Input<boolean>;
        /**
         * Name of the helm parameter.
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the Helm parameter.
         */
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKsonnet {
        /**
         * Ksonnet application environment name.
         */
        environment?: pulumi.Input<string>;
        /**
         * List of ksonnet component parameter override values.
         */
        parameters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourceKsonnetParameter>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKsonnetParameter {
        /**
         * Component of the parameter of the ksonnet application.
         */
        component?: pulumi.Input<string>;
        /**
         * Name of the parameter of the ksonnet application.
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the parameter of the ksonnet application.
         */
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourceKustomize {
        /**
         * List of additional annotations to add to rendered manifests.
         */
        commonAnnotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * List of additional labels to add to rendered manifests.
         */
        commonLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Indicates if to force applying common annotations to resources for kustomize apps.
         */
        forceCommonAnnotations?: pulumi.Input<boolean>;
        /**
         * Indicates if to force apply common labels to resources for kustomize apps.
         */
        forceCommonLabels?: pulumi.Input<boolean>;
        /**
         * List of kustomize image override specifications.
         */
        images?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Prefix prepended to resources for kustomize apps.
         */
        namePrefix?: pulumi.Input<string>;
        /**
         * Suffix appended to resources for kustomize apps.
         */
        nameSuffix?: pulumi.Input<string>;
        /**
         * Version of kustomize to use for rendering manifests.
         */
        version?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourcePlugin {
        /**
         * Entry in the GitOps application's environment.
         */
        envs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSourcePluginEnv>[]>;
        /**
         * Name of the plugin.
         */
        name?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSourcePluginEnv {
        /**
         * Name of the variable, usually expressed in uppercase.
         */
        name?: pulumi.Input<string>;
        /**
         * Value of the variable.
         */
        value?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicy {
        /**
         * Controls the behavior of an automated sync.
         */
        automateds?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyAutomated>[]>;
        /**
         * Contains information about the strategy to apply when a sync failed.
         */
        retries?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyRetry>[]>;
        /**
         * Options allow you to specify whole app sync-options.
         */
        syncOptions?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyAutomated {
        /**
         * Indicates to allows apps to have zero live resources (default: false).
         */
        allowEmpty?: pulumi.Input<boolean>;
        /**
         * Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
         */
        prune?: pulumi.Input<boolean>;
        /**
         * Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
         */
        selfHeal?: pulumi.Input<boolean>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyRetry {
        /**
         * Backoff strategy to use on subsequent retries for failing syncs.
         */
        backoffs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff>[]>;
        /**
         * Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
         */
        limit?: pulumi.Input<string>;
    }

    export interface GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff {
        /**
         * Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
         */
        duration?: pulumi.Input<string>;
        /**
         * Factor to multiply the base duration after each failed retry.
         */
        factor?: pulumi.Input<string>;
        /**
         * Maximum amount of time allowed of the backoff strategy.
         */
        maxDuration?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequest {
        /**
         * GitOps cluster details.
         */
        clusters?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestCluster>[]>;
        /**
         * Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Fields which are updated.
         */
        updatedFields?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Indicates if the GitOps cluster should be updated if existing and inserted if not.
         */
        upsert?: pulumi.Input<boolean>;
    }

    export interface GitOpsClusterRequestCluster {
        /**
         * Annotations for cluster secret metadata.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
         */
        clusterResources?: pulumi.Input<boolean>;
        /**
         * GitOps cluster config.
         */
        configs: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfig>[]>;
        /**
         * Information about cluster cache and state.
         */
        infos?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfo>[]>;
        /**
         * Labels for cluster secret metadata.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name of the cluster. If omitted, the server address will be used.
         */
        name?: pulumi.Input<string>;
        /**
         * List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
         */
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
         */
        project?: pulumi.Input<string>;
        /**
         * Time when cluster cache refresh has been requested.
         */
        refreshRequestedAts?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterRefreshRequestedAt>[]>;
        /**
         * API server URL of the kubernetes cluster.
         */
        server: pulumi.Input<string>;
        /**
         * Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
         */
        shard?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfig {
        /**
         * AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
         */
        awsClusterName?: pulumi.Input<string>;
        /**
         * Bearer authentication token the cluster.
         */
        bearerToken?: pulumi.Input<string>;
        /**
         * Identifies the authentication method used to connect to the cluster.
         */
        clusterConnectionType?: pulumi.Input<string>;
        /**
         * Configuration for an exec provider.
         */
        execProviderConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigExecProviderConfig>[]>;
        /**
         * Password of the server of the cluster.
         */
        password?: pulumi.Input<string>;
        /**
         * Optional role ARN. If set then used for AWS IAM Authenticator.
         */
        roleARN?: pulumi.Input<string>;
        /**
         * Settings to enable transport layer security.
         */
        tlsClientConfigs?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterConfigTlsClientConfig>[]>;
        /**
         * Username of the server of the cluster.
         */
        username?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigExecProviderConfig {
        /**
         * Preferred input version of the ExecInfo.
         */
        apiVersion?: pulumi.Input<string>;
        /**
         * Arguments to pass to the command when executing it.
         */
        args?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Command to execute.
         */
        command?: pulumi.Input<string>;
        /**
         * Additional environment variables to expose to the process.
         */
        env?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Message displayed when the executable is not found.
         */
        installHint?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterConfigTlsClientConfig {
        /**
         * CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
         */
        caData?: pulumi.Input<string>;
        /**
         * Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
         */
        certData?: pulumi.Input<string>;
        /**
         * Indicates if the TLS connection to the cluster should be insecure.
         */
        insecure?: pulumi.Input<boolean>;
        /**
         * Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
         */
        keyData?: pulumi.Input<string>;
        /**
         * Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
         */
        serverName?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfo {
        /**
         * List of API versions supported by the cluster.
         */
        apiVersions?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Number of applications managed by Argo CD on the cluster.
         */
        applicationsCount?: pulumi.Input<string>;
        /**
         * Information about the cluster cache.
         */
        cacheInfos?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoCacheInfo>[]>;
        /**
         * Information about the connection to the cluster.
         */
        connectionStates?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoConnectionState>[]>;
        /**
         * Kubernetes version of the cluster.
         */
        serverVersion?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoCacheInfo {
        /**
         * Number of observed kubernetes API count.
         */
        apisCount?: pulumi.Input<string>;
        /**
         * Time of most recent cache synchronization.
         */
        lastCacheSyncTime?: pulumi.Input<string>;
        /**
         * Number of observed kubernetes resources.
         */
        resourcesCount?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionState {
        /**
         * Time when cluster cache refresh has been requested.
         */
        attemptedAts?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt>[]>;
        /**
         * Information about the connection status.
         */
        message?: pulumi.Input<string>;
        /**
         * Current status indicator of the connection.
         */
        status?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt {
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: pulumi.Input<string>;
    }

    export interface GitOpsClusterRequestClusterRefreshRequestedAt {
        /**
         * Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
         */
        nanos?: pulumi.Input<number>;
        /**
         * Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
         */
        seconds?: pulumi.Input<string>;
    }

    export interface GitOpsGnupgRequest {
        /**
         * Public key details.
         */
        publickeys?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsGnupgRequestPublickey>[]>;
        /**
         * Indicates if the GnuPG Key should be inserted if not present or updated if present.
         */
        upsert: pulumi.Input<boolean>;
    }

    export interface GitOpsGnupgRequestPublickey {
        /**
         * Fingerprint is the fingerprint of the key
         */
        fingerprint?: pulumi.Input<string>;
        /**
         * KeyData holds the raw key data, in base64 encoded format.
         */
        keyData: pulumi.Input<string>;
        /**
         * KeyID specifies the key ID, in hexadecimal string format.
         */
        keyId?: pulumi.Input<string>;
        /**
         * Owner holds the owner identification, e.g. a name and e-mail address
         */
        owner?: pulumi.Input<string>;
        /**
         * SubType holds the key's sub type
         */
        subType?: pulumi.Input<string>;
        /**
         * Trust holds the level of trust assigned to this key
         */
        trust?: pulumi.Input<string>;
    }

    export interface GitOpsRepoCertRequest {
        /**
         * certificates details.
         */
        certificates?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsRepoCertRequestCertificate>[]>;
        /**
         * Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
         */
        upsert?: pulumi.Input<boolean>;
    }

    export interface GitOpsRepoCertRequestCertificate {
        /**
         * List of certificates to be processed.
         */
        items?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsRepoCertRequestCertificateItem>[]>;
        /**
         * metadata details
         */
        metadatas?: pulumi.Input<pulumi.Input<inputs.platform.GitOpsRepoCertRequestCertificateMetadata>[]>;
    }

    export interface GitOpsRepoCertRequestCertificateItem {
        /**
         * CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
         */
        certData?: pulumi.Input<string>;
        /**
         * CertInfo will hold additional certificate info, dependent on the certificate type .
         */
        certInfo?: pulumi.Input<string>;
        /**
         * CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
         */
        certSubType?: pulumi.Input<string>;
        /**
         * CertType specifies the type of the certificate - currently one of https or ssh.
         */
        certType?: pulumi.Input<string>;
        /**
         * ServerName specifies the DNS name of the server this certificate is intended.
         */
        serverName?: pulumi.Input<string>;
    }

    export interface GitOpsRepoCertRequestCertificateMetadata {
        /**
         * continue may be set if the user set a limit on the number of items returned.
         */
        continue?: pulumi.Input<string>;
        /**
         * subsequent items in the list.
         */
        remainingItemCount?: pulumi.Input<string>;
        /**
         * Identifies the server's internal version.
         */
        resourceVersion?: pulumi.Input<string>;
        /**
         * selfLink is a URL representing this object.
         */
        selfLink?: pulumi.Input<string>;
    }

    export interface GitOpsRepoCredCred {
        /**
         * Specifies whether helm-oci support should be enabled for this repo.
         */
        enableOci?: pulumi.Input<boolean>;
        /**
         * Specifies the GitHub API URL for GitHub app authentication.
         */
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        /**
         * Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
         */
        githubAppId?: pulumi.Input<string>;
        /**
         * Specifies the ID of the installed GitHub App for GitHub app authentication.
         */
        githubAppInstallationId?: pulumi.Input<string>;
        /**
         * github*app*private_key specifies the private key PEM data for authentication via GitHub app.
         */
        githubAppPrivateKey?: pulumi.Input<string>;
        /**
         * Password or PAT to be used for authenticating the remote repository.
         */
        password?: pulumi.Input<string>;
        /**
         * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
         */
        sshPrivateKey?: pulumi.Input<string>;
        /**
         * Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
         */
        tlsClientCertData?: pulumi.Input<string>;
        /**
         * Private key in PEM format for authenticating at the repo server. This is used for mTLS.
         */
        tlsClientCertKey?: pulumi.Input<string>;
        /**
         * Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
         */
        type?: pulumi.Input<string>;
        /**
         * URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
         */
        url?: pulumi.Input<string>;
        /**
         * Username to be used for authenticating the remote repository.
         */
        username?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryEcrGen {
        /**
         * JWT authentication specific configuration.
         */
        jwtAuth?: pulumi.Input<inputs.platform.GitOpsRepositoryEcrGenJwtAuth>;
        /**
         * AWS region.
         */
        region?: pulumi.Input<string>;
        /**
         * Secret reference to the AWS credentials.
         */
        secretRef?: pulumi.Input<inputs.platform.GitOpsRepositoryEcrGenSecretRef>;
    }

    export interface GitOpsRepositoryEcrGenJwtAuth {
        /**
         * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
         */
        audiences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the ServiceAccount resource being referred to.
         */
        name?: pulumi.Input<string>;
        /**
         * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryEcrGenSecretRef {
        /**
         * AWS access key id.
         */
        awsAccessKeyId?: pulumi.Input<string>;
        /**
         * AWS secret access key.
         */
        awsSecretAccessKey?: pulumi.Input<string>;
        /**
         * AWS session token.
         */
        awsSessionToken?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryGcrGen {
        /**
         * GCP access key.
         */
        accessKey?: pulumi.Input<string>;
        /**
         * GCP project id.
         */
        projectId?: pulumi.Input<string>;
        /**
         * GCP workload identity.
         */
        workloadIdentity?: pulumi.Input<inputs.platform.GitOpsRepositoryGcrGenWorkloadIdentity>;
    }

    export interface GitOpsRepositoryGcrGenWorkloadIdentity {
        /**
         * Cluster location.
         */
        clusterLocation?: pulumi.Input<string>;
        /**
         * Cluster name.
         */
        clusterName?: pulumi.Input<string>;
        /**
         * Cluster project id.
         */
        clusterProjectId?: pulumi.Input<string>;
        /**
         * Service account reference.
         */
        serviceAccountRef?: pulumi.Input<inputs.platform.GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRef>;
    }

    export interface GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRef {
        /**
         * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
         */
        audiences?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * The name of the ServiceAccount resource being referred to.
         */
        name?: pulumi.Input<string>;
        /**
         * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
         */
        namespace?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryRepo {
        /**
         * Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS*ANONYMOUS", "GITHUB*ENTERPRISE".
         */
        connectionType: pulumi.Input<string>;
        /**
         * Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
         */
        enableLfs?: pulumi.Input<boolean>;
        /**
         * Indicates if helm-oci support must be enabled for this repo.
         */
        enableOci?: pulumi.Input<boolean>;
        /**
         * Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
         */
        githubAppEnterpriseBaseUrl?: pulumi.Input<string>;
        /**
         * Id of the GitHub app used to access the repo.
         */
        githubAppId?: pulumi.Input<string>;
        /**
         * Installation id of the GitHub app used to access the repo.
         */
        githubAppInstallationId?: pulumi.Input<string>;
        /**
         * GitHub app private key PEM data.
         */
        githubAppPrivateKey?: pulumi.Input<string>;
        /**
         * Indicates if the credentials were inherited from a repository credential.
         */
        inheritedCreds?: pulumi.Input<boolean>;
        /**
         * Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
         */
        insecure?: pulumi.Input<boolean>;
        /**
         * Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
         */
        insecureIgnoreHostKey?: pulumi.Input<boolean>;
        /**
         * Name to be used for this repo. Only used with Helm repos.
         */
        name?: pulumi.Input<string>;
        /**
         * Password or PAT to be used for authenticating the remote repository.
         */
        password?: pulumi.Input<string>;
        /**
         * The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
         */
        project?: pulumi.Input<string>;
        /**
         * The HTTP/HTTPS proxy used to access the repo.
         */
        proxy?: pulumi.Input<string>;
        /**
         * URL to the remote repository.
         */
        repo: pulumi.Input<string>;
        /**
         * SSH Key in PEM format for authenticating the repository. Used only for Git repository.
         */
        sshPrivateKey?: pulumi.Input<string>;
        /**
         * Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
         */
        tlsClientCertData?: pulumi.Input<string>;
        /**
         * Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
         */
        tlsClientCertKey?: pulumi.Input<string>;
        /**
         * Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
         */
        type_?: pulumi.Input<string>;
        /**
         * Username to be used for authenticating the remote repository.
         */
        username?: pulumi.Input<string>;
    }

    export interface GitOpsRepositoryUpdateMask {
        /**
         * The set of field mask paths.
         */
        paths?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GithubConnectorApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: pulumi.Input<inputs.platform.GithubConnectorApiAuthenticationGithubApp>;
        /**
         * Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef?: pulumi.Input<string>;
    }

    export interface GithubConnectorApiAuthenticationGithubApp {
        /**
         * Enter the GitHub App ID from the GitHub App General tab.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        applicationIdRef?: pulumi.Input<string>;
        /**
         * Enter the Installation ID located in the URL of the installed GitHub App.
         */
        installationId?: pulumi.Input<string>;
        /**
         * Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        installationIdRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        privateKeyRef: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GithubConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GithubConnectorCredentialsSsh>;
    }

    export interface GithubConnectorCredentialsHttp {
        /**
         * Configuration for using the http anonymous github for interacting with the github api.
         */
        anonymouses?: pulumi.Input<pulumi.Input<inputs.platform.GithubConnectorCredentialsHttpAnonymouse>[]>;
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: pulumi.Input<inputs.platform.GithubConnectorCredentialsHttpGithubApp>;
        /**
         * Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef?: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentialsHttpAnonymouse {
    }

    export interface GithubConnectorCredentialsHttpGithubApp {
        /**
         * Enter the GitHub App ID from the GitHub App General tab.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        applicationIdRef?: pulumi.Input<string>;
        /**
         * Enter the Installation ID located in the URL of the installed GitHub App.
         */
        installationId?: pulumi.Input<string>;
        /**
         * Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        installationIdRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        privateKeyRef: pulumi.Input<string>;
    }

    export interface GithubConnectorCredentialsSsh {
        /**
         * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitlabConnectorApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: pulumi.Input<string>;
    }

    export interface GitlabConnectorCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.platform.GitlabConnectorCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.platform.GitlabConnectorCredentialsSsh>;
    }

    export interface GitlabConnectorCredentialsHttp {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef?: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitlabConnectorCredentialsSsh {
        /**
         * Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProject {
        /**
         * K8s object metadata for the Argo project.
         */
        metadatas: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectMetadata>[]>;
        /**
         * Specification details for the Argo project.
         */
        specs: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpec>[]>;
    }

    export interface GitopsAppProjectProjectMetadata {
        /**
         * Annotations associated with the GitOps project.
         */
        annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Name of the cluster associated with the GitOps project.
         */
        clusterName?: pulumi.Input<string>;
        /**
         * Finalizers associated with the GitOps project.
         */
        finalizers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Labels associated with the GitOps project.
         */
        labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Managed fields associated with the GitOps project.
         */
        managedFields?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectMetadataManagedField>[]>;
        /**
         * Name of the GitOps project.
         */
        name?: pulumi.Input<string>;
        /**
         * Namespace of the GitOps project. This must be the same as the namespace where the agent is installed
         */
        namespace?: pulumi.Input<string>;
        /**
         * Resource Version for the GitOps project
         */
        resourceVersion?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectMetadataManagedField {
        /**
         * API version of the operation performed.
         */
        apiVersion?: pulumi.Input<string>;
        /**
         * Type of the fields in the GitOps project.
         */
        fieldsType?: pulumi.Input<string>;
        /**
         * Raw fields associated with the GitOps project.
         */
        fieldsV1?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        /**
         * Manager responsible for the operation.
         */
        manager?: pulumi.Input<string>;
        /**
         * Operation type performed on the GitOps project.
         */
        operation?: pulumi.Input<string>;
        /**
         * Subresource associated with the GitOps project.
         */
        subresource?: pulumi.Input<string>;
        /**
         * Timestamp of the operation.
         */
        time?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    }

    export interface GitopsAppProjectProjectSpec {
        /**
         * Cluster resource blacklist for the GitOps project.
         */
        clusterResourceBlacklists?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecClusterResourceBlacklist>[]>;
        /**
         * Cluster resource whitelist for the Argo project.
         */
        clusterResourceWhitelists?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecClusterResourceWhitelist>[]>;
        /**
         * Description of the Argo project.
         */
        description?: pulumi.Input<string>;
        /**
         * Allowed destinations for applications in this Argo project.
         */
        destinations?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecDestination>[]>;
        /**
         * Namespace resource blacklist for the Argo project.
         */
        namespaceResourceBlacklists?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecNamespaceResourceBlacklist>[]>;
        /**
         * Namespace resource whitelist for the GitOps project.
         */
        namespaceResourceWhitelists?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecNamespaceResourceWhitelist>[]>;
        /**
         * OrphanedResources specifies if agent should monitor orphaned resources of apps in this project
         */
        orphanedResources?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecOrphanedResource>[]>;
        /**
         * Roles associated with the Argo project.
         */
        roles?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecRole>[]>;
        /**
         * Signature keys for the GitOps project.
         */
        signatureKeys?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecSignatureKey>[]>;
        /**
         * Allowed Source repositories for the Argo project.
         */
        sourceRepos?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Synchronization windows for the GitOps project.
         */
        syncWindows?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecSyncWindow>[]>;
    }

    export interface GitopsAppProjectProjectSpecClusterResourceBlacklist {
        /**
         * Group of the cluster resource blacklist.
         */
        group?: pulumi.Input<string>;
        /**
         * Kind of the cluster resource blacklist.
         */
        kind?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecClusterResourceWhitelist {
        /**
         * Group of the cluster resource whitelist.
         */
        group?: pulumi.Input<string>;
        /**
         * Kind of the cluster resource whitelist.
         */
        kind?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecDestination {
        /**
         * Name of the destination cluster.
         */
        name?: pulumi.Input<string>;
        /**
         * Permitted Namespaces for deployment in the destination cluster.
         */
        namespace?: pulumi.Input<string>;
        /**
         * Server URL of the destination cluster.
         */
        server?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecNamespaceResourceBlacklist {
        /**
         * Group of the namespace resource blacklist.
         */
        group?: pulumi.Input<string>;
        /**
         * Kind of the namespace resource blacklist.
         */
        kind?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecNamespaceResourceWhitelist {
        /**
         * Group of the namespace resource whitelist.
         */
        group?: pulumi.Input<string>;
        /**
         * Kind of the namespace resource whitelist.
         */
        kind?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecOrphanedResource {
        /**
         * List of ignored orphaned resources.
         */
        ignores?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecOrphanedResourceIgnore>[]>;
        /**
         * Whether to warn about orphaned resources.
         */
        warn?: pulumi.Input<boolean>;
    }

    export interface GitopsAppProjectProjectSpecOrphanedResourceIgnore {
        /**
         * Group of the ignored orphaned resource.
         */
        group?: pulumi.Input<string>;
        /**
         * Kind of the ignored orphaned resource.
         */
        kind?: pulumi.Input<string>;
        /**
         * Name of the ignored orphaned resource.
         */
        name?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecRole {
        /**
         * Description of the role.
         */
        description: pulumi.Input<string>;
        /**
         * Groups associated with the role.
         */
        groups?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * JWT tokens associated with the role.
         */
        jwtTokens?: pulumi.Input<pulumi.Input<inputs.platform.GitopsAppProjectProjectSpecRoleJwtToken>[]>;
        /**
         * Name of the role.
         */
        name: pulumi.Input<string>;
        /**
         * Policies associated with the role. These are argo RBAC policies and may not necessarily reflect in harness.
         */
        policies?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GitopsAppProjectProjectSpecRoleJwtToken {
        /**
         * Expiration time of the JWT token.
         */
        exp?: pulumi.Input<string>;
        /**
         * Issued At time of the JWT token.
         */
        iat?: pulumi.Input<string>;
        /**
         * ID of the JWT token.
         */
        id?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecSignatureKey {
        /**
         * ID of the signature key.
         */
        keyId?: pulumi.Input<string>;
    }

    export interface GitopsAppProjectProjectSpecSyncWindow {
        /**
         * Applications associated with synchronization window.
         */
        applications?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Clusters associated with synchronization window.
         */
        clusters?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Duration of synchronization window.
         */
        duration?: pulumi.Input<string>;
        /**
         * Kind of synchronization window.
         */
        kind?: pulumi.Input<string>;
        /**
         * Whether manual synchronization is enabled.
         */
        manualSync?: pulumi.Input<boolean>;
        /**
         * Namespaces associated with synchronization window.
         */
        namespaces?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Schedule of synchronization window.
         */
        schedule?: pulumi.Input<string>;
        /**
         * Time zone of synchronization window.
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface HelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface InfrastructureGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * message for the commit in Git Repo.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Flag to set if importing from Git
         */
        importFromGit?: pulumi.Input<boolean>;
        /**
         * Flag to set if force importing from Git
         */
        isForceImport?: pulumi.Input<boolean>;
        /**
         * If the gitProvider is HarnessCode
         */
        isHarnesscodeRepo?: pulumi.Input<boolean>;
        /**
         * If a new branch creation is requested.
         */
        isNewBranch?: pulumi.Input<boolean>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Infrastructures.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Infrastructures.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * If the Entity is to be fetched from cache
         */
        loadFromCache?: pulumi.Input<string>;
        /**
         * Whether the file has to be get from fallback_branch.
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        parentEntityConnectorRef?: pulumi.Input<string>;
        /**
         * Name of the repository where parent entity lies.
         */
        parentEntityRepoName?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * store type of the entity.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface InputSetGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        parentEntityConnectorRef?: pulumi.Input<string>;
        /**
         * Repository name for Parent Entity (Pipeline).
         */
        parentEntityRepoName?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface InputSetGitImportInfo {
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        isForceImport?: pulumi.Input<boolean>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
    }

    export interface InputSetInputSetImportRequest {
        /**
         * Description of the input set.
         */
        inputSetDescription?: pulumi.Input<string>;
        /**
         * Name of the input set.
         */
        inputSetName?: pulumi.Input<string>;
    }

    export interface JenkinsConnectorAuth {
        /**
         * Authenticate to App Dynamics using bearer token.
         */
        jenkinsBearerToken?: pulumi.Input<inputs.platform.JenkinsConnectorAuthJenkinsBearerToken>;
        /**
         * Authenticate to App Dynamics using user name and password.
         */
        jenkinsUserNamePassword?: pulumi.Input<inputs.platform.JenkinsConnectorAuthJenkinsUserNamePassword>;
        /**
         * Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
         */
        type: pulumi.Input<string>;
    }

    export interface JenkinsConnectorAuthJenkinsBearerToken {
        /**
         * Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        tokenRef: pulumi.Input<string>;
    }

    export interface JenkinsConnectorAuthJenkinsUserNamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.To reference a secret at the project scope, use directly without any prefix.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Username reference to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface JiraConnectorAuth {
        /**
         * Authentication types for Jira connector
         */
        authType: pulumi.Input<string>;
        /**
         * Authenticate using personal access token.
         */
        personalAccessToken?: pulumi.Input<inputs.platform.JiraConnectorAuthPersonalAccessToken>;
        /**
         * Authenticate using username password.
         */
        usernamePassword?: pulumi.Input<inputs.platform.JiraConnectorAuthUsernamePassword>;
    }

    export interface JiraConnectorAuthPersonalAccessToken {
        /**
         * Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        patRef: pulumi.Input<string>;
    }

    export interface JiraConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesConnectorClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        caCertRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientCertRef: pulumi.Input<string>;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientKeyPassphraseRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientKeyRef: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
    }

    export interface KubernetesConnectorInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface KubernetesConnectorOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientIdRef: pulumi.Input<string>;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Scopes to request for the connector.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        secretRef?: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesConnectorServiceAccount {
        /**
         * Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        caCertRef?: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        serviceAccountTokenRef: pulumi.Input<string>;
    }

    export interface KubernetesConnectorUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface ManualFreezeCurrentOrUpcomingWindow {
        /**
         * End time of the freeze
         */
        endTime?: pulumi.Input<number>;
        /**
         * Start time of the freeze
         */
        startTime?: pulumi.Input<number>;
    }

    export interface ManualFreezeFreezeWindow {
        /**
         * Duration of the freeze
         */
        duration?: pulumi.Input<string>;
        /**
         * End time of the freeze
         */
        endTime?: pulumi.Input<string>;
        /**
         * Recurrence of the freeze window
         */
        recurrences?: pulumi.Input<pulumi.Input<inputs.platform.ManualFreezeFreezeWindowRecurrence>[]>;
        /**
         * Start time of the freeze
         */
        startTime?: pulumi.Input<string>;
        /**
         * Timezone
         */
        timeZone?: pulumi.Input<string>;
    }

    export interface ManualFreezeFreezeWindowRecurrence {
        /**
         * Used to filter resources on their attributes
         */
        recurrenceSpecs?: pulumi.Input<pulumi.Input<inputs.platform.ManualFreezeFreezeWindowRecurrenceRecurrenceSpec>[]>;
        /**
         * Recurrence type(Daily, Weekly, Monthly, Yearly)
         */
        type?: pulumi.Input<string>;
    }

    export interface ManualFreezeFreezeWindowRecurrenceRecurrenceSpec {
        /**
         * Recurrence until timestamp
         */
        until?: pulumi.Input<string>;
        /**
         * Value of n, for n months recurrence
         */
        value?: pulumi.Input<number>;
    }

    export interface MonitoredServiceRequest {
        /**
         * Set of change sources for the monitored service.
         */
        changeSources?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestChangeSource>[]>;
        /**
         * Dependencies of the monitored service.
         */
        dependencies?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestDependency>[]>;
        /**
         * Description for the monitored service.
         */
        description?: pulumi.Input<string>;
        /**
         * Enable or disable the monitored service.
         *
         * @deprecated enabled field is deprecated
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Environment in which the service is deployed.
         */
        environmentRef: pulumi.Input<string>;
        /**
         * Environment reference list for the monitored service.
         */
        environmentRefLists?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Set of health sources for the monitored service.
         */
        healthSources?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestHealthSource>[]>;
        /**
         * Name for the monitored service.
         */
        name: pulumi.Input<string>;
        /**
         * Notification rule references for the monitored service.
         */
        notificationRuleRefs?: pulumi.Input<pulumi.Input<inputs.platform.MonitoredServiceRequestNotificationRuleRef>[]>;
        /**
         * Service reference for the monitored service.
         */
        serviceRef: pulumi.Input<string>;
        /**
         * Tags for the monitored service. comma-separated key value string pairs.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Template reference for the monitored service.
         */
        templateRef?: pulumi.Input<string>;
        /**
         * Type of the monitored service.
         */
        type: pulumi.Input<string>;
        /**
         * Template version label for the monitored service.
         */
        versionLabel?: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestChangeSource {
        /**
         * Category of the change source.
         */
        category: pulumi.Input<string>;
        /**
         * Enable or disable the change source.
         */
        enabled?: pulumi.Input<boolean>;
        /**
         * Identifier of the change source.
         */
        identifier: pulumi.Input<string>;
        /**
         * Name of the change source.
         */
        name: pulumi.Input<string>;
        /**
         * Specification of the change source. Depends on the type of the change source.
         */
        spec?: pulumi.Input<string>;
        /**
         * Type of the change source.
         */
        type: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestDependency {
        /**
         * Dependency metadata for the monitored service.
         */
        dependencyMetadata?: pulumi.Input<string>;
        /**
         * Monitored service identifier of the dependency.
         */
        monitoredServiceIdentifier: pulumi.Input<string>;
        /**
         * Type of the service dependency.
         */
        type: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestHealthSource {
        /**
         * Identifier of the health source.
         */
        identifier: pulumi.Input<string>;
        /**
         * Name of the health source.
         */
        name: pulumi.Input<string>;
        /**
         * Specification of the health source. Depends on the type of the health source.
         */
        spec: pulumi.Input<string>;
        /**
         * Type of the health source.
         */
        type: pulumi.Input<string>;
        /**
         * Version of the health source.
         */
        version?: pulumi.Input<string>;
    }

    export interface MonitoredServiceRequestNotificationRuleRef {
        /**
         * Enable or disable notification rule reference for the monitored service.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Notification rule reference for the monitored service.
         */
        notificationRuleRef: pulumi.Input<string>;
    }

    export interface NexusConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface NotificationRuleRequest {
        /**
         * Notification Rule conditions specification.
         */
        conditions: pulumi.Input<pulumi.Input<inputs.platform.NotificationRuleRequestCondition>[]>;
        /**
         * Name for the Notification Rule.
         */
        name: pulumi.Input<string>;
        /**
         * Notification Method specifications.
         */
        notificationMethod: pulumi.Input<inputs.platform.NotificationRuleRequestNotificationMethod>;
        /**
         * Type of the Notification Rule.
         */
        type: pulumi.Input<string>;
    }

    export interface NotificationRuleRequestCondition {
        /**
         * Specification of the notification condition. Depends on the type of the notification condition.
         */
        spec?: pulumi.Input<string>;
        /**
         * Type of the condition.
         */
        type: pulumi.Input<string>;
    }

    export interface NotificationRuleRequestNotificationMethod {
        /**
         * Specification of the notification method. Depends on the type of the notification method.
         */
        spec?: pulumi.Input<string>;
        /**
         * Type of the Notification Method.
         */
        type: pulumi.Input<string>;
    }

    export interface OciHelmConnectorCredentials {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface OverridesGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * If the repo is in harness code
         */
        isHarnessCodeRepo?: pulumi.Input<boolean>;
        /**
         * If the branch being created is new
         */
        isNewBranch?: pulumi.Input<boolean>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating override.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Load service yaml from catch
         */
        loadFromCache?: pulumi.Input<boolean>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface PipelineFiltersFilterProperties {
        /**
         * description of the pipline filter.
         */
        description?: pulumi.Input<string>;
        /**
         * Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
         */
        filterType: pulumi.Input<string>;
        /**
         * module properties of the pipline filter.
         */
        moduleProperties?: pulumi.Input<inputs.platform.PipelineFiltersFilterPropertiesModuleProperties>;
        /**
         * Name of the pipeline filter.
         */
        name?: pulumi.Input<string>;
        /**
         * Pipeline identifiers to filter on.
         */
        pipelineIdentifiers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
         */
        pipelineTags?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipelineFiltersFilterPropertiesModuleProperties {
        /**
         * CD related properties to be filtered on.
         */
        cd?: pulumi.Input<inputs.platform.PipelineFiltersFilterPropertiesModulePropertiesCd>;
        /**
         * CI related properties to be filtered on.
         */
        ci?: pulumi.Input<inputs.platform.PipelineFiltersFilterPropertiesModulePropertiesCi>;
    }

    export interface PipelineFiltersFilterPropertiesModulePropertiesCd {
        /**
         * Artifact display names of the CD pipeline.
         */
        artifactDisplayNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Deployment type of the CD pipeline, eg. Kubernetes
         */
        deploymentTypes?: pulumi.Input<string>;
        /**
         * Environment names of the CD pipeline.
         */
        environmentNames?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Service names of the CD pipeline.
         */
        serviceNames?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface PipelineFiltersFilterPropertiesModulePropertiesCi {
        /**
         * Branch which was used while building.
         */
        branch?: pulumi.Input<string>;
        /**
         * Build type of the pipeline. Possible values: branch.
         */
        buildType?: pulumi.Input<string>;
        /**
         * CI execution info for the pipeline.
         */
        ciExecutionInfo?: pulumi.Input<inputs.platform.PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo>;
        /**
         * name of the repository used in the pipeline.
         */
        repoNames?: pulumi.Input<string>;
        /**
         * Tags to associate with the CI pipeline resource.
         */
        tag?: pulumi.Input<string>;
    }

    export interface PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo {
        /**
         * Event for the ci execution, Possible values: pullRequest.
         */
        event?: pulumi.Input<string>;
        /**
         * The pull request details of the CI pipeline.
         */
        pullRequest?: pulumi.Input<inputs.platform.PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest>;
    }

    export interface PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest {
        /**
         * Source branch of the pull request.
         */
        sourceBranch?: pulumi.Input<string>;
        /**
         * Target branch of the pull request.
         */
        targetBranch?: pulumi.Input<string>;
    }

    export interface PipelineGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface PipelineGitImportInfo {
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
    }

    export interface PipelinePipelineImportRequest {
        /**
         * Description of the pipeline.
         */
        pipelineDescription?: pulumi.Input<string>;
        /**
         * Name of the pipeline.
         */
        pipelineName?: pulumi.Input<string>;
    }

    export interface PolicySetPolicy {
        /**
         * Account Identifier of the account
         */
        identifier: pulumi.Input<string>;
        /**
         * Policy failure response - 'warning' for continuation, 'error' for exit
         */
        severity: pulumi.Input<string>;
    }

    export interface PrometheusConnectorHeader {
        /**
         * Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        encryptedValueRef?: pulumi.Input<string>;
        /**
         * Key.
         */
        key: pulumi.Input<string>;
        /**
         * Value.
         */
        value?: pulumi.Input<string>;
        /**
         * Encrypted value.
         */
        valueEncrypted?: pulumi.Input<boolean>;
    }

    export interface RepoRuleBranchBypass {
        /**
         * Allow users with repository edit permission to bypass.
         */
        repoOwners?: pulumi.Input<boolean>;
        /**
         * List of user ids with who can bypass.
         */
        userIds?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RepoRuleBranchPattern {
        /**
         * Should rule apply to default branch of the repository.
         */
        defaultBranch?: pulumi.Input<boolean>;
        /**
         * Globstar branch patterns on which rules will NOT be applied.
         */
        excludes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Globstar branch patterns on which rules will be applied.
         */
        includes?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RepoRuleBranchPolicy {
        /**
         * Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
         */
        allowMergeStrategies?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Only allow users with bypass permission to create matching branches.
         */
        blockBranchCreation?: pulumi.Input<boolean>;
        /**
         * Only allow users with bypass permission to delete matching branches.
         */
        blockBranchDeletion?: pulumi.Input<boolean>;
        /**
         * Automatically delete the source branch of a pull request after it is merged.
         */
        deleteBranchOnMerge?: pulumi.Input<boolean>;
        /**
         * Require approval on pull requests from one reviewer for each codeowner rule.
         */
        requireCodeOwners?: pulumi.Input<boolean>;
        /**
         * Require re-approval when there are new changes in the pull request.
         */
        requireLatestCommitApproval?: pulumi.Input<boolean>;
        /**
         * Require approval on pull requests from a minimum number of reviewers.
         */
        requireMinimumApprovalCount?: pulumi.Input<number>;
        /**
         * Require all request for changes have been resolved.
         */
        requireNoChangeRequest?: pulumi.Input<boolean>;
        /**
         * Do not allow any changes to matching branches without a pull request.
         */
        requirePullRequest?: pulumi.Input<boolean>;
        /**
         * All comments on a pull request must be resolved before it can be merged.
         */
        requireResolveAllComments?: pulumi.Input<boolean>;
        /**
         * Selected status checks must pass before a pull request can be merged.
         */
        requireStatusChecks?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RepoSource {
        /**
         * The host URL for the import source.
         */
        host?: pulumi.Input<string>;
        /**
         * The password for authentication when importing.
         */
        password?: pulumi.Input<string>;
        /**
         * The full identifier of the repository on the SCM provider's platform.
         */
        repo?: pulumi.Input<string>;
        /**
         * The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
         */
        type?: pulumi.Input<string>;
        /**
         * The username for authentication when importing.
         */
        username?: pulumi.Input<string>;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: pulumi.Input<string>;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: pulumi.Input<string>;
        /**
         * Organization Identifier
         */
        orgId?: pulumi.Input<string>;
        /**
         * Project Identifier
         */
        projectId?: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: pulumi.Input<boolean>;
        /**
         * Resources for a resource group
         */
        resources?: pulumi.Input<pulumi.Input<inputs.platform.ResourceGroupResourceFilterResource>[]>;
    }

    export interface ResourceGroupResourceFilterResource {
        /**
         * Used to filter resources on their attributes
         */
        attributeFilters?: pulumi.Input<pulumi.Input<inputs.platform.ResourceGroupResourceFilterResourceAttributeFilter>[]>;
        /**
         * List of the identifiers
         */
        identifiers?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the resource
         */
        resourceType: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        /**
         * Name of the attribute. Valid values are `category`, `type`, `labels`, `tag` or `tags`.
         */
        attributeName?: pulumi.Input<string>;
        /**
         * Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD*COST,CLOUD*PROVIDER,CODE*REPO,MONITORING,SECRET*MANAGER,TICKETING], for `type` are [Production,PreProduction], for `labels`, it can be using the syntax 'label:value', for `tag` or `tags` it can be any string.
         */
        attributeValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface RoleAssignmentsPrincipal {
        /**
         * Identifier.
         */
        identifier?: pulumi.Input<string>;
        /**
         * Scope level.
         */
        scopeLevel?: pulumi.Input<string>;
        /**
         * Type.
         */
        type: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: pulumi.Input<string>;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: pulumi.Input<string>;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: pulumi.Input<string>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: pulumi.Input<inputs.platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: pulumi.Input<inputs.platform.SecretSshkeyKerberosTgtPasswordSpec>;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        /**
         * key path
         */
        keyPath?: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        /**
         * password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
         */
        password?: pulumi.Input<string>;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: pulumi.Input<string>;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshPasswordCredential>;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshkeyPathCredential>;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: pulumi.Input<inputs.platform.SecretSshkeySshSshkeyReferenceCredential>;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        /**
         * SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
         */
        password: pulumi.Input<string>;
        /**
         * SSH Username.
         */
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        /**
         * Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
         */
        encryptedPassphrase?: pulumi.Input<string>;
        /**
         * Path of the key file.
         */
        keyPath: pulumi.Input<string>;
        /**
         * SSH Username.
         */
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        /**
         * Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
         */
        encryptedPassphrase?: pulumi.Input<string>;
        /**
         * SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
         */
        key: pulumi.Input<string>;
        /**
         * SSH Username.
         */
        userName: pulumi.Input<string>;
    }

    export interface SecretTextAdditionalMetadata {
        values?: pulumi.Input<pulumi.Input<inputs.platform.SecretTextAdditionalMetadataValue>[]>;
    }

    export interface SecretTextAdditionalMetadataValue {
        version?: pulumi.Input<string>;
    }

    export interface ServiceGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * If the repo is in harness code
         */
        isHarnessCodeRepo?: pulumi.Input<boolean>;
        /**
         * If the branch being created is new
         */
        isNewBranch?: pulumi.Input<boolean>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Load service yaml from catch
         */
        loadFromCache?: pulumi.Input<boolean>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface ServiceNowConnectorAuth {
        /**
         * Authenticate using adfs client credentials with certificate.
         */
        adfs?: pulumi.Input<inputs.platform.ServiceNowConnectorAuthAdfs>;
        /**
         * Authentication types for Jira connector
         */
        authType: pulumi.Input<string>;
        /**
         * Authenticate using refresh token grant type.
         */
        refreshToken?: pulumi.Input<inputs.platform.ServiceNowConnectorAuthRefreshToken>;
        /**
         * Authenticate using username password.
         */
        usernamePassword?: pulumi.Input<inputs.platform.ServiceNowConnectorAuthUsernamePassword>;
    }

    export interface ServiceNowConnectorAuthAdfs {
        /**
         * asdf URL.
         */
        adfsUrl: pulumi.Input<string>;
        /**
         * Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        certificateRef: pulumi.Input<string>;
        /**
         * Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientIdRef: pulumi.Input<string>;
        /**
         * Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        privateKeyRef: pulumi.Input<string>;
        /**
         * Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        resourceIdRef: pulumi.Input<string>;
    }

    export interface ServiceNowConnectorAuthRefreshToken {
        /**
         * Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientIdRef: pulumi.Input<string>;
        /**
         * Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        clientSecretRef?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        refreshTokenRef: pulumi.Input<string>;
        /**
         * Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        scope?: pulumi.Input<string>;
        /**
         * Token url to use for authentication.
         */
        tokenUrl: pulumi.Input<string>;
    }

    export interface ServiceNowConnectorAuthUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface ServiceOverridesV2GitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branch?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * If the repo is in harness code
         */
        isHarnessCodeRepo?: pulumi.Input<boolean>;
        /**
         * If the branch being created is new
         */
        isNewBranch?: pulumi.Input<boolean>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating override.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Load service yaml from catch
         */
        loadFromCache?: pulumi.Input<boolean>;
        /**
         * Load service yaml from fallback branch
         */
        loadFromFallbackBranch?: pulumi.Input<boolean>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface SloRequest {
        /**
         * Description for the SLO.
         */
        description?: pulumi.Input<string>;
        /**
         * Name for the SLO.
         */
        name: pulumi.Input<string>;
        /**
         * Notification rule references for the SLO.
         */
        notificationRuleRefs?: pulumi.Input<pulumi.Input<inputs.platform.SloRequestNotificationRuleRef>[]>;
        /**
         * SLO Target specification.
         */
        sloTarget: pulumi.Input<inputs.platform.SloRequestSloTarget>;
        /**
         * Specification of the SLO.
         */
        spec: pulumi.Input<string>;
        /**
         * Tags for the SLO. comma-separated key value string pairs.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Type of the SLO.
         */
        type: pulumi.Input<string>;
        /**
         * User journey reference list for the SLO.
         */
        userJourneyRefs: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SloRequestNotificationRuleRef {
        /**
         * Enable or disable notification rule reference for the SLO.
         */
        enabled: pulumi.Input<boolean>;
        /**
         * Notification rule reference for the SLO.
         */
        notificationRuleRef: pulumi.Input<string>;
    }

    export interface SloRequestSloTarget {
        /**
         * Target percentage for the SLO.
         */
        sloTargetPercentage: pulumi.Input<number>;
        /**
         * Specification of the SLO Target.
         */
        spec: pulumi.Input<string>;
        /**
         * Type of the SLO target.
         */
        type: pulumi.Input<string>;
    }

    export interface SpotConnectorPermanentToken {
        /**
         * Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        apiTokenRef: pulumi.Input<string>;
        /**
         * Connect only using delegates with these tags.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Execute on delegate or not.
         */
        executeOnDelegate?: pulumi.Input<boolean>;
        /**
         * Spot account id.
         */
        spotAccountId?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        spotAccountIdRef?: pulumi.Input<string>;
    }

    export interface TasConnectorCredentials {
        /**
         * Authenticate to Tas using manual details.
         */
        tasManualDetails: pulumi.Input<inputs.platform.TasConnectorCredentialsTasManualDetails>;
        /**
         * Type can be ManualConfig.
         */
        type: pulumi.Input<string>;
    }

    export interface TasConnectorCredentialsTasManualDetails {
        /**
         * URL of the Tas server.
         */
        endpointUrl: pulumi.Input<string>;
        /**
         * Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Reference of the secret for the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}
         */
        referenceToken?: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface TemplateFiltersFilterProperties {
        /**
         * Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
         */
        filterType: pulumi.Input<string>;
        /**
         * Tags to associate with the resource. Tags should be in the form `name:value`.
         */
        tags?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface TemplateGitDetails {
        /**
         * Name of the default branch (this checks out a new branch titled by branch_name).
         */
        baseBranch?: pulumi.Input<string>;
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Commit message used for the merge commit.
         */
        commitMessage?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        /**
         * Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
         */
        lastCommitId?: pulumi.Input<string>;
        /**
         * Last object identifier (for Github). To be provided only when updating Pipeline.
         */
        lastObjectId?: pulumi.Input<string>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
        /**
         * Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
         */
        storeType?: pulumi.Input<string>;
    }

    export interface TemplateGitImportDetails {
        /**
         * Name of the branch.
         */
        branchName?: pulumi.Input<string>;
        /**
         * Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        connectorRef?: pulumi.Input<string>;
        /**
         * File path of the Entity in the repository.
         */
        filePath?: pulumi.Input<string>;
        isForceImport?: pulumi.Input<boolean>;
        /**
         * Name of the repository.
         */
        repoName?: pulumi.Input<string>;
    }

    export interface TemplateTemplateImportRequest {
        /**
         * Description of the template.
         */
        templateDescription?: pulumi.Input<string>;
        /**
         * Name of the template.
         */
        templateName?: pulumi.Input<string>;
        /**
         * Version of the template.
         */
        templateVersion?: pulumi.Input<string>;
    }

    export interface TerraformCloudConnectorCredentials {
        /**
         * API token credentials to use for authentication.
         */
        apiToken: pulumi.Input<inputs.platform.TerraformCloudConnectorCredentialsApiToken>;
    }

    export interface TerraformCloudConnectorCredentialsApiToken {
        /**
         * Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
         */
        apiTokenRef: pulumi.Input<string>;
    }

    export interface UserRoleBinding {
        /**
         * Managed Role of the user.
         */
        managedRole?: pulumi.Input<boolean>;
        /**
         * Resource Group Identifier of the user.
         */
        resourceGroupIdentifier?: pulumi.Input<string>;
        /**
         * Resource Group Name of the user.
         */
        resourceGroupName?: pulumi.Input<string>;
        /**
         * Role Identifier of the user.
         */
        roleIdentifier?: pulumi.Input<string>;
        /**
         * Role Name Identifier of the user.
         */
        roleName?: pulumi.Input<string>;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email.
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook.
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key.
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Send email to all the group members.
         */
        sendEmailToAllUsers?: pulumi.Input<boolean>;
        /**
         * Url of slack webhook.
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
         */
        type?: pulumi.Input<string>;
    }

    export interface VariablesSpec {
        /**
         * FixedValue of the variable
         */
        fixedValue: pulumi.Input<string>;
        /**
         * Type of Value of the Variable. For now only FIXED is supported
         */
        valueType: pulumi.Input<string>;
    }

    export interface WorkspaceEnvironmentVariable {
        /**
         * Key is the identifier for the variable. Must be unique within the workspace.
         */
        key: pulumi.Input<string>;
        /**
         * Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
         */
        value: pulumi.Input<string>;
        /**
         * Value type indicates the value type of the variable. Currently we support string and secret.
         */
        valueType: pulumi.Input<string>;
    }

    export interface WorkspaceTerraformVariable {
        /**
         * Key is the identifier for the variable. Must be unique within the workspace.
         */
        key: pulumi.Input<string>;
        /**
         * Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
         */
        value: pulumi.Input<string>;
        /**
         * Value type indicates the value type of the variable. Currently we support string and secret.
         */
        valueType: pulumi.Input<string>;
    }

    export interface WorkspaceTerraformVariableFile {
        /**
         * Repository is the name of the repository to fetch the code from.
         */
        repository: pulumi.Input<string>;
        /**
         * Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
         */
        repositoryBranch?: pulumi.Input<string>;
        /**
         * Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
         */
        repositoryCommit?: pulumi.Input<string>;
        /**
         * Repository connector is the reference to the connector used to fetch the variables.
         */
        repositoryConnector: pulumi.Input<string>;
        /**
         * Repository path is the path in which the variables reside.
         */
        repositoryPath?: pulumi.Input<string>;
        /**
         * Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
         */
        repositorySha?: pulumi.Input<string>;
    }
}

export namespace service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }
}
