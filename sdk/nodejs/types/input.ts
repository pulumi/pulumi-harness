// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface EncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface EnvironmentVariableOverride {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * The name of the service
     */
    serviceName?: pulumi.Input<string>;
    /**
     * The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
     */
    type: pulumi.Input<string>;
    /**
     * The value of the service variable
     */
    value: pulumi.Input<string>;
}

export interface GetEncryptedTextUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetEncryptedTextUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetSecretManagerUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSecretManagerUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GetSshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: string;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: string;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: string;
}

export interface GetSshCredentialUsageScopeArgs {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface GitConnectorCommitDetails {
    /**
     * The email id of the author
     */
    authorEmailId?: pulumi.Input<string>;
    /**
     * The name of the author
     */
    authorName?: pulumi.Input<string>;
    /**
     * Commit message
     */
    message?: pulumi.Input<string>;
}

export interface GitConnectorUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsAmi {
    /**
     * The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
     */
    amiDeploymentType: pulumi.Input<string>;
    /**
     * Flag to indicate whether the autoscaling group identifies the workload.
     */
    asgIdentifiesWorkload?: pulumi.Input<boolean>;
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The classic load balancers to use.
     */
    classicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The name of the SpotInst cloud provider to connect with.
     */
    spotinstCloudProviderName?: pulumi.Input<string>;
    /**
     * The SpotInst configuration to use.
     */
    spotinstConfigJson?: pulumi.Input<string>;
    /**
     * The staging classic load balancers to use.
     */
    stageClassicLoadbalancers?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The staging classic load balancers to use.
     */
    stageTargetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ARN's of the target groups.
     */
    targetGroupArns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Flag to enable traffic shifting.
     */
    useTrafficShift?: pulumi.Input<boolean>;
}

export interface InfrastructureDefinitionAwsEcs {
    /**
     * Flag to assign a public IP address.
     */
    assignPublicIp?: pulumi.Input<boolean>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the ECS cluster to use.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The ARN of the role to use for execution.
     */
    executionRole?: pulumi.Input<string>;
    /**
     * The type of launch configuration to use. Valid options are FARGATE
     */
    launchType: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsLambda {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The IAM role to use.
     */
    iamRole?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The security group ids to apply to the ecs service.
     */
    securityGroupIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The subnet ids to apply to the ecs service.
     */
    subnetIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcId?: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsSsh {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName?: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the auto scaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
    /**
     * The tags to use when selecting the instances.
     */
    tags?: pulumi.Input<pulumi.Input<inputs.InfrastructureDefinitionAwsSshTag>[]>;
    /**
     * The VPC ids to use when selecting the instances.
     */
    vpcIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionAwsSshTag {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAwsWinrm {
    /**
     * The name of the autoscaling group.
     */
    autoscalingGroupName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The desired capacity of the autoscaling group.
     */
    desiredCapacity?: pulumi.Input<number>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName: pulumi.Input<string>;
    /**
     * The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
     */
    hostConnectionType: pulumi.Input<string>;
    /**
     * The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
     */
    hostnameConvention?: pulumi.Input<string>;
    /**
     * The name of the load balancer to use.
     */
    loadbalancerName?: pulumi.Input<string>;
    /**
     * The region to deploy to.
     */
    region: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureVmss {
    /**
     * The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
     */
    authType: pulumi.Input<string>;
    /**
     * Base name.
     */
    baseName: pulumi.Input<string>;
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The type of deployment. Valid options are NATIVE_VMSS
     */
    deploymentType: pulumi.Input<string>;
    /**
     * The name of the host connection attributes to use.
     */
    hostConnectionAttrsName?: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroupName: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
    /**
     * The username to connect with.
     */
    username: pulumi.Input<string>;
}

export interface InfrastructureDefinitionAzureWebapp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the resource group.
     */
    resourceGroup: pulumi.Input<string>;
    /**
     * The unique id of the azure subscription.
     */
    subscriptionId: pulumi.Input<string>;
}

export interface InfrastructureDefinitionDatacenterSsh {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the SSH connection attributes to use.
     */
    hostConnectionAttributesName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface InfrastructureDefinitionDatacenterWinrm {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * A list of hosts to deploy to.
     */
    hostnames: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the WinRM connection attributes to use.
     */
    winrmConnectionAttributesName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetes {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionKubernetesGcp {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The name of the cluster being deployed to.
     */
    clusterName: pulumi.Input<string>;
    /**
     * The namespace in Kubernetes to deploy to.
     */
    namespace: pulumi.Input<string>;
    /**
     * The naming convention of the release.
     */
    releaseName: pulumi.Input<string>;
}

export interface InfrastructureDefinitionTanzu {
    /**
     * The name of the cloud provider to connect with.
     */
    cloudProviderName: pulumi.Input<string>;
    /**
     * The PCF organization to use.
     */
    organization: pulumi.Input<string>;
    /**
     * The PCF space to deploy to.
     */
    space: pulumi.Input<string>;
}

export interface SshCredentialKerberosAuthentication {
    /**
     * Port to use for Kerberos authentication
     */
    port: pulumi.Input<number>;
    /**
     * Name of the principal for authentication
     */
    principal: pulumi.Input<string>;
    /**
     * Realm associated with the Kerberos authentication
     */
    realm: pulumi.Input<string>;
    /**
     * TGT generation method
     */
    tgtGenerationMethod?: pulumi.Input<inputs.SshCredentialKerberosAuthenticationTgtGenerationMethod>;
}

export interface SshCredentialKerberosAuthenticationTgtGenerationMethod {
    kerberosPasswordId?: pulumi.Input<string>;
    keyTabFilePath?: pulumi.Input<string>;
}

export interface SshCredentialSshAuthentication {
    /**
     * Inline SSH authentication configuration. Only ond of `passphraseSecretId` or `sshKeyFileId` should be used
     */
    inlineSsh?: pulumi.Input<inputs.SshCredentialSshAuthenticationInlineSsh>;
    /**
     * The port to connect to
     */
    port: pulumi.Input<number>;
    /**
     * Server password authentication configuration
     */
    serverPassword?: pulumi.Input<inputs.SshCredentialSshAuthenticationServerPassword>;
    /**
     * Use ssh key file for authentication
     */
    sshKeyFile?: pulumi.Input<inputs.SshCredentialSshAuthenticationSshKeyFile>;
    /**
     * The username to use when connecting to ssh
     */
    username: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationInlineSsh {
    passphraseSecretId?: pulumi.Input<string>;
    sshKeyFileId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationServerPassword {
    passwordSecretId: pulumi.Input<string>;
}

export interface SshCredentialSshAuthenticationSshKeyFile {
    passphraseSecretId?: pulumi.Input<string>;
    path: pulumi.Input<string>;
}

export interface SshCredentialUsageScope {
    /**
     * Id of the application to scope to. If empty then this scope applies to all applications.
     */
    applicationId?: pulumi.Input<string>;
    /**
     * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
     */
    environmentFilterType?: pulumi.Input<string>;
    /**
     * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
     */
    environmentId?: pulumi.Input<string>;
}

export interface UserGroupLdapSettings {
    /**
     * The group DN of the LDAP user group.
     */
    groupDn?: pulumi.Input<string>;
    /**
     * The group name of the LDAP user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}

export interface UserGroupNotificationSettings {
    /**
     * The email addresses of the user group.
     */
    groupEmailAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Microsoft Teams webhook URL of the user group.
     */
    microsoftTeamsWebhookUrl?: pulumi.Input<string>;
    /**
     * Indicates whether an email is sent when a new user is added to the group.
     */
    sendMailToNewMembers?: pulumi.Input<boolean>;
    /**
     * Enable this setting to have notifications sent to the members of this group.
     */
    sendNotificationsToMembers?: pulumi.Input<boolean>;
    /**
     * The Slack channel to send notifications to.
     */
    slackChannel?: pulumi.Input<string>;
    /**
     * The Slack webhook URL to send notifications to.
     */
    slackWebhookUrl?: pulumi.Input<string>;
}

export interface UserGroupPermissions {
    /**
     * The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
     */
    accountPermissions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Application specific permissions
     */
    appPermissions?: pulumi.Input<inputs.UserGroupPermissionsAppPermissions>;
}

export interface UserGroupPermissionsAppPermissions {
    alls?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsAll>[]>;
    deployments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsDeployment>[]>;
    environments?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsEnvironment>[]>;
    pipelines?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsPipeline>[]>;
    provisioners?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsProvisioner>[]>;
    services?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsService>[]>;
    templates?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsTemplate>[]>;
    workflows?: pulumi.Input<pulumi.Input<inputs.UserGroupPermissionsAppPermissionsWorkflow>[]>;
}

export interface UserGroupPermissionsAppPermissionsAll {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsDeployment {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsEnvironment {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsPipeline {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    envIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsProvisioner {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    provisionerIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsService {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    serviceIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsTemplate {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    templateIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupPermissionsAppPermissionsWorkflow {
    actions: pulumi.Input<pulumi.Input<string>[]>;
    appIds?: pulumi.Input<pulumi.Input<string>[]>;
    filters: pulumi.Input<pulumi.Input<string>[]>;
}

export interface UserGroupSamlSettings {
    /**
     * The group name of the SAML user group.
     */
    groupName?: pulumi.Input<string>;
    /**
     * The ID of the SSO provider.
     */
    ssoProviderId?: pulumi.Input<string>;
}
export namespace Cloudprovider {
    export interface AwsAssumeCrossAccountRole {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * This is an IAM role in the target deployment AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface DatacenterUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface GcpUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }

    export interface KubernetesAuthentication {
        /**
         * Delegate selectors to inherit the GCP credentials from.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Service account configuration for connecting to the Kubernetes cluster
         */
        oidc?: pulumi.Input<inputs.Cloudprovider.KubernetesAuthenticationOidc>;
        /**
         * Username and password for authentication to the cluster
         */
        serviceAccount?: pulumi.Input<inputs.Cloudprovider.KubernetesAuthenticationServiceAccount>;
        /**
         * Username and password for authentication to the cluster
         */
        usernamePassword?: pulumi.Input<inputs.Cloudprovider.KubernetesAuthenticationUsernamePassword>;
    }

    export interface KubernetesAuthenticationOidc {
        clientIdSecretName: pulumi.Input<string>;
        clientSecretSecretName?: pulumi.Input<string>;
        identityProviderUrl: pulumi.Input<string>;
        masterUrl: pulumi.Input<string>;
        passwordSecretName: pulumi.Input<string>;
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        username: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationServiceAccount {
        caCertificateSecretName?: pulumi.Input<string>;
        masterUrl: pulumi.Input<string>;
        serviceAccountTokenSecretName: pulumi.Input<string>;
    }

    export interface KubernetesAuthenticationUsernamePassword {
        masterUrl: pulumi.Input<string>;
        passwordSecretName: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameSecretName?: pulumi.Input<string>;
    }

    export interface KubernetesUsageScope {
        /**
         * Id of the application to scope to. If empty then this scope applies to all applications.
         */
        applicationId?: pulumi.Input<string>;
        /**
         * Type of environment filter applied. Cannot be used with `environmentId`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
         */
        environmentFilterType?: pulumi.Input<string>;
        /**
         * Id of the id of the specific environment to scope to. Cannot be used with `environmentFilterType`.
         */
        environmentId?: pulumi.Input<string>;
    }
}

export namespace Platform {
    export interface GetUsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail?: string;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: string;
        /**
         * Pager duty key
         */
        pagerDutyKey?: string;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: string;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: string;
    }

    export interface GetUsergroupNotificationConfigArgs {
        /**
         * Group email
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: pulumi.Input<string>;
    }

    export interface ResourceGroupIncludedScope {
        /**
         * Account Identifier of the account
         */
        accountId?: pulumi.Input<string>;
        /**
         * Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
         */
        filter: pulumi.Input<string>;
        /**
         * Organization Identifier
         */
        orgId?: pulumi.Input<string>;
        /**
         * Project Identifier
         */
        projectId?: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilter {
        /**
         * Include all resource or not
         */
        includeAllResources?: pulumi.Input<boolean>;
        /**
         * Resources for a resource group
         */
        resources?: pulumi.Input<pulumi.Input<inputs.Platform.ResourceGroupResourceFilterResource>[]>;
    }

    export interface ResourceGroupResourceFilterResource {
        attributeFilters?: pulumi.Input<pulumi.Input<inputs.Platform.ResourceGroupResourceFilterResourceAttributeFilter>[]>;
        identifiers?: pulumi.Input<pulumi.Input<string>[]>;
        resourceType: pulumi.Input<string>;
    }

    export interface ResourceGroupResourceFilterResourceAttributeFilter {
        attributeName?: pulumi.Input<string>;
        attributeValues?: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface SecretSshkeyKerberos {
        /**
         * Username to use for authentication.
         */
        principal: pulumi.Input<string>;
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        realm: pulumi.Input<string>;
        /**
         * Method to generate tgt
         */
        tgtGenerationMethod?: pulumi.Input<string>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtKeyTabFilePathSpec?: pulumi.Input<inputs.Platform.SecretSshkeyKerberosTgtKeyTabFilePathSpec>;
        /**
         * Authenticate to App Dynamics using username and password.
         */
        tgtPasswordSpec?: pulumi.Input<inputs.Platform.SecretSshkeyKerberosTgtPasswordSpec>;
    }

    export interface SecretSshkeyKerberosTgtKeyTabFilePathSpec {
        keyPath?: pulumi.Input<string>;
    }

    export interface SecretSshkeyKerberosTgtPasswordSpec {
        password?: pulumi.Input<string>;
    }

    export interface SecretSshkeySsh {
        /**
         * This specifies SSH credential type as Password, KeyPath or KeyReference
         */
        credentialType: pulumi.Input<string>;
        /**
         * SSH credential of type keyReference
         */
        sshPasswordCredential?: pulumi.Input<inputs.Platform.SecretSshkeySshSshPasswordCredential>;
        /**
         * SSH credential of type keyPath
         */
        sshkeyPathCredential?: pulumi.Input<inputs.Platform.SecretSshkeySshSshkeyPathCredential>;
        /**
         * SSH credential of type keyReference
         */
        sshkeyReferenceCredential?: pulumi.Input<inputs.Platform.SecretSshkeySshSshkeyReferenceCredential>;
    }

    export interface SecretSshkeySshSshPasswordCredential {
        password: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyPathCredential {
        encryptedPassphrase?: pulumi.Input<string>;
        keyPath: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface SecretSshkeySshSshkeyReferenceCredential {
        encryptedPassphrase?: pulumi.Input<string>;
        key?: pulumi.Input<string>;
        userName: pulumi.Input<string>;
    }

    export interface UsergroupNotificationConfig {
        /**
         * Group email
         */
        groupEmail?: pulumi.Input<string>;
        /**
         * Url of Microsoft teams webhook
         */
        microsoftTeamsWebhookUrl?: pulumi.Input<string>;
        /**
         * Pager duty key
         */
        pagerDutyKey?: pulumi.Input<string>;
        /**
         * Url of slack webhook
         */
        slackWebhookUrl?: pulumi.Input<string>;
        /**
         * Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS
         */
        type?: pulumi.Input<string>;
    }
}

export namespace PlatformConnector {
    export interface AppDynamicsApiToken {
        /**
         * The client id used for connecting to App Dynamics.
         */
        clientId: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the App Dynamics client secret.
         */
        clientSecretRef: pulumi.Input<string>;
    }

    export interface AppDynamicsUsernamePassword {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username: pulumi.Input<string>;
    }

    export interface ArtifactoryCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface AwsCCCrossAccountAccess {
        /**
         * The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
         */
        externalId: pulumi.Input<string>;
        /**
         * The ARN of the role to use for cross-account access.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsCrossAccountAccess {
        /**
         * If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
         */
        externalId?: pulumi.Input<string>;
        /**
         * The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
         */
        roleArn: pulumi.Input<string>;
    }

    export interface AwsInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsIrsa {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface AwsKmsCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.PlatformConnector.AwsKmsCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.PlatformConnector.AwsKmsCredentialsManual>;
    }

    export interface AwsKmsCredentialsAssumeRole {
        duration: pulumi.Input<number>;
        externalId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AwsKmsCredentialsManual {
        accessKeyRef: pulumi.Input<string>;
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsManual {
        /**
         * AWS access key.
         */
        accessKey?: pulumi.Input<string>;
        /**
         * Reference to the Harness secret containing the aws access key.
         */
        accessKeyRef?: pulumi.Input<string>;
        /**
         * Connect only use delegates with these tags.
         */
        delegateSelectors?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the aws secret key.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface AwsSecretManagerCredentials {
        /**
         * Connect using STS assume role.
         */
        assumeRole?: pulumi.Input<inputs.PlatformConnector.AwsSecretManagerCredentialsAssumeRole>;
        /**
         * Inherit the credentials from from the delegate.
         */
        inheritFromDelegate?: pulumi.Input<boolean>;
        /**
         * Specify the AWS key and secret used for authenticating.
         */
        manual?: pulumi.Input<inputs.PlatformConnector.AwsSecretManagerCredentialsManual>;
    }

    export interface AwsSecretManagerCredentialsAssumeRole {
        duration: pulumi.Input<number>;
        externalId?: pulumi.Input<string>;
        roleArn: pulumi.Input<string>;
    }

    export interface AwsSecretManagerCredentialsManual {
        accessKeyRef: pulumi.Input<string>;
        secretKeyRef: pulumi.Input<string>;
    }

    export interface BitbucketApiAuthentication {
        /**
         * Personal access token for interacting with the BitBucket api.
         */
        tokenRef: pulumi.Input<string>;
        /**
         * The username used for connecting to the api.
         */
        username?: pulumi.Input<string>;
        /**
         * The name of the Harness secret containing the username.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.PlatformConnector.BitbucketCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.PlatformConnector.BitbucketCredentialsSsh>;
    }

    export interface BitbucketCredentialsHttp {
        passwordRef?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface BitbucketCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface DockerCredentials {
        /**
         * The reference to the password to use for the docker registry.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * The username to use for the docker registry.
         */
        username?: pulumi.Input<string>;
        /**
         * The reference to the username to use for the docker registry.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface GcpInheritFromDelegate {
        /**
         * The delegates to inherit the credentials from.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface GcpManual {
        /**
         * The delegates to connect with.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the Harness secret containing the secret key.
         */
        secretKeyRef: pulumi.Input<string>;
    }

    export interface GitCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.PlatformConnector.GitCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.PlatformConnector.GitCredentialsSsh>;
    }

    export interface GitCredentialsHttp {
        passwordRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GithubApiAuthentication {
        /**
         * Configuration for using the github app for interacting with the github api.
         */
        githubApp?: pulumi.Input<inputs.PlatformConnector.GithubApiAuthenticationGithubApp>;
        /**
         * Personal access token for interacting with the github api.
         */
        tokenRef?: pulumi.Input<string>;
    }

    export interface GithubApiAuthenticationGithubApp {
        applicationId: pulumi.Input<string>;
        installationId: pulumi.Input<string>;
        privateKeyRef: pulumi.Input<string>;
    }

    export interface GithubCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.PlatformConnector.GithubCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.PlatformConnector.GithubCredentialsSsh>;
    }

    export interface GithubCredentialsHttp {
        tokenRef: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GithubCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface GitlabApiAuthentication {
        /**
         * Personal access token for interacting with the gitlab api.
         */
        tokenRef: pulumi.Input<string>;
    }

    export interface GitlabCredentials {
        /**
         * Authenticate using Username and password over http(s) for the connection.
         */
        http?: pulumi.Input<inputs.PlatformConnector.GitlabCredentialsHttp>;
        /**
         * Authenticate using SSH for the connection.
         */
        ssh?: pulumi.Input<inputs.PlatformConnector.GitlabCredentialsSsh>;
    }

    export interface GitlabCredentialsHttp {
        passwordRef?: pulumi.Input<string>;
        tokenRef?: pulumi.Input<string>;
        username?: pulumi.Input<string>;
        usernameRef?: pulumi.Input<string>;
    }

    export interface GitlabCredentialsSsh {
        sshKeyRef: pulumi.Input<string>;
    }

    export interface HelmCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesClientKeyCert {
        /**
         * Reference to the secret containing the CA certificate for the connector.
         */
        caCertRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client certificate for the connector.
         */
        clientCertRef: pulumi.Input<string>;
        /**
         * The algorithm used to generate the client key for the connector. Valid values are RSA, EC
         */
        clientKeyAlgorithm: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key passphrase for the connector.
         */
        clientKeyPassphraseRef?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the client key for the connector.
         */
        clientKeyRef: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
    }

    export interface KubernetesInheritFromDelegate {
        /**
         * Selectors to use for the delegate.
         */
        delegateSelectors: pulumi.Input<pulumi.Input<string>[]>;
    }

    export interface KubernetesOpenidConnect {
        /**
         * Reference to the secret containing the client ID for the connector.
         */
        clientIdRef: pulumi.Input<string>;
        /**
         * The URL of the OpenID Connect issuer.
         */
        issuerUrl: pulumi.Input<string>;
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Scopes to request for the connector.
         */
        scopes?: pulumi.Input<pulumi.Input<string>[]>;
        /**
         * Reference to the secret containing the client secret for the connector.
         */
        secretRef?: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface KubernetesServiceAccount {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the service account token for the connector.
         */
        serviceAccountTokenRef: pulumi.Input<string>;
    }

    export interface KubernetesUsernamePassword {
        /**
         * The URL of the Kubernetes cluster.
         */
        masterUrl: pulumi.Input<string>;
        /**
         * Reference to the secret containing the password for the connector.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username for the connector.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to the secret containing the username for the connector.
         */
        usernameRef?: pulumi.Input<string>;
    }

    export interface NexusCredentials {
        /**
         * Reference to a secret containing the password to use for authentication.
         */
        passwordRef: pulumi.Input<string>;
        /**
         * Username to use for authentication.
         */
        username?: pulumi.Input<string>;
        /**
         * Reference to a secret containing the username to use for authentication.
         */
        usernameRef?: pulumi.Input<string>;
    }
}

export namespace Service {
    export interface AmiVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface CodedeployVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface EcsVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface HelmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface KubernetesVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface LambdaVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface SshVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface TanzuVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }

    export interface WinrmVariable {
        /**
         * Name of the variable
         */
        name: pulumi.Input<string>;
        /**
         * Type of the variable. Options are 'TEXT' and 'ENCRYPTED_TEXT'
         */
        type: pulumi.Input<string>;
        /**
         * Value of the variable
         */
        value: pulumi.Input<string>;
    }
}
