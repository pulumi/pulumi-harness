// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";
import * as utilities from "../utilities";

/**
 * Data source for retrieving a Harness repo branch rule.
 */
export function getRepoRuleBranch(args: GetRepoRuleBranchArgs, opts?: pulumi.InvokeOptions): Promise<GetRepoRuleBranchResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invoke("harness:platform/getRepoRuleBranch:getRepoRuleBranch", {
        "bypasses": args.bypasses,
        "description": args.description,
        "identifier": args.identifier,
        "orgId": args.orgId,
        "patterns": args.patterns,
        "policies": args.policies,
        "projectId": args.projectId,
        "repoIdentifier": args.repoIdentifier,
        "state": args.state,
    }, opts);
}

/**
 * A collection of arguments for invoking getRepoRuleBranch.
 */
export interface GetRepoRuleBranchArgs {
    /**
     * List of users who can bypass this rule.
     */
    bypasses: inputs.platform.GetRepoRuleBranchBypass[];
    /**
     * Description of the rule.
     */
    description?: string;
    /**
     * Identifier of the rule.
     */
    identifier: string;
    /**
     * Unique identifier of the organization.
     */
    orgId?: string;
    /**
     * Pattern of branch to which rule will apply.
     */
    patterns?: inputs.platform.GetRepoRuleBranchPattern[];
    /**
     * Policies to be applied for this rule.
     */
    policies: inputs.platform.GetRepoRuleBranchPolicy[];
    /**
     * Unique identifier of the project.
     */
    projectId?: string;
    /**
     * Repo identifier of the repository.
     */
    repoIdentifier: string;
    /**
     * State of the rule (active, disable, monitor).
     */
    state: string;
}

/**
 * A collection of values returned by getRepoRuleBranch.
 */
export interface GetRepoRuleBranchResult {
    /**
     * List of users who can bypass this rule.
     */
    readonly bypasses: outputs.platform.GetRepoRuleBranchBypass[];
    /**
     * Timestamp when the rule was created.
     */
    readonly created: number;
    /**
     * ID of the user who created the rule.
     */
    readonly createdBy: number;
    /**
     * Description of the rule.
     */
    readonly description?: string;
    /**
     * The provider-assigned unique ID for this managed resource.
     */
    readonly id: string;
    /**
     * Identifier of the rule.
     */
    readonly identifier: string;
    /**
     * Unique identifier of the organization.
     */
    readonly orgId?: string;
    /**
     * Pattern of branch to which rule will apply.
     */
    readonly patterns?: outputs.platform.GetRepoRuleBranchPattern[];
    /**
     * Policies to be applied for this rule.
     */
    readonly policies: outputs.platform.GetRepoRuleBranchPolicy[];
    /**
     * Unique identifier of the project.
     */
    readonly projectId?: string;
    /**
     * Repo identifier of the repository.
     */
    readonly repoIdentifier: string;
    /**
     * State of the rule (active, disable, monitor).
     */
    readonly state: string;
    /**
     * Timestamp when the rule was updated.
     */
    readonly updated: number;
    /**
     * ID of the user who updated the rule.
     */
    readonly updatedBy: number;
}
/**
 * Data source for retrieving a Harness repo branch rule.
 */
export function getRepoRuleBranchOutput(args: GetRepoRuleBranchOutputArgs, opts?: pulumi.InvokeOutputOptions): pulumi.Output<GetRepoRuleBranchResult> {
    opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts || {});
    return pulumi.runtime.invokeOutput("harness:platform/getRepoRuleBranch:getRepoRuleBranch", {
        "bypasses": args.bypasses,
        "description": args.description,
        "identifier": args.identifier,
        "orgId": args.orgId,
        "patterns": args.patterns,
        "policies": args.policies,
        "projectId": args.projectId,
        "repoIdentifier": args.repoIdentifier,
        "state": args.state,
    }, opts);
}

/**
 * A collection of arguments for invoking getRepoRuleBranch.
 */
export interface GetRepoRuleBranchOutputArgs {
    /**
     * List of users who can bypass this rule.
     */
    bypasses: pulumi.Input<pulumi.Input<inputs.platform.GetRepoRuleBranchBypassArgs>[]>;
    /**
     * Description of the rule.
     */
    description?: pulumi.Input<string>;
    /**
     * Identifier of the rule.
     */
    identifier: pulumi.Input<string>;
    /**
     * Unique identifier of the organization.
     */
    orgId?: pulumi.Input<string>;
    /**
     * Pattern of branch to which rule will apply.
     */
    patterns?: pulumi.Input<pulumi.Input<inputs.platform.GetRepoRuleBranchPatternArgs>[]>;
    /**
     * Policies to be applied for this rule.
     */
    policies: pulumi.Input<pulumi.Input<inputs.platform.GetRepoRuleBranchPolicyArgs>[]>;
    /**
     * Unique identifier of the project.
     */
    projectId?: pulumi.Input<string>;
    /**
     * Repo identifier of the repository.
     */
    repoIdentifier: pulumi.Input<string>;
    /**
     * State of the rule (active, disable, monitor).
     */
    state: pulumi.Input<string>;
}
