# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'OrchestratorConfigBinpacking',
    'OrchestratorConfigBinpackingDisruption',
    'OrchestratorConfigBinpackingDisruptionBudget',
    'OrchestratorConfigBinpackingDisruptionBudgetSchedule',
    'OrchestratorConfigBinpackingPodEviction',
    'OrchestratorConfigBinpackingPodEvictionThreshold',
    'OrchestratorConfigCommitmentIntegration',
    'OrchestratorConfigDistribution',
    'OrchestratorConfigNodePreferences',
    'OrchestratorConfigReplacementSchedule',
    'OrchestratorConfigReplacementScheduleAppliesTo',
    'OrchestratorConfigReplacementScheduleWindowDetails',
    'GetOrchestratorConfigBinpackingResult',
    'GetOrchestratorConfigBinpackingDisruptionResult',
    'GetOrchestratorConfigBinpackingDisruptionBudgetResult',
    'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleResult',
    'GetOrchestratorConfigBinpackingPodEvictionResult',
    'GetOrchestratorConfigBinpackingPodEvictionThresholdResult',
    'GetOrchestratorConfigCommitmentIntegrationResult',
    'GetOrchestratorConfigDistributionResult',
    'GetOrchestratorConfigNodePreferencesResult',
    'GetOrchestratorConfigReplacementScheduleResult',
    'GetOrchestratorConfigReplacementScheduleAppliesToResult',
    'GetOrchestratorConfigReplacementScheduleWindowDetailsResult',
]

@pulumi.output_type
class OrchestratorConfigBinpacking(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podEviction":
            suggest = "pod_eviction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigBinpacking. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigBinpacking.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigBinpacking.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disruption: Optional['outputs.OrchestratorConfigBinpackingDisruption'] = None,
                 pod_eviction: Optional['outputs.OrchestratorConfigBinpackingPodEviction'] = None):
        """
        :param 'OrchestratorConfigBinpackingDisruptionArgs' disruption: Harness disruption configuration
        :param 'OrchestratorConfigBinpackingPodEvictionArgs' pod_eviction: Harness Pod Evictor Configuration
        """
        if disruption is not None:
            pulumi.set(__self__, "disruption", disruption)
        if pod_eviction is not None:
            pulumi.set(__self__, "pod_eviction", pod_eviction)

    @_builtins.property
    @pulumi.getter
    def disruption(self) -> Optional['outputs.OrchestratorConfigBinpackingDisruption']:
        """
        Harness disruption configuration
        """
        return pulumi.get(self, "disruption")

    @_builtins.property
    @pulumi.getter(name="podEviction")
    def pod_eviction(self) -> Optional['outputs.OrchestratorConfigBinpackingPodEviction']:
        """
        Harness Pod Evictor Configuration
        """
        return pulumi.get(self, "pod_eviction")


@pulumi.output_type
class OrchestratorConfigBinpackingDisruption(dict):
    def __init__(__self__, *,
                 budgets: Optional[Sequence['outputs.OrchestratorConfigBinpackingDisruptionBudget']] = None,
                 criteria: Optional[_builtins.str] = None,
                 delay: Optional[_builtins.str] = None):
        """
        :param Sequence['OrchestratorConfigBinpackingDisruptionBudgetArgs'] budgets: Budgets for disruption
        :param _builtins.str criteria: Criteria for considering a nodes for disruption
        :param _builtins.str delay: Deletion delay
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def budgets(self) -> Optional[Sequence['outputs.OrchestratorConfigBinpackingDisruptionBudget']]:
        """
        Budgets for disruption
        """
        return pulumi.get(self, "budgets")

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[_builtins.str]:
        """
        Criteria for considering a nodes for disruption
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Deletion delay
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class OrchestratorConfigBinpackingDisruptionBudget(dict):
    def __init__(__self__, *,
                 nodes: _builtins.str,
                 reasons: Optional[Sequence[_builtins.str]] = None,
                 schedule: Optional['outputs.OrchestratorConfigBinpackingDisruptionBudgetSchedule'] = None):
        """
        :param _builtins.str nodes: Number or percentage of Nodes to consider for disruption
        :param Sequence[_builtins.str] reasons: Reasons for disruption
        :param 'OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs' schedule: Schedule for disruption budget
        """
        pulumi.set(__self__, "nodes", nodes)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> _builtins.str:
        """
        Number or percentage of Nodes to consider for disruption
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        Reasons for disruption
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.OrchestratorConfigBinpackingDisruptionBudgetSchedule']:
        """
        Schedule for disruption budget
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class OrchestratorConfigBinpackingDisruptionBudgetSchedule(dict):
    def __init__(__self__, *,
                 duration: _builtins.str,
                 frequency: _builtins.str):
        """
        :param _builtins.str duration: Duration for disruption budget
        :param _builtins.str frequency: Frequency for disruption budget
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        Duration for disruption budget
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Frequency for disruption budget
        """
        return pulumi.get(self, "frequency")


@pulumi.output_type
class OrchestratorConfigBinpackingPodEviction(dict):
    def __init__(__self__, *,
                 threshold: 'outputs.OrchestratorConfigBinpackingPodEvictionThreshold'):
        """
        :param 'OrchestratorConfigBinpackingPodEvictionThresholdArgs' threshold: Minimum Threshold for considering a node as underutilized
        """
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> 'outputs.OrchestratorConfigBinpackingPodEvictionThreshold':
        """
        Minimum Threshold for considering a node as underutilized
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class OrchestratorConfigBinpackingPodEvictionThreshold(dict):
    def __init__(__self__, *,
                 cpu: _builtins.float,
                 memory: _builtins.float):
        """
        :param _builtins.float cpu: CPU percentage for considering a node as underutilized
        :param _builtins.float memory: Memory percentage for considering a node as underutilized
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.float:
        """
        CPU percentage for considering a node as underutilized
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Memory percentage for considering a node as underutilized
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class OrchestratorConfigCommitmentIntegration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterAccountId":
            suggest = "master_account_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigCommitmentIntegration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigCommitmentIntegration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigCommitmentIntegration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 master_account_id: _builtins.str):
        """
        :param _builtins.bool enabled: Flag to enable Commitment Integration
        :param _builtins.str master_account_id: Master AWS account id for commitment integration
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "master_account_id", master_account_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag to enable Commitment Integration
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="masterAccountId")
    def master_account_id(self) -> _builtins.str:
        """
        Master AWS account id for commitment integration
        """
        return pulumi.get(self, "master_account_id")


@pulumi.output_type
class OrchestratorConfigDistribution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ondemandReplicaPercentage":
            suggest = "ondemand_replica_percentage"
        elif key == "baseOndemandCapacity":
            suggest = "base_ondemand_capacity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigDistribution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigDistribution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigDistribution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ondemand_replica_percentage: _builtins.float,
                 base_ondemand_capacity: Optional[_builtins.int] = None,
                 selector: Optional[_builtins.str] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.float ondemand_replica_percentage: Percentage of on-demand replicas required for workloads
        :param _builtins.int base_ondemand_capacity: Number of minimum ondemand replicas required for workloads
        :param _builtins.str selector: Selector for choosing workloads for distribution
        :param _builtins.str strategy: Strategy for choosing spot nodes for cluster
        """
        pulumi.set(__self__, "ondemand_replica_percentage", ondemand_replica_percentage)
        if base_ondemand_capacity is not None:
            pulumi.set(__self__, "base_ondemand_capacity", base_ondemand_capacity)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="ondemandReplicaPercentage")
    def ondemand_replica_percentage(self) -> _builtins.float:
        """
        Percentage of on-demand replicas required for workloads
        """
        return pulumi.get(self, "ondemand_replica_percentage")

    @_builtins.property
    @pulumi.getter(name="baseOndemandCapacity")
    def base_ondemand_capacity(self) -> Optional[_builtins.int]:
        """
        Number of minimum ondemand replicas required for workloads
        """
        return pulumi.get(self, "base_ondemand_capacity")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[_builtins.str]:
        """
        Selector for choosing workloads for distribution
        """
        return pulumi.get(self, "selector")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy for choosing spot nodes for cluster
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class OrchestratorConfigNodePreferences(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "reverseFallbackInterval":
            suggest = "reverse_fallback_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigNodePreferences. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigNodePreferences.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigNodePreferences.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reverse_fallback_interval: Optional[_builtins.str] = None,
                 ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str reverse_fallback_interval: Reverse fallback interval
        :param _builtins.str ttl: TTL for nodes
        """
        if reverse_fallback_interval is not None:
            pulumi.set(__self__, "reverse_fallback_interval", reverse_fallback_interval)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="reverseFallbackInterval")
    def reverse_fallback_interval(self) -> Optional[_builtins.str]:
        """
        Reverse fallback interval
        """
        return pulumi.get(self, "reverse_fallback_interval")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        TTL for nodes
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class OrchestratorConfigReplacementSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appliesTo":
            suggest = "applies_to"
        elif key == "windowType":
            suggest = "window_type"
        elif key == "windowDetails":
            suggest = "window_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigReplacementSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigReplacementSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigReplacementSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applies_to: 'outputs.OrchestratorConfigReplacementScheduleAppliesTo',
                 window_type: _builtins.str,
                 window_details: Optional['outputs.OrchestratorConfigReplacementScheduleWindowDetails'] = None):
        """
        :param 'OrchestratorConfigReplacementScheduleAppliesToArgs' applies_to: Defines the scope of the replacement schedule
        :param _builtins.str window_type: Window type for replacement schedule
        """
        pulumi.set(__self__, "applies_to", applies_to)
        pulumi.set(__self__, "window_type", window_type)
        if window_details is not None:
            pulumi.set(__self__, "window_details", window_details)

    @_builtins.property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> 'outputs.OrchestratorConfigReplacementScheduleAppliesTo':
        """
        Defines the scope of the replacement schedule
        """
        return pulumi.get(self, "applies_to")

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> _builtins.str:
        """
        Window type for replacement schedule
        """
        return pulumi.get(self, "window_type")

    @_builtins.property
    @pulumi.getter(name="windowDetails")
    def window_details(self) -> Optional['outputs.OrchestratorConfigReplacementScheduleWindowDetails']:
        return pulumi.get(self, "window_details")


@pulumi.output_type
class OrchestratorConfigReplacementScheduleAppliesTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "harnessPodEviction":
            suggest = "harness_pod_eviction"
        elif key == "reverseFallback":
            suggest = "reverse_fallback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigReplacementScheduleAppliesTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigReplacementScheduleAppliesTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigReplacementScheduleAppliesTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consolidation: _builtins.bool,
                 harness_pod_eviction: _builtins.bool,
                 reverse_fallback: _builtins.bool):
        pulumi.set(__self__, "consolidation", consolidation)
        pulumi.set(__self__, "harness_pod_eviction", harness_pod_eviction)
        pulumi.set(__self__, "reverse_fallback", reverse_fallback)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> _builtins.bool:
        return pulumi.get(self, "consolidation")

    @_builtins.property
    @pulumi.getter(name="harnessPodEviction")
    def harness_pod_eviction(self) -> _builtins.bool:
        return pulumi.get(self, "harness_pod_eviction")

    @_builtins.property
    @pulumi.getter(name="reverseFallback")
    def reverse_fallback(self) -> _builtins.bool:
        return pulumi.get(self, "reverse_fallback")


@pulumi.output_type
class OrchestratorConfigReplacementScheduleWindowDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"
        elif key == "allDay":
            suggest = "all_day"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrchestratorConfigReplacementScheduleWindowDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrchestratorConfigReplacementScheduleWindowDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrchestratorConfigReplacementScheduleWindowDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days: Sequence[_builtins.str],
                 time_zone: _builtins.str,
                 all_day: Optional[_builtins.bool] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] days: List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        :param _builtins.str time_zone: Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        :param _builtins.str end_time: End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        :param _builtins.str start_time: Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "time_zone", time_zone)
        if all_day is not None:
            pulumi.set(__self__, "all_day", all_day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Sequence[_builtins.str]:
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="allDay")
    def all_day(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all_day")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetOrchestratorConfigBinpackingResult(dict):
    def __init__(__self__, *,
                 disruption: Optional['outputs.GetOrchestratorConfigBinpackingDisruptionResult'] = None,
                 pod_eviction: Optional['outputs.GetOrchestratorConfigBinpackingPodEvictionResult'] = None):
        """
        :param 'GetOrchestratorConfigBinpackingDisruptionArgs' disruption: Harness disruption configuration
        :param 'GetOrchestratorConfigBinpackingPodEvictionArgs' pod_eviction: Harness Pod Evictor Configuration
        """
        if disruption is not None:
            pulumi.set(__self__, "disruption", disruption)
        if pod_eviction is not None:
            pulumi.set(__self__, "pod_eviction", pod_eviction)

    @_builtins.property
    @pulumi.getter
    def disruption(self) -> Optional['outputs.GetOrchestratorConfigBinpackingDisruptionResult']:
        """
        Harness disruption configuration
        """
        return pulumi.get(self, "disruption")

    @_builtins.property
    @pulumi.getter(name="podEviction")
    def pod_eviction(self) -> Optional['outputs.GetOrchestratorConfigBinpackingPodEvictionResult']:
        """
        Harness Pod Evictor Configuration
        """
        return pulumi.get(self, "pod_eviction")


@pulumi.output_type
class GetOrchestratorConfigBinpackingDisruptionResult(dict):
    def __init__(__self__, *,
                 budgets: Optional[Sequence['outputs.GetOrchestratorConfigBinpackingDisruptionBudgetResult']] = None,
                 criteria: Optional[_builtins.str] = None,
                 delay: Optional[_builtins.str] = None):
        """
        :param Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs'] budgets: Budgets for disruption
        :param _builtins.str criteria: Criteria for considering a nodes for disruption
        :param _builtins.str delay: Deletion delay
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def budgets(self) -> Optional[Sequence['outputs.GetOrchestratorConfigBinpackingDisruptionBudgetResult']]:
        """
        Budgets for disruption
        """
        return pulumi.get(self, "budgets")

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[_builtins.str]:
        """
        Criteria for considering a nodes for disruption
        """
        return pulumi.get(self, "criteria")

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Deletion delay
        """
        return pulumi.get(self, "delay")


@pulumi.output_type
class GetOrchestratorConfigBinpackingDisruptionBudgetResult(dict):
    def __init__(__self__, *,
                 nodes: _builtins.str,
                 reasons: Optional[Sequence[_builtins.str]] = None,
                 schedule: Optional['outputs.GetOrchestratorConfigBinpackingDisruptionBudgetScheduleResult'] = None):
        """
        :param _builtins.str nodes: Number or percentage of Nodes to consider for disruption
        :param Sequence[_builtins.str] reasons: Reasons for disruption
        :param 'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs' schedule: Schedule for disruption budget
        """
        pulumi.set(__self__, "nodes", nodes)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> _builtins.str:
        """
        Number or percentage of Nodes to consider for disruption
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        Reasons for disruption
        """
        return pulumi.get(self, "reasons")

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['outputs.GetOrchestratorConfigBinpackingDisruptionBudgetScheduleResult']:
        """
        Schedule for disruption budget
        """
        return pulumi.get(self, "schedule")


@pulumi.output_type
class GetOrchestratorConfigBinpackingDisruptionBudgetScheduleResult(dict):
    def __init__(__self__, *,
                 duration: _builtins.str,
                 frequency: _builtins.str):
        """
        :param _builtins.str duration: Duration for disruption budget
        :param _builtins.str frequency: Frequency for disruption budget
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        Duration for disruption budget
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Frequency for disruption budget
        """
        return pulumi.get(self, "frequency")


@pulumi.output_type
class GetOrchestratorConfigBinpackingPodEvictionResult(dict):
    def __init__(__self__, *,
                 threshold: 'outputs.GetOrchestratorConfigBinpackingPodEvictionThresholdResult'):
        """
        :param 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs' threshold: Minimum Threshold for considering a node as underutilized
        """
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> 'outputs.GetOrchestratorConfigBinpackingPodEvictionThresholdResult':
        """
        Minimum Threshold for considering a node as underutilized
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class GetOrchestratorConfigBinpackingPodEvictionThresholdResult(dict):
    def __init__(__self__, *,
                 cpu: _builtins.float,
                 memory: _builtins.float):
        """
        :param _builtins.float cpu: CPU percentage for considering a node as underutilized
        :param _builtins.float memory: Memory percentage for considering a node as underutilized
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.float:
        """
        CPU percentage for considering a node as underutilized
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Memory percentage for considering a node as underutilized
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetOrchestratorConfigCommitmentIntegrationResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 master_account_id: _builtins.str):
        """
        :param _builtins.bool enabled: Flag to enable Commitment Integration
        :param _builtins.str master_account_id: Master AWS account id for commitment integration
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "master_account_id", master_account_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag to enable Commitment Integration
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="masterAccountId")
    def master_account_id(self) -> _builtins.str:
        """
        Master AWS account id for commitment integration
        """
        return pulumi.get(self, "master_account_id")


@pulumi.output_type
class GetOrchestratorConfigDistributionResult(dict):
    def __init__(__self__, *,
                 ondemand_replica_percentage: _builtins.float,
                 base_ondemand_capacity: Optional[_builtins.int] = None,
                 selector: Optional[_builtins.str] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.float ondemand_replica_percentage: Percentage of on-demand replicas required for workloads
        :param _builtins.int base_ondemand_capacity: Number of minimum ondemand replicas required for workloads
        :param _builtins.str selector: Selector for choosing workloads for distribution
        :param _builtins.str strategy: Strategy for choosing spot nodes for cluster
        """
        pulumi.set(__self__, "ondemand_replica_percentage", ondemand_replica_percentage)
        if base_ondemand_capacity is not None:
            pulumi.set(__self__, "base_ondemand_capacity", base_ondemand_capacity)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="ondemandReplicaPercentage")
    def ondemand_replica_percentage(self) -> _builtins.float:
        """
        Percentage of on-demand replicas required for workloads
        """
        return pulumi.get(self, "ondemand_replica_percentage")

    @_builtins.property
    @pulumi.getter(name="baseOndemandCapacity")
    def base_ondemand_capacity(self) -> Optional[_builtins.int]:
        """
        Number of minimum ondemand replicas required for workloads
        """
        return pulumi.get(self, "base_ondemand_capacity")

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[_builtins.str]:
        """
        Selector for choosing workloads for distribution
        """
        return pulumi.get(self, "selector")

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy for choosing spot nodes for cluster
        """
        return pulumi.get(self, "strategy")


@pulumi.output_type
class GetOrchestratorConfigNodePreferencesResult(dict):
    def __init__(__self__, *,
                 reverse_fallback_interval: Optional[_builtins.str] = None,
                 ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str reverse_fallback_interval: Reverse fallback interval
        :param _builtins.str ttl: TTL for nodes
        """
        if reverse_fallback_interval is not None:
            pulumi.set(__self__, "reverse_fallback_interval", reverse_fallback_interval)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="reverseFallbackInterval")
    def reverse_fallback_interval(self) -> Optional[_builtins.str]:
        """
        Reverse fallback interval
        """
        return pulumi.get(self, "reverse_fallback_interval")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        TTL for nodes
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class GetOrchestratorConfigReplacementScheduleResult(dict):
    def __init__(__self__, *,
                 applies_to: 'outputs.GetOrchestratorConfigReplacementScheduleAppliesToResult',
                 window_type: _builtins.str,
                 window_details: Optional['outputs.GetOrchestratorConfigReplacementScheduleWindowDetailsResult'] = None):
        """
        :param 'GetOrchestratorConfigReplacementScheduleAppliesToArgs' applies_to: Defines the scope of the replacement schedule
        :param _builtins.str window_type: Window type for replacement schedule
        """
        pulumi.set(__self__, "applies_to", applies_to)
        pulumi.set(__self__, "window_type", window_type)
        if window_details is not None:
            pulumi.set(__self__, "window_details", window_details)

    @_builtins.property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> 'outputs.GetOrchestratorConfigReplacementScheduleAppliesToResult':
        """
        Defines the scope of the replacement schedule
        """
        return pulumi.get(self, "applies_to")

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> _builtins.str:
        """
        Window type for replacement schedule
        """
        return pulumi.get(self, "window_type")

    @_builtins.property
    @pulumi.getter(name="windowDetails")
    def window_details(self) -> Optional['outputs.GetOrchestratorConfigReplacementScheduleWindowDetailsResult']:
        return pulumi.get(self, "window_details")


@pulumi.output_type
class GetOrchestratorConfigReplacementScheduleAppliesToResult(dict):
    def __init__(__self__, *,
                 consolidation: _builtins.bool,
                 harness_pod_eviction: _builtins.bool,
                 reverse_fallback: _builtins.bool):
        pulumi.set(__self__, "consolidation", consolidation)
        pulumi.set(__self__, "harness_pod_eviction", harness_pod_eviction)
        pulumi.set(__self__, "reverse_fallback", reverse_fallback)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> _builtins.bool:
        return pulumi.get(self, "consolidation")

    @_builtins.property
    @pulumi.getter(name="harnessPodEviction")
    def harness_pod_eviction(self) -> _builtins.bool:
        return pulumi.get(self, "harness_pod_eviction")

    @_builtins.property
    @pulumi.getter(name="reverseFallback")
    def reverse_fallback(self) -> _builtins.bool:
        return pulumi.get(self, "reverse_fallback")


@pulumi.output_type
class GetOrchestratorConfigReplacementScheduleWindowDetailsResult(dict):
    def __init__(__self__, *,
                 days: Sequence[_builtins.str],
                 time_zone: _builtins.str,
                 all_day: Optional[_builtins.bool] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] days: List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        :param _builtins.str time_zone: Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        :param _builtins.str end_time: End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        :param _builtins.str start_time: Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "time_zone", time_zone)
        if all_day is not None:
            pulumi.set(__self__, "all_day", all_day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Sequence[_builtins.str]:
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter(name="allDay")
    def all_day(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all_day")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "start_time")


