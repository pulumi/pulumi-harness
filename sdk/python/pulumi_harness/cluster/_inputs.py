# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'OrchestratorConfigBinpackingArgs',
    'OrchestratorConfigBinpackingArgsDict',
    'OrchestratorConfigBinpackingDisruptionArgs',
    'OrchestratorConfigBinpackingDisruptionArgsDict',
    'OrchestratorConfigBinpackingDisruptionBudgetArgs',
    'OrchestratorConfigBinpackingDisruptionBudgetArgsDict',
    'OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs',
    'OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict',
    'OrchestratorConfigBinpackingPodEvictionArgs',
    'OrchestratorConfigBinpackingPodEvictionArgsDict',
    'OrchestratorConfigBinpackingPodEvictionThresholdArgs',
    'OrchestratorConfigBinpackingPodEvictionThresholdArgsDict',
    'OrchestratorConfigCommitmentIntegrationArgs',
    'OrchestratorConfigCommitmentIntegrationArgsDict',
    'OrchestratorConfigDistributionArgs',
    'OrchestratorConfigDistributionArgsDict',
    'OrchestratorConfigNodePreferencesArgs',
    'OrchestratorConfigNodePreferencesArgsDict',
    'OrchestratorConfigReplacementScheduleArgs',
    'OrchestratorConfigReplacementScheduleArgsDict',
    'OrchestratorConfigReplacementScheduleAppliesToArgs',
    'OrchestratorConfigReplacementScheduleAppliesToArgsDict',
    'OrchestratorConfigReplacementScheduleWindowDetailsArgs',
    'OrchestratorConfigReplacementScheduleWindowDetailsArgsDict',
    'GetOrchestratorConfigBinpackingArgs',
    'GetOrchestratorConfigBinpackingArgsDict',
    'GetOrchestratorConfigBinpackingDisruptionArgs',
    'GetOrchestratorConfigBinpackingDisruptionArgsDict',
    'GetOrchestratorConfigBinpackingDisruptionBudgetArgs',
    'GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict',
    'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs',
    'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict',
    'GetOrchestratorConfigBinpackingPodEvictionArgs',
    'GetOrchestratorConfigBinpackingPodEvictionArgsDict',
    'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs',
    'GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict',
    'GetOrchestratorConfigCommitmentIntegrationArgs',
    'GetOrchestratorConfigCommitmentIntegrationArgsDict',
    'GetOrchestratorConfigDistributionArgs',
    'GetOrchestratorConfigDistributionArgsDict',
    'GetOrchestratorConfigNodePreferencesArgs',
    'GetOrchestratorConfigNodePreferencesArgsDict',
    'GetOrchestratorConfigReplacementScheduleArgs',
    'GetOrchestratorConfigReplacementScheduleArgsDict',
    'GetOrchestratorConfigReplacementScheduleAppliesToArgs',
    'GetOrchestratorConfigReplacementScheduleAppliesToArgsDict',
    'GetOrchestratorConfigReplacementScheduleWindowDetailsArgs',
    'GetOrchestratorConfigReplacementScheduleWindowDetailsArgsDict',
]

MYPY = False

if not MYPY:
    class OrchestratorConfigBinpackingArgsDict(TypedDict):
        disruption: NotRequired[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgsDict']]
        """
        Harness disruption configuration
        """
        pod_eviction: NotRequired[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgsDict']]
        """
        Harness Pod Evictor Configuration
        """
elif False:
    OrchestratorConfigBinpackingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingArgs:
    def __init__(__self__, *,
                 disruption: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs']] = None,
                 pod_eviction: Optional[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs']] = None):
        """
        :param pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs'] disruption: Harness disruption configuration
        :param pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs'] pod_eviction: Harness Pod Evictor Configuration
        """
        if disruption is not None:
            pulumi.set(__self__, "disruption", disruption)
        if pod_eviction is not None:
            pulumi.set(__self__, "pod_eviction", pod_eviction)

    @_builtins.property
    @pulumi.getter
    def disruption(self) -> Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs']]:
        """
        Harness disruption configuration
        """
        return pulumi.get(self, "disruption")

    @disruption.setter
    def disruption(self, value: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs']]):
        pulumi.set(self, "disruption", value)

    @_builtins.property
    @pulumi.getter(name="podEviction")
    def pod_eviction(self) -> Optional[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs']]:
        """
        Harness Pod Evictor Configuration
        """
        return pulumi.get(self, "pod_eviction")

    @pod_eviction.setter
    def pod_eviction(self, value: Optional[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs']]):
        pulumi.set(self, "pod_eviction", value)


if not MYPY:
    class OrchestratorConfigBinpackingDisruptionArgsDict(TypedDict):
        budgets: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgsDict']]]]
        """
        Budgets for disruption
        """
        criteria: NotRequired[pulumi.Input[_builtins.str]]
        """
        Criteria for considering a nodes for disruption
        """
        delay: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deletion delay
        """
elif False:
    OrchestratorConfigBinpackingDisruptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingDisruptionArgs:
    def __init__(__self__, *,
                 budgets: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]]] = None,
                 criteria: Optional[pulumi.Input[_builtins.str]] = None,
                 delay: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]] budgets: Budgets for disruption
        :param pulumi.Input[_builtins.str] criteria: Criteria for considering a nodes for disruption
        :param pulumi.Input[_builtins.str] delay: Deletion delay
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def budgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]]]:
        """
        Budgets for disruption
        """
        return pulumi.get(self, "budgets")

    @budgets.setter
    def budgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]]]):
        pulumi.set(self, "budgets", value)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Criteria for considering a nodes for disruption
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deletion delay
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delay", value)


if not MYPY:
    class OrchestratorConfigBinpackingDisruptionBudgetArgsDict(TypedDict):
        nodes: pulumi.Input[_builtins.str]
        """
        Number or percentage of Nodes to consider for disruption
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Reasons for disruption
        """
        schedule: NotRequired[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict']]
        """
        Schedule for disruption budget
        """
elif False:
    OrchestratorConfigBinpackingDisruptionBudgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingDisruptionBudgetArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[_builtins.str],
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 schedule: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] nodes: Number or percentage of Nodes to consider for disruption
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] reasons: Reasons for disruption
        :param pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs'] schedule: Schedule for disruption budget
        """
        pulumi.set(__self__, "nodes", nodes)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[_builtins.str]:
        """
        Number or percentage of Nodes to consider for disruption
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Reasons for disruption
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']]:
        """
        Schedule for disruption budget
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict(TypedDict):
        duration: pulumi.Input[_builtins.str]
        """
        Duration for disruption budget
        """
        frequency: pulumi.Input[_builtins.str]
        """
        Frequency for disruption budget
        """
elif False:
    OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[_builtins.str],
                 frequency: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] duration: Duration for disruption budget
        :param pulumi.Input[_builtins.str] frequency: Frequency for disruption budget
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> pulumi.Input[_builtins.str]:
        """
        Duration for disruption budget
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[_builtins.str]:
        """
        Frequency for disruption budget
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class OrchestratorConfigBinpackingPodEvictionArgsDict(TypedDict):
        threshold: pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgsDict']
        """
        Minimum Threshold for considering a node as underutilized
        """
elif False:
    OrchestratorConfigBinpackingPodEvictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingPodEvictionArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs']):
        """
        :param pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs'] threshold: Minimum Threshold for considering a node as underutilized
        """
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs']:
        """
        Minimum Threshold for considering a node as underutilized
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs']):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class OrchestratorConfigBinpackingPodEvictionThresholdArgsDict(TypedDict):
        cpu: pulumi.Input[_builtins.float]
        """
        CPU percentage for considering a node as underutilized
        """
        memory: pulumi.Input[_builtins.float]
        """
        Memory percentage for considering a node as underutilized
        """
elif False:
    OrchestratorConfigBinpackingPodEvictionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingPodEvictionThresholdArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[_builtins.float],
                 memory: pulumi.Input[_builtins.float]):
        """
        :param pulumi.Input[_builtins.float] cpu: CPU percentage for considering a node as underutilized
        :param pulumi.Input[_builtins.float] memory: Memory percentage for considering a node as underutilized
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.float]:
        """
        CPU percentage for considering a node as underutilized
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.float]:
        """
        Memory percentage for considering a node as underutilized
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class OrchestratorConfigCommitmentIntegrationArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Flag to enable Commitment Integration
        """
        master_account_id: pulumi.Input[_builtins.str]
        """
        Master AWS account id for commitment integration
        """
elif False:
    OrchestratorConfigCommitmentIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigCommitmentIntegrationArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 master_account_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Flag to enable Commitment Integration
        :param pulumi.Input[_builtins.str] master_account_id: Master AWS account id for commitment integration
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "master_account_id", master_account_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Flag to enable Commitment Integration
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="masterAccountId")
    def master_account_id(self) -> pulumi.Input[_builtins.str]:
        """
        Master AWS account id for commitment integration
        """
        return pulumi.get(self, "master_account_id")

    @master_account_id.setter
    def master_account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "master_account_id", value)


if not MYPY:
    class OrchestratorConfigDistributionArgsDict(TypedDict):
        ondemand_replica_percentage: pulumi.Input[_builtins.float]
        """
        Percentage of on-demand replicas required for workloads
        """
        base_ondemand_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of minimum ondemand replicas required for workloads
        """
        selector: NotRequired[pulumi.Input[_builtins.str]]
        """
        Selector for choosing workloads for distribution
        """
        strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Strategy for choosing spot nodes for cluster
        """
elif False:
    OrchestratorConfigDistributionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigDistributionArgs:
    def __init__(__self__, *,
                 ondemand_replica_percentage: pulumi.Input[_builtins.float],
                 base_ondemand_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 selector: Optional[pulumi.Input[_builtins.str]] = None,
                 strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] ondemand_replica_percentage: Percentage of on-demand replicas required for workloads
        :param pulumi.Input[_builtins.int] base_ondemand_capacity: Number of minimum ondemand replicas required for workloads
        :param pulumi.Input[_builtins.str] selector: Selector for choosing workloads for distribution
        :param pulumi.Input[_builtins.str] strategy: Strategy for choosing spot nodes for cluster
        """
        pulumi.set(__self__, "ondemand_replica_percentage", ondemand_replica_percentage)
        if base_ondemand_capacity is not None:
            pulumi.set(__self__, "base_ondemand_capacity", base_ondemand_capacity)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="ondemandReplicaPercentage")
    def ondemand_replica_percentage(self) -> pulumi.Input[_builtins.float]:
        """
        Percentage of on-demand replicas required for workloads
        """
        return pulumi.get(self, "ondemand_replica_percentage")

    @ondemand_replica_percentage.setter
    def ondemand_replica_percentage(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "ondemand_replica_percentage", value)

    @_builtins.property
    @pulumi.getter(name="baseOndemandCapacity")
    def base_ondemand_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of minimum ondemand replicas required for workloads
        """
        return pulumi.get(self, "base_ondemand_capacity")

    @base_ondemand_capacity.setter
    def base_ondemand_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "base_ondemand_capacity", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Selector for choosing workloads for distribution
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Strategy for choosing spot nodes for cluster
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class OrchestratorConfigNodePreferencesArgsDict(TypedDict):
        reverse_fallback_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reverse fallback interval
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        TTL for nodes
        """
elif False:
    OrchestratorConfigNodePreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigNodePreferencesArgs:
    def __init__(__self__, *,
                 reverse_fallback_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] reverse_fallback_interval: Reverse fallback interval
        :param pulumi.Input[_builtins.str] ttl: TTL for nodes
        """
        if reverse_fallback_interval is not None:
            pulumi.set(__self__, "reverse_fallback_interval", reverse_fallback_interval)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="reverseFallbackInterval")
    def reverse_fallback_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reverse fallback interval
        """
        return pulumi.get(self, "reverse_fallback_interval")

    @reverse_fallback_interval.setter
    def reverse_fallback_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reverse_fallback_interval", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TTL for nodes
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class OrchestratorConfigReplacementScheduleArgsDict(TypedDict):
        applies_to: pulumi.Input['OrchestratorConfigReplacementScheduleAppliesToArgsDict']
        """
        Defines the scope of the replacement schedule
        """
        window_type: pulumi.Input[_builtins.str]
        """
        Window type for replacement schedule
        """
        window_details: NotRequired[pulumi.Input['OrchestratorConfigReplacementScheduleWindowDetailsArgsDict']]
elif False:
    OrchestratorConfigReplacementScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigReplacementScheduleArgs:
    def __init__(__self__, *,
                 applies_to: pulumi.Input['OrchestratorConfigReplacementScheduleAppliesToArgs'],
                 window_type: pulumi.Input[_builtins.str],
                 window_details: Optional[pulumi.Input['OrchestratorConfigReplacementScheduleWindowDetailsArgs']] = None):
        """
        :param pulumi.Input['OrchestratorConfigReplacementScheduleAppliesToArgs'] applies_to: Defines the scope of the replacement schedule
        :param pulumi.Input[_builtins.str] window_type: Window type for replacement schedule
        """
        pulumi.set(__self__, "applies_to", applies_to)
        pulumi.set(__self__, "window_type", window_type)
        if window_details is not None:
            pulumi.set(__self__, "window_details", window_details)

    @_builtins.property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> pulumi.Input['OrchestratorConfigReplacementScheduleAppliesToArgs']:
        """
        Defines the scope of the replacement schedule
        """
        return pulumi.get(self, "applies_to")

    @applies_to.setter
    def applies_to(self, value: pulumi.Input['OrchestratorConfigReplacementScheduleAppliesToArgs']):
        pulumi.set(self, "applies_to", value)

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> pulumi.Input[_builtins.str]:
        """
        Window type for replacement schedule
        """
        return pulumi.get(self, "window_type")

    @window_type.setter
    def window_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "window_type", value)

    @_builtins.property
    @pulumi.getter(name="windowDetails")
    def window_details(self) -> Optional[pulumi.Input['OrchestratorConfigReplacementScheduleWindowDetailsArgs']]:
        return pulumi.get(self, "window_details")

    @window_details.setter
    def window_details(self, value: Optional[pulumi.Input['OrchestratorConfigReplacementScheduleWindowDetailsArgs']]):
        pulumi.set(self, "window_details", value)


if not MYPY:
    class OrchestratorConfigReplacementScheduleAppliesToArgsDict(TypedDict):
        consolidation: pulumi.Input[_builtins.bool]
        harness_pod_eviction: pulumi.Input[_builtins.bool]
        reverse_fallback: pulumi.Input[_builtins.bool]
elif False:
    OrchestratorConfigReplacementScheduleAppliesToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigReplacementScheduleAppliesToArgs:
    def __init__(__self__, *,
                 consolidation: pulumi.Input[_builtins.bool],
                 harness_pod_eviction: pulumi.Input[_builtins.bool],
                 reverse_fallback: pulumi.Input[_builtins.bool]):
        pulumi.set(__self__, "consolidation", consolidation)
        pulumi.set(__self__, "harness_pod_eviction", harness_pod_eviction)
        pulumi.set(__self__, "reverse_fallback", reverse_fallback)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "consolidation")

    @consolidation.setter
    def consolidation(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "consolidation", value)

    @_builtins.property
    @pulumi.getter(name="harnessPodEviction")
    def harness_pod_eviction(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "harness_pod_eviction")

    @harness_pod_eviction.setter
    def harness_pod_eviction(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "harness_pod_eviction", value)

    @_builtins.property
    @pulumi.getter(name="reverseFallback")
    def reverse_fallback(self) -> pulumi.Input[_builtins.bool]:
        return pulumi.get(self, "reverse_fallback")

    @reverse_fallback.setter
    def reverse_fallback(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "reverse_fallback", value)


if not MYPY:
    class OrchestratorConfigReplacementScheduleWindowDetailsArgsDict(TypedDict):
        days: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        time_zone: pulumi.Input[_builtins.str]
        """
        Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        """
        all_day: NotRequired[pulumi.Input[_builtins.bool]]
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
elif False:
    OrchestratorConfigReplacementScheduleWindowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigReplacementScheduleWindowDetailsArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 time_zone: pulumi.Input[_builtins.str],
                 all_day: Optional[pulumi.Input[_builtins.bool]] = None,
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] days: List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        :param pulumi.Input[_builtins.str] time_zone: Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        :param pulumi.Input[_builtins.str] end_time: End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        :param pulumi.Input[_builtins.str] start_time: Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "time_zone", time_zone)
        if all_day is not None:
            pulumi.set(__self__, "all_day", all_day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[_builtins.str]:
        """
        Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter(name="allDay")
    def all_day(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "all_day")

    @all_day.setter
    def all_day(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "all_day", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingArgsDict(TypedDict):
        disruption: NotRequired['GetOrchestratorConfigBinpackingDisruptionArgsDict']
        """
        Harness disruption configuration
        """
        pod_eviction: NotRequired['GetOrchestratorConfigBinpackingPodEvictionArgsDict']
        """
        Harness Pod Evictor Configuration
        """
elif False:
    GetOrchestratorConfigBinpackingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingArgs:
    def __init__(__self__, *,
                 disruption: Optional['GetOrchestratorConfigBinpackingDisruptionArgs'] = None,
                 pod_eviction: Optional['GetOrchestratorConfigBinpackingPodEvictionArgs'] = None):
        """
        :param 'GetOrchestratorConfigBinpackingDisruptionArgs' disruption: Harness disruption configuration
        :param 'GetOrchestratorConfigBinpackingPodEvictionArgs' pod_eviction: Harness Pod Evictor Configuration
        """
        if disruption is not None:
            pulumi.set(__self__, "disruption", disruption)
        if pod_eviction is not None:
            pulumi.set(__self__, "pod_eviction", pod_eviction)

    @_builtins.property
    @pulumi.getter
    def disruption(self) -> Optional['GetOrchestratorConfigBinpackingDisruptionArgs']:
        """
        Harness disruption configuration
        """
        return pulumi.get(self, "disruption")

    @disruption.setter
    def disruption(self, value: Optional['GetOrchestratorConfigBinpackingDisruptionArgs']):
        pulumi.set(self, "disruption", value)

    @_builtins.property
    @pulumi.getter(name="podEviction")
    def pod_eviction(self) -> Optional['GetOrchestratorConfigBinpackingPodEvictionArgs']:
        """
        Harness Pod Evictor Configuration
        """
        return pulumi.get(self, "pod_eviction")

    @pod_eviction.setter
    def pod_eviction(self, value: Optional['GetOrchestratorConfigBinpackingPodEvictionArgs']):
        pulumi.set(self, "pod_eviction", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingDisruptionArgsDict(TypedDict):
        budgets: NotRequired[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict']]
        """
        Budgets for disruption
        """
        criteria: NotRequired[_builtins.str]
        """
        Criteria for considering a nodes for disruption
        """
        delay: NotRequired[_builtins.str]
        """
        Deletion delay
        """
elif False:
    GetOrchestratorConfigBinpackingDisruptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingDisruptionArgs:
    def __init__(__self__, *,
                 budgets: Optional[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs']] = None,
                 criteria: Optional[_builtins.str] = None,
                 delay: Optional[_builtins.str] = None):
        """
        :param Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs'] budgets: Budgets for disruption
        :param _builtins.str criteria: Criteria for considering a nodes for disruption
        :param _builtins.str delay: Deletion delay
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @_builtins.property
    @pulumi.getter
    def budgets(self) -> Optional[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs']]:
        """
        Budgets for disruption
        """
        return pulumi.get(self, "budgets")

    @budgets.setter
    def budgets(self, value: Optional[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs']]):
        pulumi.set(self, "budgets", value)

    @_builtins.property
    @pulumi.getter
    def criteria(self) -> Optional[_builtins.str]:
        """
        Criteria for considering a nodes for disruption
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[_builtins.str]):
        pulumi.set(self, "criteria", value)

    @_builtins.property
    @pulumi.getter
    def delay(self) -> Optional[_builtins.str]:
        """
        Deletion delay
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[_builtins.str]):
        pulumi.set(self, "delay", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict(TypedDict):
        nodes: _builtins.str
        """
        Number or percentage of Nodes to consider for disruption
        """
        reasons: NotRequired[Sequence[_builtins.str]]
        """
        Reasons for disruption
        """
        schedule: NotRequired['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict']
        """
        Schedule for disruption budget
        """
elif False:
    GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingDisruptionBudgetArgs:
    def __init__(__self__, *,
                 nodes: _builtins.str,
                 reasons: Optional[Sequence[_builtins.str]] = None,
                 schedule: Optional['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs'] = None):
        """
        :param _builtins.str nodes: Number or percentage of Nodes to consider for disruption
        :param Sequence[_builtins.str] reasons: Reasons for disruption
        :param 'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs' schedule: Schedule for disruption budget
        """
        pulumi.set(__self__, "nodes", nodes)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> _builtins.str:
        """
        Number or percentage of Nodes to consider for disruption
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: _builtins.str):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        Reasons for disruption
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "reasons", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']:
        """
        Schedule for disruption budget
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict(TypedDict):
        duration: _builtins.str
        """
        Duration for disruption budget
        """
        frequency: _builtins.str
        """
        Frequency for disruption budget
        """
elif False:
    GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs:
    def __init__(__self__, *,
                 duration: _builtins.str,
                 frequency: _builtins.str):
        """
        :param _builtins.str duration: Duration for disruption budget
        :param _builtins.str frequency: Frequency for disruption budget
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        Duration for disruption budget
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: _builtins.str):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> _builtins.str:
        """
        Frequency for disruption budget
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: _builtins.str):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingPodEvictionArgsDict(TypedDict):
        threshold: 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict'
        """
        Minimum Threshold for considering a node as underutilized
        """
elif False:
    GetOrchestratorConfigBinpackingPodEvictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingPodEvictionArgs:
    def __init__(__self__, *,
                 threshold: 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs'):
        """
        :param 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs' threshold: Minimum Threshold for considering a node as underutilized
        """
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs':
        """
        Minimum Threshold for considering a node as underutilized
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs'):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict(TypedDict):
        cpu: _builtins.float
        """
        CPU percentage for considering a node as underutilized
        """
        memory: _builtins.float
        """
        Memory percentage for considering a node as underutilized
        """
elif False:
    GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingPodEvictionThresholdArgs:
    def __init__(__self__, *,
                 cpu: _builtins.float,
                 memory: _builtins.float):
        """
        :param _builtins.float cpu: CPU percentage for considering a node as underutilized
        :param _builtins.float memory: Memory percentage for considering a node as underutilized
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.float:
        """
        CPU percentage for considering a node as underutilized
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: _builtins.float):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Memory percentage for considering a node as underutilized
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: _builtins.float):
        pulumi.set(self, "memory", value)


if not MYPY:
    class GetOrchestratorConfigCommitmentIntegrationArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Flag to enable Commitment Integration
        """
        master_account_id: _builtins.str
        """
        Master AWS account id for commitment integration
        """
elif False:
    GetOrchestratorConfigCommitmentIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigCommitmentIntegrationArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 master_account_id: _builtins.str):
        """
        :param _builtins.bool enabled: Flag to enable Commitment Integration
        :param _builtins.str master_account_id: Master AWS account id for commitment integration
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "master_account_id", master_account_id)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Flag to enable Commitment Integration
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="masterAccountId")
    def master_account_id(self) -> _builtins.str:
        """
        Master AWS account id for commitment integration
        """
        return pulumi.get(self, "master_account_id")

    @master_account_id.setter
    def master_account_id(self, value: _builtins.str):
        pulumi.set(self, "master_account_id", value)


if not MYPY:
    class GetOrchestratorConfigDistributionArgsDict(TypedDict):
        ondemand_replica_percentage: _builtins.float
        """
        Percentage of on-demand replicas required for workloads
        """
        base_ondemand_capacity: NotRequired[_builtins.int]
        """
        Number of minimum ondemand replicas required for workloads
        """
        selector: NotRequired[_builtins.str]
        """
        Selector for choosing workloads for distribution
        """
        strategy: NotRequired[_builtins.str]
        """
        Strategy for choosing spot nodes for cluster
        """
elif False:
    GetOrchestratorConfigDistributionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigDistributionArgs:
    def __init__(__self__, *,
                 ondemand_replica_percentage: _builtins.float,
                 base_ondemand_capacity: Optional[_builtins.int] = None,
                 selector: Optional[_builtins.str] = None,
                 strategy: Optional[_builtins.str] = None):
        """
        :param _builtins.float ondemand_replica_percentage: Percentage of on-demand replicas required for workloads
        :param _builtins.int base_ondemand_capacity: Number of minimum ondemand replicas required for workloads
        :param _builtins.str selector: Selector for choosing workloads for distribution
        :param _builtins.str strategy: Strategy for choosing spot nodes for cluster
        """
        pulumi.set(__self__, "ondemand_replica_percentage", ondemand_replica_percentage)
        if base_ondemand_capacity is not None:
            pulumi.set(__self__, "base_ondemand_capacity", base_ondemand_capacity)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @_builtins.property
    @pulumi.getter(name="ondemandReplicaPercentage")
    def ondemand_replica_percentage(self) -> _builtins.float:
        """
        Percentage of on-demand replicas required for workloads
        """
        return pulumi.get(self, "ondemand_replica_percentage")

    @ondemand_replica_percentage.setter
    def ondemand_replica_percentage(self, value: _builtins.float):
        pulumi.set(self, "ondemand_replica_percentage", value)

    @_builtins.property
    @pulumi.getter(name="baseOndemandCapacity")
    def base_ondemand_capacity(self) -> Optional[_builtins.int]:
        """
        Number of minimum ondemand replicas required for workloads
        """
        return pulumi.get(self, "base_ondemand_capacity")

    @base_ondemand_capacity.setter
    def base_ondemand_capacity(self, value: Optional[_builtins.int]):
        pulumi.set(self, "base_ondemand_capacity", value)

    @_builtins.property
    @pulumi.getter
    def selector(self) -> Optional[_builtins.str]:
        """
        Selector for choosing workloads for distribution
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[_builtins.str]):
        pulumi.set(self, "selector", value)

    @_builtins.property
    @pulumi.getter
    def strategy(self) -> Optional[_builtins.str]:
        """
        Strategy for choosing spot nodes for cluster
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[_builtins.str]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class GetOrchestratorConfigNodePreferencesArgsDict(TypedDict):
        reverse_fallback_interval: NotRequired[_builtins.str]
        """
        Reverse fallback interval
        """
        ttl: NotRequired[_builtins.str]
        """
        TTL for nodes
        """
elif False:
    GetOrchestratorConfigNodePreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigNodePreferencesArgs:
    def __init__(__self__, *,
                 reverse_fallback_interval: Optional[_builtins.str] = None,
                 ttl: Optional[_builtins.str] = None):
        """
        :param _builtins.str reverse_fallback_interval: Reverse fallback interval
        :param _builtins.str ttl: TTL for nodes
        """
        if reverse_fallback_interval is not None:
            pulumi.set(__self__, "reverse_fallback_interval", reverse_fallback_interval)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="reverseFallbackInterval")
    def reverse_fallback_interval(self) -> Optional[_builtins.str]:
        """
        Reverse fallback interval
        """
        return pulumi.get(self, "reverse_fallback_interval")

    @reverse_fallback_interval.setter
    def reverse_fallback_interval(self, value: Optional[_builtins.str]):
        pulumi.set(self, "reverse_fallback_interval", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        TTL for nodes
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class GetOrchestratorConfigReplacementScheduleArgsDict(TypedDict):
        applies_to: 'GetOrchestratorConfigReplacementScheduleAppliesToArgsDict'
        """
        Defines the scope of the replacement schedule
        """
        window_type: _builtins.str
        """
        Window type for replacement schedule
        """
        window_details: NotRequired['GetOrchestratorConfigReplacementScheduleWindowDetailsArgsDict']
elif False:
    GetOrchestratorConfigReplacementScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigReplacementScheduleArgs:
    def __init__(__self__, *,
                 applies_to: 'GetOrchestratorConfigReplacementScheduleAppliesToArgs',
                 window_type: _builtins.str,
                 window_details: Optional['GetOrchestratorConfigReplacementScheduleWindowDetailsArgs'] = None):
        """
        :param 'GetOrchestratorConfigReplacementScheduleAppliesToArgs' applies_to: Defines the scope of the replacement schedule
        :param _builtins.str window_type: Window type for replacement schedule
        """
        pulumi.set(__self__, "applies_to", applies_to)
        pulumi.set(__self__, "window_type", window_type)
        if window_details is not None:
            pulumi.set(__self__, "window_details", window_details)

    @_builtins.property
    @pulumi.getter(name="appliesTo")
    def applies_to(self) -> 'GetOrchestratorConfigReplacementScheduleAppliesToArgs':
        """
        Defines the scope of the replacement schedule
        """
        return pulumi.get(self, "applies_to")

    @applies_to.setter
    def applies_to(self, value: 'GetOrchestratorConfigReplacementScheduleAppliesToArgs'):
        pulumi.set(self, "applies_to", value)

    @_builtins.property
    @pulumi.getter(name="windowType")
    def window_type(self) -> _builtins.str:
        """
        Window type for replacement schedule
        """
        return pulumi.get(self, "window_type")

    @window_type.setter
    def window_type(self, value: _builtins.str):
        pulumi.set(self, "window_type", value)

    @_builtins.property
    @pulumi.getter(name="windowDetails")
    def window_details(self) -> Optional['GetOrchestratorConfigReplacementScheduleWindowDetailsArgs']:
        return pulumi.get(self, "window_details")

    @window_details.setter
    def window_details(self, value: Optional['GetOrchestratorConfigReplacementScheduleWindowDetailsArgs']):
        pulumi.set(self, "window_details", value)


if not MYPY:
    class GetOrchestratorConfigReplacementScheduleAppliesToArgsDict(TypedDict):
        consolidation: _builtins.bool
        harness_pod_eviction: _builtins.bool
        reverse_fallback: _builtins.bool
elif False:
    GetOrchestratorConfigReplacementScheduleAppliesToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigReplacementScheduleAppliesToArgs:
    def __init__(__self__, *,
                 consolidation: _builtins.bool,
                 harness_pod_eviction: _builtins.bool,
                 reverse_fallback: _builtins.bool):
        pulumi.set(__self__, "consolidation", consolidation)
        pulumi.set(__self__, "harness_pod_eviction", harness_pod_eviction)
        pulumi.set(__self__, "reverse_fallback", reverse_fallback)

    @_builtins.property
    @pulumi.getter
    def consolidation(self) -> _builtins.bool:
        return pulumi.get(self, "consolidation")

    @consolidation.setter
    def consolidation(self, value: _builtins.bool):
        pulumi.set(self, "consolidation", value)

    @_builtins.property
    @pulumi.getter(name="harnessPodEviction")
    def harness_pod_eviction(self) -> _builtins.bool:
        return pulumi.get(self, "harness_pod_eviction")

    @harness_pod_eviction.setter
    def harness_pod_eviction(self, value: _builtins.bool):
        pulumi.set(self, "harness_pod_eviction", value)

    @_builtins.property
    @pulumi.getter(name="reverseFallback")
    def reverse_fallback(self) -> _builtins.bool:
        return pulumi.get(self, "reverse_fallback")

    @reverse_fallback.setter
    def reverse_fallback(self, value: _builtins.bool):
        pulumi.set(self, "reverse_fallback", value)


if not MYPY:
    class GetOrchestratorConfigReplacementScheduleWindowDetailsArgsDict(TypedDict):
        days: Sequence[_builtins.str]
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        time_zone: _builtins.str
        """
        Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        """
        all_day: NotRequired[_builtins.bool]
        end_time: NotRequired[_builtins.str]
        """
        End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        start_time: NotRequired[_builtins.str]
        """
        Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
elif False:
    GetOrchestratorConfigReplacementScheduleWindowDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigReplacementScheduleWindowDetailsArgs:
    def __init__(__self__, *,
                 days: Sequence[_builtins.str],
                 time_zone: _builtins.str,
                 all_day: Optional[_builtins.bool] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] days: List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        :param _builtins.str time_zone: Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        :param _builtins.str end_time: End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        :param _builtins.str start_time: Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        pulumi.set(__self__, "days", days)
        pulumi.set(__self__, "time_zone", time_zone)
        if all_day is not None:
            pulumi.set(__self__, "all_day", all_day)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Sequence[_builtins.str]:
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        Time zone in which the schedule needs to be executed. Example Valid values: UTC, America/New*York, Europe/London, Asia/Kolkata, Asia/Tokyo, Asia/Hong*Kong, Asia/Singapore, Australia/Melbourne and Australia/Sydney.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: _builtins.str):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter(name="allDay")
    def all_day(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all_day")

    @all_day.setter
    def all_day(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all_day", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        End time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[_builtins.str]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        Start time of schedule in the format HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[_builtins.str]):
        pulumi.set(self, "start_time", value)


