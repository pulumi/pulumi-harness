# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'OrchestratorConfigBinpackingArgs',
    'OrchestratorConfigBinpackingArgsDict',
    'OrchestratorConfigBinpackingDisruptionArgs',
    'OrchestratorConfigBinpackingDisruptionArgsDict',
    'OrchestratorConfigBinpackingDisruptionBudgetArgs',
    'OrchestratorConfigBinpackingDisruptionBudgetArgsDict',
    'OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs',
    'OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict',
    'OrchestratorConfigBinpackingPodEvictionArgs',
    'OrchestratorConfigBinpackingPodEvictionArgsDict',
    'OrchestratorConfigBinpackingPodEvictionThresholdArgs',
    'OrchestratorConfigBinpackingPodEvictionThresholdArgsDict',
    'OrchestratorConfigDistributionArgs',
    'OrchestratorConfigDistributionArgsDict',
    'OrchestratorConfigNodePreferencesArgs',
    'OrchestratorConfigNodePreferencesArgsDict',
    'GetOrchestratorConfigBinpackingArgs',
    'GetOrchestratorConfigBinpackingArgsDict',
    'GetOrchestratorConfigBinpackingDisruptionArgs',
    'GetOrchestratorConfigBinpackingDisruptionArgsDict',
    'GetOrchestratorConfigBinpackingDisruptionBudgetArgs',
    'GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict',
    'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs',
    'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict',
    'GetOrchestratorConfigBinpackingPodEvictionArgs',
    'GetOrchestratorConfigBinpackingPodEvictionArgsDict',
    'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs',
    'GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict',
    'GetOrchestratorConfigDistributionArgs',
    'GetOrchestratorConfigDistributionArgsDict',
    'GetOrchestratorConfigNodePreferencesArgs',
    'GetOrchestratorConfigNodePreferencesArgsDict',
]

MYPY = False

if not MYPY:
    class OrchestratorConfigBinpackingArgsDict(TypedDict):
        disruption: NotRequired[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgsDict']]
        """
        Harness disruption configuration
        """
        pod_eviction: NotRequired[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgsDict']]
        """
        Harness Pod Evictor Configuration
        """
elif False:
    OrchestratorConfigBinpackingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingArgs:
    def __init__(__self__, *,
                 disruption: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs']] = None,
                 pod_eviction: Optional[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs']] = None):
        """
        :param pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs'] disruption: Harness disruption configuration
        :param pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs'] pod_eviction: Harness Pod Evictor Configuration
        """
        if disruption is not None:
            pulumi.set(__self__, "disruption", disruption)
        if pod_eviction is not None:
            pulumi.set(__self__, "pod_eviction", pod_eviction)

    @property
    @pulumi.getter
    def disruption(self) -> Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs']]:
        """
        Harness disruption configuration
        """
        return pulumi.get(self, "disruption")

    @disruption.setter
    def disruption(self, value: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionArgs']]):
        pulumi.set(self, "disruption", value)

    @property
    @pulumi.getter(name="podEviction")
    def pod_eviction(self) -> Optional[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs']]:
        """
        Harness Pod Evictor Configuration
        """
        return pulumi.get(self, "pod_eviction")

    @pod_eviction.setter
    def pod_eviction(self, value: Optional[pulumi.Input['OrchestratorConfigBinpackingPodEvictionArgs']]):
        pulumi.set(self, "pod_eviction", value)


if not MYPY:
    class OrchestratorConfigBinpackingDisruptionArgsDict(TypedDict):
        budgets: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgsDict']]]]
        """
        Budgets for disruption
        """
        criteria: NotRequired[pulumi.Input[builtins.str]]
        """
        Criteria for considering a nodes for disruption
        """
        delay: NotRequired[pulumi.Input[builtins.str]]
        """
        Deletion delay
        """
elif False:
    OrchestratorConfigBinpackingDisruptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingDisruptionArgs:
    def __init__(__self__, *,
                 budgets: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]]] = None,
                 criteria: Optional[pulumi.Input[builtins.str]] = None,
                 delay: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]] budgets: Budgets for disruption
        :param pulumi.Input[builtins.str] criteria: Criteria for considering a nodes for disruption
        :param pulumi.Input[builtins.str] delay: Deletion delay
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def budgets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]]]:
        """
        Budgets for disruption
        """
        return pulumi.get(self, "budgets")

    @budgets.setter
    def budgets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetArgs']]]]):
        pulumi.set(self, "budgets", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Criteria for considering a nodes for disruption
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def delay(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deletion delay
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delay", value)


if not MYPY:
    class OrchestratorConfigBinpackingDisruptionBudgetArgsDict(TypedDict):
        nodes: pulumi.Input[builtins.str]
        """
        Number or percentage of Nodes to consider for disruption
        """
        reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Reasons for disruption
        """
        schedule: NotRequired[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict']]
        """
        Schedule for disruption budget
        """
elif False:
    OrchestratorConfigBinpackingDisruptionBudgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingDisruptionBudgetArgs:
    def __init__(__self__, *,
                 nodes: pulumi.Input[builtins.str],
                 reasons: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 schedule: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']] = None):
        """
        :param pulumi.Input[builtins.str] nodes: Number or percentage of Nodes to consider for disruption
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] reasons: Reasons for disruption
        :param pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs'] schedule: Schedule for disruption budget
        """
        pulumi.set(__self__, "nodes", nodes)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def nodes(self) -> pulumi.Input[builtins.str]:
        """
        Number or percentage of Nodes to consider for disruption
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Reasons for disruption
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "reasons", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']]:
        """
        Schedule for disruption budget
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict(TypedDict):
        duration: pulumi.Input[builtins.str]
        """
        Duration for disruption budget
        """
        frequency: pulumi.Input[builtins.str]
        """
        Frequency for disruption budget
        """
elif False:
    OrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingDisruptionBudgetScheduleArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[builtins.str],
                 frequency: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] duration: Duration for disruption budget
        :param pulumi.Input[builtins.str] frequency: Frequency for disruption budget
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[builtins.str]:
        """
        Duration for disruption budget
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[builtins.str]:
        """
        Frequency for disruption budget
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class OrchestratorConfigBinpackingPodEvictionArgsDict(TypedDict):
        threshold: pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgsDict']
        """
        Minimum Threshold for considering a node as underutilized
        """
elif False:
    OrchestratorConfigBinpackingPodEvictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingPodEvictionArgs:
    def __init__(__self__, *,
                 threshold: pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs']):
        """
        :param pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs'] threshold: Minimum Threshold for considering a node as underutilized
        """
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs']:
        """
        Minimum Threshold for considering a node as underutilized
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input['OrchestratorConfigBinpackingPodEvictionThresholdArgs']):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class OrchestratorConfigBinpackingPodEvictionThresholdArgsDict(TypedDict):
        cpu: pulumi.Input[builtins.float]
        """
        CPU percentage for considering a node as underutilized
        """
        memory: pulumi.Input[builtins.float]
        """
        Memory percentage for considering a node as underutilized
        """
elif False:
    OrchestratorConfigBinpackingPodEvictionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigBinpackingPodEvictionThresholdArgs:
    def __init__(__self__, *,
                 cpu: pulumi.Input[builtins.float],
                 memory: pulumi.Input[builtins.float]):
        """
        :param pulumi.Input[builtins.float] cpu: CPU percentage for considering a node as underutilized
        :param pulumi.Input[builtins.float] memory: Memory percentage for considering a node as underutilized
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[builtins.float]:
        """
        CPU percentage for considering a node as underutilized
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> pulumi.Input[builtins.float]:
        """
        Memory percentage for considering a node as underutilized
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class OrchestratorConfigDistributionArgsDict(TypedDict):
        ondemand_replica_percentage: pulumi.Input[builtins.float]
        """
        Percentage of on-demand replicas required for workloads
        """
        base_ondemand_capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of minimum ondemand replicas required for workloads
        """
        selector: NotRequired[pulumi.Input[builtins.str]]
        """
        Selector for choosing workloads for distribution
        """
        strategy: NotRequired[pulumi.Input[builtins.str]]
        """
        Strategy for choosing spot nodes for cluster
        """
elif False:
    OrchestratorConfigDistributionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigDistributionArgs:
    def __init__(__self__, *,
                 ondemand_replica_percentage: pulumi.Input[builtins.float],
                 base_ondemand_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 selector: Optional[pulumi.Input[builtins.str]] = None,
                 strategy: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.float] ondemand_replica_percentage: Percentage of on-demand replicas required for workloads
        :param pulumi.Input[builtins.int] base_ondemand_capacity: Number of minimum ondemand replicas required for workloads
        :param pulumi.Input[builtins.str] selector: Selector for choosing workloads for distribution
        :param pulumi.Input[builtins.str] strategy: Strategy for choosing spot nodes for cluster
        """
        pulumi.set(__self__, "ondemand_replica_percentage", ondemand_replica_percentage)
        if base_ondemand_capacity is not None:
            pulumi.set(__self__, "base_ondemand_capacity", base_ondemand_capacity)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="ondemandReplicaPercentage")
    def ondemand_replica_percentage(self) -> pulumi.Input[builtins.float]:
        """
        Percentage of on-demand replicas required for workloads
        """
        return pulumi.get(self, "ondemand_replica_percentage")

    @ondemand_replica_percentage.setter
    def ondemand_replica_percentage(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "ondemand_replica_percentage", value)

    @property
    @pulumi.getter(name="baseOndemandCapacity")
    def base_ondemand_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of minimum ondemand replicas required for workloads
        """
        return pulumi.get(self, "base_ondemand_capacity")

    @base_ondemand_capacity.setter
    def base_ondemand_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "base_ondemand_capacity", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Selector for choosing workloads for distribution
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Strategy for choosing spot nodes for cluster
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class OrchestratorConfigNodePreferencesArgsDict(TypedDict):
        reverse_fallback_interval: NotRequired[pulumi.Input[builtins.str]]
        """
        Reverse fallback interval
        """
        ttl: NotRequired[pulumi.Input[builtins.str]]
        """
        TTL for nodes
        """
elif False:
    OrchestratorConfigNodePreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrchestratorConfigNodePreferencesArgs:
    def __init__(__self__, *,
                 reverse_fallback_interval: Optional[pulumi.Input[builtins.str]] = None,
                 ttl: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] reverse_fallback_interval: Reverse fallback interval
        :param pulumi.Input[builtins.str] ttl: TTL for nodes
        """
        if reverse_fallback_interval is not None:
            pulumi.set(__self__, "reverse_fallback_interval", reverse_fallback_interval)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="reverseFallbackInterval")
    def reverse_fallback_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reverse fallback interval
        """
        return pulumi.get(self, "reverse_fallback_interval")

    @reverse_fallback_interval.setter
    def reverse_fallback_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reverse_fallback_interval", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        TTL for nodes
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingArgsDict(TypedDict):
        disruption: NotRequired['GetOrchestratorConfigBinpackingDisruptionArgsDict']
        """
        Harness disruption configuration
        """
        pod_eviction: NotRequired['GetOrchestratorConfigBinpackingPodEvictionArgsDict']
        """
        Harness Pod Evictor Configuration
        """
elif False:
    GetOrchestratorConfigBinpackingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingArgs:
    def __init__(__self__, *,
                 disruption: Optional['GetOrchestratorConfigBinpackingDisruptionArgs'] = None,
                 pod_eviction: Optional['GetOrchestratorConfigBinpackingPodEvictionArgs'] = None):
        """
        :param 'GetOrchestratorConfigBinpackingDisruptionArgs' disruption: Harness disruption configuration
        :param 'GetOrchestratorConfigBinpackingPodEvictionArgs' pod_eviction: Harness Pod Evictor Configuration
        """
        if disruption is not None:
            pulumi.set(__self__, "disruption", disruption)
        if pod_eviction is not None:
            pulumi.set(__self__, "pod_eviction", pod_eviction)

    @property
    @pulumi.getter
    def disruption(self) -> Optional['GetOrchestratorConfigBinpackingDisruptionArgs']:
        """
        Harness disruption configuration
        """
        return pulumi.get(self, "disruption")

    @disruption.setter
    def disruption(self, value: Optional['GetOrchestratorConfigBinpackingDisruptionArgs']):
        pulumi.set(self, "disruption", value)

    @property
    @pulumi.getter(name="podEviction")
    def pod_eviction(self) -> Optional['GetOrchestratorConfigBinpackingPodEvictionArgs']:
        """
        Harness Pod Evictor Configuration
        """
        return pulumi.get(self, "pod_eviction")

    @pod_eviction.setter
    def pod_eviction(self, value: Optional['GetOrchestratorConfigBinpackingPodEvictionArgs']):
        pulumi.set(self, "pod_eviction", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingDisruptionArgsDict(TypedDict):
        budgets: NotRequired[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict']]
        """
        Budgets for disruption
        """
        criteria: NotRequired[builtins.str]
        """
        Criteria for considering a nodes for disruption
        """
        delay: NotRequired[builtins.str]
        """
        Deletion delay
        """
elif False:
    GetOrchestratorConfigBinpackingDisruptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingDisruptionArgs:
    def __init__(__self__, *,
                 budgets: Optional[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs']] = None,
                 criteria: Optional[builtins.str] = None,
                 delay: Optional[builtins.str] = None):
        """
        :param Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs'] budgets: Budgets for disruption
        :param builtins.str criteria: Criteria for considering a nodes for disruption
        :param builtins.str delay: Deletion delay
        """
        if budgets is not None:
            pulumi.set(__self__, "budgets", budgets)
        if criteria is not None:
            pulumi.set(__self__, "criteria", criteria)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def budgets(self) -> Optional[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs']]:
        """
        Budgets for disruption
        """
        return pulumi.get(self, "budgets")

    @budgets.setter
    def budgets(self, value: Optional[Sequence['GetOrchestratorConfigBinpackingDisruptionBudgetArgs']]):
        pulumi.set(self, "budgets", value)

    @property
    @pulumi.getter
    def criteria(self) -> Optional[builtins.str]:
        """
        Criteria for considering a nodes for disruption
        """
        return pulumi.get(self, "criteria")

    @criteria.setter
    def criteria(self, value: Optional[builtins.str]):
        pulumi.set(self, "criteria", value)

    @property
    @pulumi.getter
    def delay(self) -> Optional[builtins.str]:
        """
        Deletion delay
        """
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[builtins.str]):
        pulumi.set(self, "delay", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict(TypedDict):
        nodes: builtins.str
        """
        Number or percentage of Nodes to consider for disruption
        """
        reasons: NotRequired[Sequence[builtins.str]]
        """
        Reasons for disruption
        """
        schedule: NotRequired['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict']
        """
        Schedule for disruption budget
        """
elif False:
    GetOrchestratorConfigBinpackingDisruptionBudgetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingDisruptionBudgetArgs:
    def __init__(__self__, *,
                 nodes: builtins.str,
                 reasons: Optional[Sequence[builtins.str]] = None,
                 schedule: Optional['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs'] = None):
        """
        :param builtins.str nodes: Number or percentage of Nodes to consider for disruption
        :param Sequence[builtins.str] reasons: Reasons for disruption
        :param 'GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs' schedule: Schedule for disruption budget
        """
        pulumi.set(__self__, "nodes", nodes)
        if reasons is not None:
            pulumi.set(__self__, "reasons", reasons)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def nodes(self) -> builtins.str:
        """
        Number or percentage of Nodes to consider for disruption
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: builtins.str):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def reasons(self) -> Optional[Sequence[builtins.str]]:
        """
        Reasons for disruption
        """
        return pulumi.get(self, "reasons")

    @reasons.setter
    def reasons(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "reasons", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']:
        """
        Schedule for disruption budget
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional['GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs']):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict(TypedDict):
        duration: builtins.str
        """
        Duration for disruption budget
        """
        frequency: builtins.str
        """
        Frequency for disruption budget
        """
elif False:
    GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingDisruptionBudgetScheduleArgs:
    def __init__(__self__, *,
                 duration: builtins.str,
                 frequency: builtins.str):
        """
        :param builtins.str duration: Duration for disruption budget
        :param builtins.str frequency: Frequency for disruption budget
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def duration(self) -> builtins.str:
        """
        Duration for disruption budget
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: builtins.str):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def frequency(self) -> builtins.str:
        """
        Frequency for disruption budget
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: builtins.str):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingPodEvictionArgsDict(TypedDict):
        threshold: 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict'
        """
        Minimum Threshold for considering a node as underutilized
        """
elif False:
    GetOrchestratorConfigBinpackingPodEvictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingPodEvictionArgs:
    def __init__(__self__, *,
                 threshold: 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs'):
        """
        :param 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs' threshold: Minimum Threshold for considering a node as underutilized
        """
        pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def threshold(self) -> 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs':
        """
        Minimum Threshold for considering a node as underutilized
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: 'GetOrchestratorConfigBinpackingPodEvictionThresholdArgs'):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict(TypedDict):
        cpu: builtins.float
        """
        CPU percentage for considering a node as underutilized
        """
        memory: builtins.float
        """
        Memory percentage for considering a node as underutilized
        """
elif False:
    GetOrchestratorConfigBinpackingPodEvictionThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigBinpackingPodEvictionThresholdArgs:
    def __init__(__self__, *,
                 cpu: builtins.float,
                 memory: builtins.float):
        """
        :param builtins.float cpu: CPU percentage for considering a node as underutilized
        :param builtins.float memory: Memory percentage for considering a node as underutilized
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> builtins.float:
        """
        CPU percentage for considering a node as underutilized
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: builtins.float):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> builtins.float:
        """
        Memory percentage for considering a node as underutilized
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: builtins.float):
        pulumi.set(self, "memory", value)


if not MYPY:
    class GetOrchestratorConfigDistributionArgsDict(TypedDict):
        ondemand_replica_percentage: builtins.float
        """
        Percentage of on-demand replicas required for workloads
        """
        base_ondemand_capacity: NotRequired[builtins.int]
        """
        Number of minimum ondemand replicas required for workloads
        """
        selector: NotRequired[builtins.str]
        """
        Selector for choosing workloads for distribution
        """
        strategy: NotRequired[builtins.str]
        """
        Strategy for choosing spot nodes for cluster
        """
elif False:
    GetOrchestratorConfigDistributionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigDistributionArgs:
    def __init__(__self__, *,
                 ondemand_replica_percentage: builtins.float,
                 base_ondemand_capacity: Optional[builtins.int] = None,
                 selector: Optional[builtins.str] = None,
                 strategy: Optional[builtins.str] = None):
        """
        :param builtins.float ondemand_replica_percentage: Percentage of on-demand replicas required for workloads
        :param builtins.int base_ondemand_capacity: Number of minimum ondemand replicas required for workloads
        :param builtins.str selector: Selector for choosing workloads for distribution
        :param builtins.str strategy: Strategy for choosing spot nodes for cluster
        """
        pulumi.set(__self__, "ondemand_replica_percentage", ondemand_replica_percentage)
        if base_ondemand_capacity is not None:
            pulumi.set(__self__, "base_ondemand_capacity", base_ondemand_capacity)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if strategy is not None:
            pulumi.set(__self__, "strategy", strategy)

    @property
    @pulumi.getter(name="ondemandReplicaPercentage")
    def ondemand_replica_percentage(self) -> builtins.float:
        """
        Percentage of on-demand replicas required for workloads
        """
        return pulumi.get(self, "ondemand_replica_percentage")

    @ondemand_replica_percentage.setter
    def ondemand_replica_percentage(self, value: builtins.float):
        pulumi.set(self, "ondemand_replica_percentage", value)

    @property
    @pulumi.getter(name="baseOndemandCapacity")
    def base_ondemand_capacity(self) -> Optional[builtins.int]:
        """
        Number of minimum ondemand replicas required for workloads
        """
        return pulumi.get(self, "base_ondemand_capacity")

    @base_ondemand_capacity.setter
    def base_ondemand_capacity(self, value: Optional[builtins.int]):
        pulumi.set(self, "base_ondemand_capacity", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[builtins.str]:
        """
        Selector for choosing workloads for distribution
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[builtins.str]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def strategy(self) -> Optional[builtins.str]:
        """
        Strategy for choosing spot nodes for cluster
        """
        return pulumi.get(self, "strategy")

    @strategy.setter
    def strategy(self, value: Optional[builtins.str]):
        pulumi.set(self, "strategy", value)


if not MYPY:
    class GetOrchestratorConfigNodePreferencesArgsDict(TypedDict):
        reverse_fallback_interval: NotRequired[builtins.str]
        """
        Reverse fallback interval
        """
        ttl: NotRequired[builtins.str]
        """
        TTL for nodes
        """
elif False:
    GetOrchestratorConfigNodePreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrchestratorConfigNodePreferencesArgs:
    def __init__(__self__, *,
                 reverse_fallback_interval: Optional[builtins.str] = None,
                 ttl: Optional[builtins.str] = None):
        """
        :param builtins.str reverse_fallback_interval: Reverse fallback interval
        :param builtins.str ttl: TTL for nodes
        """
        if reverse_fallback_interval is not None:
            pulumi.set(__self__, "reverse_fallback_interval", reverse_fallback_interval)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter(name="reverseFallbackInterval")
    def reverse_fallback_interval(self) -> Optional[builtins.str]:
        """
        Reverse fallback interval
        """
        return pulumi.get(self, "reverse_fallback_interval")

    @reverse_fallback_interval.setter
    def reverse_fallback_interval(self, value: Optional[builtins.str]):
        pulumi.set(self, "reverse_fallback_interval", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[builtins.str]:
        """
        TTL for nodes
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[builtins.str]):
        pulumi.set(self, "ttl", value)


