# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ImageRegistryCustomImageArgs',
    'ImageRegistryCustomImageArgsDict',
    'InfrastructureV2EnvArgs',
    'InfrastructureV2EnvArgsDict',
    'InfrastructureV2IdentifierArgs',
    'InfrastructureV2IdentifierArgsDict',
    'InfrastructureV2ImageRegistryArgs',
    'InfrastructureV2ImageRegistryArgsDict',
    'InfrastructureV2ImageRegistryCustomImageArgs',
    'InfrastructureV2ImageRegistryCustomImageArgsDict',
    'InfrastructureV2ImageRegistryIdentifierArgs',
    'InfrastructureV2ImageRegistryIdentifierArgsDict',
    'InfrastructureV2MtlsArgs',
    'InfrastructureV2MtlsArgsDict',
    'InfrastructureV2ProxyArgs',
    'InfrastructureV2ProxyArgsDict',
    'InfrastructureV2TolerationArgs',
    'InfrastructureV2TolerationArgsDict',
    'InfrastructureV2VolumeArgs',
    'InfrastructureV2VolumeArgsDict',
    'InfrastructureV2VolumeMountArgs',
    'InfrastructureV2VolumeMountArgsDict',
    'SecurityGovernanceConditionFaultSpecArgs',
    'SecurityGovernanceConditionFaultSpecArgsDict',
    'SecurityGovernanceConditionFaultSpecFaultArgs',
    'SecurityGovernanceConditionFaultSpecFaultArgsDict',
    'SecurityGovernanceConditionK8sSpecArgs',
    'SecurityGovernanceConditionK8sSpecArgsDict',
    'SecurityGovernanceConditionK8sSpecApplicationSpecArgs',
    'SecurityGovernanceConditionK8sSpecApplicationSpecArgsDict',
    'SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs',
    'SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgsDict',
    'SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs',
    'SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgsDict',
    'SecurityGovernanceConditionK8sSpecInfraSpecArgs',
    'SecurityGovernanceConditionK8sSpecInfraSpecArgsDict',
    'SecurityGovernanceConditionMachineSpecArgs',
    'SecurityGovernanceConditionMachineSpecArgsDict',
    'SecurityGovernanceConditionMachineSpecInfraSpecArgs',
    'SecurityGovernanceConditionMachineSpecInfraSpecArgsDict',
    'SecurityGovernanceRuleTimeWindowArgs',
    'SecurityGovernanceRuleTimeWindowArgsDict',
    'SecurityGovernanceRuleTimeWindowRecurrenceArgs',
    'SecurityGovernanceRuleTimeWindowRecurrenceArgsDict',
    'GetInfrastructureV2ImageRegistryArgs',
    'GetInfrastructureV2ImageRegistryArgsDict',
    'GetInfrastructureV2ImageRegistryCustomImageArgs',
    'GetInfrastructureV2ImageRegistryCustomImageArgsDict',
    'GetInfrastructureV2ImageRegistryIdentifierArgs',
    'GetInfrastructureV2ImageRegistryIdentifierArgsDict',
    'GetInfrastructureV2MtlsArgs',
    'GetInfrastructureV2MtlsArgsDict',
    'GetInfrastructureV2ProxyArgs',
    'GetInfrastructureV2ProxyArgsDict',
    'GetInfrastructureV2TolerationArgs',
    'GetInfrastructureV2TolerationArgsDict',
    'GetInfrastructureV2VolumeArgs',
    'GetInfrastructureV2VolumeArgsDict',
    'GetInfrastructureV2VolumeMountArgs',
    'GetInfrastructureV2VolumeMountArgsDict',
]

MYPY = False

if not MYPY:
    class ImageRegistryCustomImageArgsDict(TypedDict):
        ddcr: NotRequired[pulumi.Input[_builtins.str]]
        ddcr_fault: NotRequired[pulumi.Input[_builtins.str]]
        ddcr_lib: NotRequired[pulumi.Input[_builtins.str]]
        log_watcher: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ImageRegistryCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ImageRegistryCustomImageArgs:
    def __init__(__self__, *,
                 ddcr: Optional[pulumi.Input[_builtins.str]] = None,
                 ddcr_fault: Optional[pulumi.Input[_builtins.str]] = None,
                 ddcr_lib: Optional[pulumi.Input[_builtins.str]] = None,
                 log_watcher: Optional[pulumi.Input[_builtins.str]] = None):
        if ddcr is not None:
            pulumi.set(__self__, "ddcr", ddcr)
        if ddcr_fault is not None:
            pulumi.set(__self__, "ddcr_fault", ddcr_fault)
        if ddcr_lib is not None:
            pulumi.set(__self__, "ddcr_lib", ddcr_lib)
        if log_watcher is not None:
            pulumi.set(__self__, "log_watcher", log_watcher)

    @_builtins.property
    @pulumi.getter
    def ddcr(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ddcr")

    @ddcr.setter
    def ddcr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddcr", value)

    @_builtins.property
    @pulumi.getter(name="ddcrFault")
    def ddcr_fault(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ddcr_fault")

    @ddcr_fault.setter
    def ddcr_fault(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddcr_fault", value)

    @_builtins.property
    @pulumi.getter(name="ddcrLib")
    def ddcr_lib(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ddcr_lib")

    @ddcr_lib.setter
    def ddcr_lib(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddcr_lib", value)

    @_builtins.property
    @pulumi.getter(name="logWatcher")
    def log_watcher(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "log_watcher")

    @log_watcher.setter
    def log_watcher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_watcher", value)


if not MYPY:
    class InfrastructureV2EnvArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Variable name from a ConfigMap or Secret. Required when value_from is configMapKeyRef or secretKeyRef.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Variable references $(VAR*NAME) are expanded using the container's environment. If the variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        value_from: NotRequired[pulumi.Input[_builtins.str]]
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
elif False:
    InfrastructureV2EnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2EnvArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 value_from: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the environment variable. Must be a C_IDENTIFIER.
        :param pulumi.Input[_builtins.str] key: Variable name from a ConfigMap or Secret. Required when value_from is configMapKeyRef or secretKeyRef.
        :param pulumi.Input[_builtins.str] value: Variable references $(VAR*NAME) are expanded using the container's environment. If the variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        :param pulumi.Input[_builtins.str] value_from: Source for the environment variable's value. Cannot be used if value is not empty.
        """
        pulumi.set(__self__, "name", name)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_from is not None:
            pulumi.set(__self__, "value_from", value_from)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the environment variable. Must be a C_IDENTIFIER.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Variable name from a ConfigMap or Secret. Required when value_from is configMapKeyRef or secretKeyRef.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Variable references $(VAR*NAME) are expanded using the container's environment. If the variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR*NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="valueFrom")
    def value_from(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Source for the environment variable's value. Cannot be used if value is not empty.
        """
        return pulumi.get(self, "value_from")

    @value_from.setter
    def value_from(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value_from", value)


if not MYPY:
    class InfrastructureV2IdentifierArgsDict(TypedDict):
        account_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Account identifier.
        """
        org_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization identifier.
        """
        project_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project identifier.
        """
elif False:
    InfrastructureV2IdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2IdentifierArgs:
    def __init__(__self__, *,
                 account_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 org_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 project_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_identifier: Account identifier.
        :param pulumi.Input[_builtins.str] org_identifier: Organization identifier.
        :param pulumi.Input[_builtins.str] project_identifier: Project identifier.
        """
        if account_identifier is not None:
            pulumi.set(__self__, "account_identifier", account_identifier)
        if org_identifier is not None:
            pulumi.set(__self__, "org_identifier", org_identifier)
        if project_identifier is not None:
            pulumi.set(__self__, "project_identifier", project_identifier)

    @_builtins.property
    @pulumi.getter(name="accountIdentifier")
    def account_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Account identifier.
        """
        return pulumi.get(self, "account_identifier")

    @account_identifier.setter
    def account_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_identifier", value)

    @_builtins.property
    @pulumi.getter(name="orgIdentifier")
    def org_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization identifier.
        """
        return pulumi.get(self, "org_identifier")

    @org_identifier.setter
    def org_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "org_identifier", value)

    @_builtins.property
    @pulumi.getter(name="projectIdentifier")
    def project_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project identifier.
        """
        return pulumi.get(self, "project_identifier")

    @project_identifier.setter
    def project_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_identifier", value)


if not MYPY:
    class InfrastructureV2ImageRegistryArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the registry was created.
        """
        custom_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryCustomImageArgsDict']]]]
        """
        Custom image configurations. Required when use*custom*images is true.
        """
        identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryIdentifierArgsDict']]]]
        """
        Scoped identifiers for the registry.
        """
        infra_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the infrastructure.
        """
        is_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this is the default registry.
        """
        is_override_allowed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether override is allowed for this registry.
        """
        is_private: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the registry is private.
        """
        registry_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        The account name for the container registry.
        """
        registry_server: NotRequired[pulumi.Input[_builtins.str]]
        """
        The container image registry server URL (e.g., docker.io, gcr.io).
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Kubernetes secret containing registry credentials.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the registry was last updated.
        """
        use_custom_images: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use custom images instead of default ones.
        """
elif False:
    InfrastructureV2ImageRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2ImageRegistryArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_images: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryCustomImageArgs']]]] = None,
                 identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryIdentifierArgs']]]] = None,
                 infra_id: Optional[pulumi.Input[_builtins.str]] = None,
                 is_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_override_allowed: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_private: Optional[pulumi.Input[_builtins.bool]] = None,
                 registry_account: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_server: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 use_custom_images: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the registry was created.
        :param pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryCustomImageArgs']]] custom_images: Custom image configurations. Required when use*custom*images is true.
        :param pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryIdentifierArgs']]] identifiers: Scoped identifiers for the registry.
        :param pulumi.Input[_builtins.str] infra_id: ID of the infrastructure.
        :param pulumi.Input[_builtins.bool] is_default: Whether this is the default registry.
        :param pulumi.Input[_builtins.bool] is_override_allowed: Whether override is allowed for this registry.
        :param pulumi.Input[_builtins.bool] is_private: Whether the registry is private.
        :param pulumi.Input[_builtins.str] registry_account: The account name for the container registry.
        :param pulumi.Input[_builtins.str] registry_server: The container image registry server URL (e.g., docker.io, gcr.io).
        :param pulumi.Input[_builtins.str] secret_name: Name of the Kubernetes secret containing registry credentials.
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the registry was last updated.
        :param pulumi.Input[_builtins.bool] use_custom_images: Whether to use custom images instead of default ones.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if custom_images is not None:
            pulumi.set(__self__, "custom_images", custom_images)
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)
        if infra_id is not None:
            pulumi.set(__self__, "infra_id", infra_id)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if is_override_allowed is not None:
            pulumi.set(__self__, "is_override_allowed", is_override_allowed)
        if is_private is not None:
            pulumi.set(__self__, "is_private", is_private)
        if registry_account is not None:
            pulumi.set(__self__, "registry_account", registry_account)
        if registry_server is not None:
            pulumi.set(__self__, "registry_server", registry_server)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if use_custom_images is not None:
            pulumi.set(__self__, "use_custom_images", use_custom_images)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the registry was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryCustomImageArgs']]]]:
        """
        Custom image configurations. Required when use*custom*images is true.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryCustomImageArgs']]]]):
        pulumi.set(self, "custom_images", value)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryIdentifierArgs']]]]:
        """
        Scoped identifiers for the registry.
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureV2ImageRegistryIdentifierArgs']]]]):
        pulumi.set(self, "identifiers", value)

    @_builtins.property
    @pulumi.getter(name="infraId")
    def infra_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the infrastructure.
        """
        return pulumi.get(self, "infra_id")

    @infra_id.setter
    def infra_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "infra_id", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this is the default registry.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter(name="isOverrideAllowed")
    def is_override_allowed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether override is allowed for this registry.
        """
        return pulumi.get(self, "is_override_allowed")

    @is_override_allowed.setter
    def is_override_allowed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_override_allowed", value)

    @_builtins.property
    @pulumi.getter(name="isPrivate")
    def is_private(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the registry is private.
        """
        return pulumi.get(self, "is_private")

    @is_private.setter
    def is_private(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_private", value)

    @_builtins.property
    @pulumi.getter(name="registryAccount")
    def registry_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The account name for the container registry.
        """
        return pulumi.get(self, "registry_account")

    @registry_account.setter
    def registry_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_account", value)

    @_builtins.property
    @pulumi.getter(name="registryServer")
    def registry_server(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The container image registry server URL (e.g., docker.io, gcr.io).
        """
        return pulumi.get(self, "registry_server")

    @registry_server.setter
    def registry_server(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_server", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Kubernetes secret containing registry credentials.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the registry was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="useCustomImages")
    def use_custom_images(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use custom images instead of default ones.
        """
        return pulumi.get(self, "use_custom_images")

    @use_custom_images.setter
    def use_custom_images(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_custom_images", value)


if not MYPY:
    class InfrastructureV2ImageRegistryCustomImageArgsDict(TypedDict):
        ddcr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom image for ddcr.
        """
        ddcr_fault: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom image for ddcr-fault.
        """
        ddcr_lib: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom image for ddcr-lib.
        """
        log_watcher: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom image for log-watcher.
        """
elif False:
    InfrastructureV2ImageRegistryCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2ImageRegistryCustomImageArgs:
    def __init__(__self__, *,
                 ddcr: Optional[pulumi.Input[_builtins.str]] = None,
                 ddcr_fault: Optional[pulumi.Input[_builtins.str]] = None,
                 ddcr_lib: Optional[pulumi.Input[_builtins.str]] = None,
                 log_watcher: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ddcr: Custom image for ddcr.
        :param pulumi.Input[_builtins.str] ddcr_fault: Custom image for ddcr-fault.
        :param pulumi.Input[_builtins.str] ddcr_lib: Custom image for ddcr-lib.
        :param pulumi.Input[_builtins.str] log_watcher: Custom image for log-watcher.
        """
        if ddcr is not None:
            pulumi.set(__self__, "ddcr", ddcr)
        if ddcr_fault is not None:
            pulumi.set(__self__, "ddcr_fault", ddcr_fault)
        if ddcr_lib is not None:
            pulumi.set(__self__, "ddcr_lib", ddcr_lib)
        if log_watcher is not None:
            pulumi.set(__self__, "log_watcher", log_watcher)

    @_builtins.property
    @pulumi.getter
    def ddcr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom image for ddcr.
        """
        return pulumi.get(self, "ddcr")

    @ddcr.setter
    def ddcr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddcr", value)

    @_builtins.property
    @pulumi.getter(name="ddcrFault")
    def ddcr_fault(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom image for ddcr-fault.
        """
        return pulumi.get(self, "ddcr_fault")

    @ddcr_fault.setter
    def ddcr_fault(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddcr_fault", value)

    @_builtins.property
    @pulumi.getter(name="ddcrLib")
    def ddcr_lib(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom image for ddcr-lib.
        """
        return pulumi.get(self, "ddcr_lib")

    @ddcr_lib.setter
    def ddcr_lib(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ddcr_lib", value)

    @_builtins.property
    @pulumi.getter(name="logWatcher")
    def log_watcher(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom image for log-watcher.
        """
        return pulumi.get(self, "log_watcher")

    @log_watcher.setter
    def log_watcher(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_watcher", value)


if not MYPY:
    class InfrastructureV2ImageRegistryIdentifierArgsDict(TypedDict):
        account_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Harness account identifier.
        """
        org_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Harness organization identifier.
        """
        project_identifier: NotRequired[pulumi.Input[_builtins.str]]
        """
        Harness project identifier.
        """
elif False:
    InfrastructureV2ImageRegistryIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2ImageRegistryIdentifierArgs:
    def __init__(__self__, *,
                 account_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 org_identifier: Optional[pulumi.Input[_builtins.str]] = None,
                 project_identifier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_identifier: Harness account identifier.
        :param pulumi.Input[_builtins.str] org_identifier: Harness organization identifier.
        :param pulumi.Input[_builtins.str] project_identifier: Harness project identifier.
        """
        if account_identifier is not None:
            pulumi.set(__self__, "account_identifier", account_identifier)
        if org_identifier is not None:
            pulumi.set(__self__, "org_identifier", org_identifier)
        if project_identifier is not None:
            pulumi.set(__self__, "project_identifier", project_identifier)

    @_builtins.property
    @pulumi.getter(name="accountIdentifier")
    def account_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Harness account identifier.
        """
        return pulumi.get(self, "account_identifier")

    @account_identifier.setter
    def account_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_identifier", value)

    @_builtins.property
    @pulumi.getter(name="orgIdentifier")
    def org_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Harness organization identifier.
        """
        return pulumi.get(self, "org_identifier")

    @org_identifier.setter
    def org_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "org_identifier", value)

    @_builtins.property
    @pulumi.getter(name="projectIdentifier")
    def project_identifier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Harness project identifier.
        """
        return pulumi.get(self, "project_identifier")

    @project_identifier.setter
    def project_identifier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_identifier", value)


if not MYPY:
    class InfrastructureV2MtlsArgsDict(TypedDict):
        cert_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the certificate file for mTLS
        """
        key_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path to the private key file for mTLS
        """
        secret_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Kubernetes secret containing mTLS certificates
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL for the mTLS endpoint
        """
elif False:
    InfrastructureV2MtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2MtlsArgs:
    def __init__(__self__, *,
                 cert_path: Optional[pulumi.Input[_builtins.str]] = None,
                 key_path: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert_path: Path to the certificate file for mTLS
        :param pulumi.Input[_builtins.str] key_path: Path to the private key file for mTLS
        :param pulumi.Input[_builtins.str] secret_name: Name of the Kubernetes secret containing mTLS certificates
        :param pulumi.Input[_builtins.str] url: URL for the mTLS endpoint
        """
        if cert_path is not None:
            pulumi.set(__self__, "cert_path", cert_path)
        if key_path is not None:
            pulumi.set(__self__, "key_path", key_path)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="certPath")
    def cert_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the certificate file for mTLS
        """
        return pulumi.get(self, "cert_path")

    @cert_path.setter
    def cert_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_path", value)

    @_builtins.property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path to the private key file for mTLS
        """
        return pulumi.get(self, "key_path")

    @key_path.setter
    def key_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_path", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Kubernetes secret containing mTLS certificates
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL for the mTLS endpoint
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class InfrastructureV2ProxyArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        Proxy URL.
        """
        http_proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP proxy URL.
        """
        https_proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTPS proxy URL.
        """
        no_proxy: NotRequired[pulumi.Input[_builtins.str]]
        """
        List of hosts that should not use proxy.
        """
elif False:
    InfrastructureV2ProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2ProxyArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 http_proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 https_proxy: Optional[pulumi.Input[_builtins.str]] = None,
                 no_proxy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Proxy URL.
        :param pulumi.Input[_builtins.str] http_proxy: HTTP proxy URL.
        :param pulumi.Input[_builtins.str] https_proxy: HTTPS proxy URL.
        :param pulumi.Input[_builtins.str] no_proxy: List of hosts that should not use proxy.
        """
        pulumi.set(__self__, "url", url)
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Proxy URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP proxy URL.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_proxy", value)

    @_builtins.property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTPS proxy URL.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "https_proxy", value)

    @_builtins.property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        List of hosts that should not use proxy.
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_proxy", value)


if not MYPY:
    class InfrastructureV2TolerationArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        Effect indicates the taint effect to match. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        key: pulumi.Input[_builtins.str]
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists.
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal.
        """
        toleration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
elif False:
    InfrastructureV2TolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2TolerationArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 operator: pulumi.Input[_builtins.str],
                 toleration_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effect: Effect indicates the taint effect to match. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param pulumi.Input[_builtins.str] key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists.
        :param pulumi.Input[_builtins.str] operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal.
        :param pulumi.Input[_builtins.int] toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param pulumi.Input[_builtins.str] value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        Effect indicates the taint effect to match. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "toleration_seconds", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InfrastructureV2VolumeArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the volume. Must be a DNS_LABEL and unique within the pod.
        """
        size_limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Size limit of the volume. Example: '10Gi', '100Mi'
        """
elif False:
    InfrastructureV2VolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2VolumeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 size_limit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the volume. Must be a DNS_LABEL and unique within the pod.
        :param pulumi.Input[_builtins.str] size_limit: Size limit of the volume. Example: '10Gi', '100Mi'
        """
        pulumi.set(__self__, "name", name)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the volume. Must be a DNS_LABEL and unique within the pod.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Size limit of the volume. Example: '10Gi', '100Mi'
        """
        return pulumi.get(self, "size_limit")

    @size_limit.setter
    def size_limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "size_limit", value)


if not MYPY:
    class InfrastructureV2VolumeMountArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        name: pulumi.Input[_builtins.str]
        """
        This must match the Name of a Volume.
        """
        mount_propagation: NotRequired[pulumi.Input[_builtins.str]]
        """
        Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.
        """
        read_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Mounted read-only if true, read-write otherwise.
        """
        sub_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path within the volume from which the container's volume should be mounted. Mutually exclusive with sub*path*expr.
        """
        sub_path_expr: NotRequired[pulumi.Input[_builtins.str]]
        """
        Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to sub*path but environment variable references $(VAR*NAME) are expanded using the container's environment. Mutually exclusive with sub_path.
        """
elif False:
    InfrastructureV2VolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureV2VolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 mount_propagation: Optional[pulumi.Input[_builtins.str]] = None,
                 read_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 sub_path: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_path_expr: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param pulumi.Input[_builtins.str] name: This must match the Name of a Volume.
        :param pulumi.Input[_builtins.str] mount_propagation: Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.
        :param pulumi.Input[_builtins.bool] read_only: Mounted read-only if true, read-write otherwise.
        :param pulumi.Input[_builtins.str] sub_path: Path within the volume from which the container's volume should be mounted. Mutually exclusive with sub*path*expr.
        :param pulumi.Input[_builtins.str] sub_path_expr: Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to sub*path but environment variable references $(VAR*NAME) are expanded using the container's environment. Mutually exclusive with sub_path.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.
        """
        return pulumi.get(self, "mount_propagation")

    @mount_propagation.setter
    def mount_propagation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount_propagation", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Mounted read-only if true, read-write otherwise.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path within the volume from which the container's volume should be mounted. Mutually exclusive with sub*path*expr.
        """
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path", value)

    @_builtins.property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to sub*path but environment variable references $(VAR*NAME) are expanded using the container's environment. Mutually exclusive with sub_path.
        """
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_path_expr", value)


if not MYPY:
    class SecurityGovernanceConditionFaultSpecArgsDict(TypedDict):
        faults: pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionFaultSpecFaultArgsDict']]]
        """
        List of fault specifications
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator for comparing faults (EQUAL*TO or NOT*EQUAL_TO)
        """
elif False:
    SecurityGovernanceConditionFaultSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionFaultSpecArgs:
    def __init__(__self__, *,
                 faults: pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionFaultSpecFaultArgs']]],
                 operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionFaultSpecFaultArgs']]] faults: List of fault specifications
        :param pulumi.Input[_builtins.str] operator: Operator for comparing faults (EQUAL*TO or NOT*EQUAL_TO)
        """
        pulumi.set(__self__, "faults", faults)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter
    def faults(self) -> pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionFaultSpecFaultArgs']]]:
        """
        List of fault specifications
        """
        return pulumi.get(self, "faults")

    @faults.setter
    def faults(self, value: pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionFaultSpecFaultArgs']]]):
        pulumi.set(self, "faults", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for comparing faults (EQUAL*TO or NOT*EQUAL_TO)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class SecurityGovernanceConditionFaultSpecFaultArgsDict(TypedDict):
        fault_type: pulumi.Input[_builtins.str]
        """
        Type of the fault (FAULT or FAULT_GROUP)
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the fault
        """
elif False:
    SecurityGovernanceConditionFaultSpecFaultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionFaultSpecFaultArgs:
    def __init__(__self__, *,
                 fault_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] fault_type: Type of the fault (FAULT or FAULT_GROUP)
        :param pulumi.Input[_builtins.str] name: Name of the fault
        """
        pulumi.set(__self__, "fault_type", fault_type)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="faultType")
    def fault_type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of the fault (FAULT or FAULT_GROUP)
        """
        return pulumi.get(self, "fault_type")

    @fault_type.setter
    def fault_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fault_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the fault
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class SecurityGovernanceConditionK8sSpecArgsDict(TypedDict):
        application_spec: NotRequired[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecArgsDict']]
        """
        Application specification
        """
        chaos_service_account_spec: NotRequired[pulumi.Input['SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgsDict']]
        """
        Chaos service account specification
        """
        infra_spec: NotRequired[pulumi.Input['SecurityGovernanceConditionK8sSpecInfraSpecArgsDict']]
        """
        Infrastructure specification
        """
elif False:
    SecurityGovernanceConditionK8sSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionK8sSpecArgs:
    def __init__(__self__, *,
                 application_spec: Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecArgs']] = None,
                 chaos_service_account_spec: Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs']] = None,
                 infra_spec: Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecInfraSpecArgs']] = None):
        """
        :param pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecArgs'] application_spec: Application specification
        :param pulumi.Input['SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs'] chaos_service_account_spec: Chaos service account specification
        :param pulumi.Input['SecurityGovernanceConditionK8sSpecInfraSpecArgs'] infra_spec: Infrastructure specification
        """
        if application_spec is not None:
            pulumi.set(__self__, "application_spec", application_spec)
        if chaos_service_account_spec is not None:
            pulumi.set(__self__, "chaos_service_account_spec", chaos_service_account_spec)
        if infra_spec is not None:
            pulumi.set(__self__, "infra_spec", infra_spec)

    @_builtins.property
    @pulumi.getter(name="applicationSpec")
    def application_spec(self) -> Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecArgs']]:
        """
        Application specification
        """
        return pulumi.get(self, "application_spec")

    @application_spec.setter
    def application_spec(self, value: Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecArgs']]):
        pulumi.set(self, "application_spec", value)

    @_builtins.property
    @pulumi.getter(name="chaosServiceAccountSpec")
    def chaos_service_account_spec(self) -> Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs']]:
        """
        Chaos service account specification
        """
        return pulumi.get(self, "chaos_service_account_spec")

    @chaos_service_account_spec.setter
    def chaos_service_account_spec(self, value: Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs']]):
        pulumi.set(self, "chaos_service_account_spec", value)

    @_builtins.property
    @pulumi.getter(name="infraSpec")
    def infra_spec(self) -> Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecInfraSpecArgs']]:
        """
        Infrastructure specification
        """
        return pulumi.get(self, "infra_spec")

    @infra_spec.setter
    def infra_spec(self, value: Optional[pulumi.Input['SecurityGovernanceConditionK8sSpecInfraSpecArgs']]):
        pulumi.set(self, "infra_spec", value)


if not MYPY:
    class SecurityGovernanceConditionK8sSpecApplicationSpecArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        Operator for application matching (EQUAL*TO or NOT*EQUAL_TO)
        """
        workloads: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgsDict']]]]
        """
        List of workloads to include/exclude
        """
elif False:
    SecurityGovernanceConditionK8sSpecApplicationSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionK8sSpecApplicationSpecArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 workloads: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: Operator for application matching (EQUAL*TO or NOT*EQUAL_TO)
        :param pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs']]] workloads: List of workloads to include/exclude
        """
        pulumi.set(__self__, "operator", operator)
        if workloads is not None:
            pulumi.set(__self__, "workloads", workloads)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for application matching (EQUAL*TO or NOT*EQUAL_TO)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def workloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs']]]]:
        """
        List of workloads to include/exclude
        """
        return pulumi.get(self, "workloads")

    @workloads.setter
    def workloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs']]]]):
        pulumi.set(self, "workloads", value)


if not MYPY:
    class SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgsDict(TypedDict):
        namespace: pulumi.Input[_builtins.str]
        """
        Namespace of the workload
        """
        application_map_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID for the application map
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind of the workload (e.g., deployment, statefulset)
        """
        label: NotRequired[pulumi.Input[_builtins.str]]
        """
        Label selector for the workload
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of services associated with the workload
        """
elif False:
    SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionK8sSpecApplicationSpecWorkloadArgs:
    def __init__(__self__, *,
                 namespace: pulumi.Input[_builtins.str],
                 application_map_id: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 label: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] namespace: Namespace of the workload
        :param pulumi.Input[_builtins.str] application_map_id: ID for the application map
        :param pulumi.Input[_builtins.str] kind: Kind of the workload (e.g., deployment, statefulset)
        :param pulumi.Input[_builtins.str] label: Label selector for the workload
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] services: List of services associated with the workload
        """
        pulumi.set(__self__, "namespace", namespace)
        if application_map_id is not None:
            pulumi.set(__self__, "application_map_id", application_map_id)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if services is not None:
            pulumi.set(__self__, "services", services)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[_builtins.str]:
        """
        Namespace of the workload
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="applicationMapId")
    def application_map_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID for the application map
        """
        return pulumi.get(self, "application_map_id")

    @application_map_id.setter
    def application_map_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "application_map_id", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind of the workload (e.g., deployment, statefulset)
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Label selector for the workload
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "label", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of services associated with the workload
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "services", value)


if not MYPY:
    class SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        Operator for service account matching (EQUAL*TO or NOT*EQUAL_TO)
        """
        service_accounts: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of service accounts to include/exclude
        """
elif False:
    SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionK8sSpecChaosServiceAccountSpecArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 service_accounts: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[_builtins.str] operator: Operator for service account matching (EQUAL*TO or NOT*EQUAL_TO)
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] service_accounts: List of service accounts to include/exclude
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "service_accounts", service_accounts)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for service account matching (EQUAL*TO or NOT*EQUAL_TO)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of service accounts to include/exclude
        """
        return pulumi.get(self, "service_accounts")

    @service_accounts.setter
    def service_accounts(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "service_accounts", value)


if not MYPY:
    class SecurityGovernanceConditionK8sSpecInfraSpecArgsDict(TypedDict):
        infra_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of infrastructure IDs to apply the condition to
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator for comparing infrastructure IDs (EQUAL*TO or NOT*EQUAL_TO)
        """
elif False:
    SecurityGovernanceConditionK8sSpecInfraSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionK8sSpecInfraSpecArgs:
    def __init__(__self__, *,
                 infra_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] infra_ids: List of infrastructure IDs to apply the condition to
        :param pulumi.Input[_builtins.str] operator: Operator for comparing infrastructure IDs (EQUAL*TO or NOT*EQUAL_TO)
        """
        pulumi.set(__self__, "infra_ids", infra_ids)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="infraIds")
    def infra_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of infrastructure IDs to apply the condition to
        """
        return pulumi.get(self, "infra_ids")

    @infra_ids.setter
    def infra_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "infra_ids", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for comparing infrastructure IDs (EQUAL*TO or NOT*EQUAL_TO)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class SecurityGovernanceConditionMachineSpecArgsDict(TypedDict):
        infra_spec: NotRequired[pulumi.Input['SecurityGovernanceConditionMachineSpecInfraSpecArgsDict']]
        """
        Infrastructure specification
        """
elif False:
    SecurityGovernanceConditionMachineSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionMachineSpecArgs:
    def __init__(__self__, *,
                 infra_spec: Optional[pulumi.Input['SecurityGovernanceConditionMachineSpecInfraSpecArgs']] = None):
        """
        :param pulumi.Input['SecurityGovernanceConditionMachineSpecInfraSpecArgs'] infra_spec: Infrastructure specification
        """
        if infra_spec is not None:
            pulumi.set(__self__, "infra_spec", infra_spec)

    @_builtins.property
    @pulumi.getter(name="infraSpec")
    def infra_spec(self) -> Optional[pulumi.Input['SecurityGovernanceConditionMachineSpecInfraSpecArgs']]:
        """
        Infrastructure specification
        """
        return pulumi.get(self, "infra_spec")

    @infra_spec.setter
    def infra_spec(self, value: Optional[pulumi.Input['SecurityGovernanceConditionMachineSpecInfraSpecArgs']]):
        pulumi.set(self, "infra_spec", value)


if not MYPY:
    class SecurityGovernanceConditionMachineSpecInfraSpecArgsDict(TypedDict):
        infra_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of infrastructure IDs to apply the condition to
        """
        operator: pulumi.Input[_builtins.str]
        """
        Operator for comparing infrastructure IDs (EQUAL*TO or NOT*EQUAL_TO)
        """
elif False:
    SecurityGovernanceConditionMachineSpecInfraSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceConditionMachineSpecInfraSpecArgs:
    def __init__(__self__, *,
                 infra_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 operator: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] infra_ids: List of infrastructure IDs to apply the condition to
        :param pulumi.Input[_builtins.str] operator: Operator for comparing infrastructure IDs (EQUAL*TO or NOT*EQUAL_TO)
        """
        pulumi.set(__self__, "infra_ids", infra_ids)
        pulumi.set(__self__, "operator", operator)

    @_builtins.property
    @pulumi.getter(name="infraIds")
    def infra_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of infrastructure IDs to apply the condition to
        """
        return pulumi.get(self, "infra_ids")

    @infra_ids.setter
    def infra_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "infra_ids", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        Operator for comparing infrastructure IDs (EQUAL*TO or NOT*EQUAL_TO)
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)


if not MYPY:
    class SecurityGovernanceRuleTimeWindowArgsDict(TypedDict):
        start_time: pulumi.Input[_builtins.int]
        time_zone: pulumi.Input[_builtins.str]
        duration: NotRequired[pulumi.Input[_builtins.str]]
        end_time: NotRequired[pulumi.Input[_builtins.int]]
        recurrence: NotRequired[pulumi.Input['SecurityGovernanceRuleTimeWindowRecurrenceArgsDict']]
elif False:
    SecurityGovernanceRuleTimeWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceRuleTimeWindowArgs:
    def __init__(__self__, *,
                 start_time: pulumi.Input[_builtins.int],
                 time_zone: pulumi.Input[_builtins.str],
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 end_time: Optional[pulumi.Input[_builtins.int]] = None,
                 recurrence: Optional[pulumi.Input['SecurityGovernanceRuleTimeWindowRecurrenceArgs']] = None):
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrence is not None:
            pulumi.set(__self__, "recurrence", recurrence)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "start_time", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter
    def recurrence(self) -> Optional[pulumi.Input['SecurityGovernanceRuleTimeWindowRecurrenceArgs']]:
        return pulumi.get(self, "recurrence")

    @recurrence.setter
    def recurrence(self, value: Optional[pulumi.Input['SecurityGovernanceRuleTimeWindowRecurrenceArgs']]):
        pulumi.set(self, "recurrence", value)


if not MYPY:
    class SecurityGovernanceRuleTimeWindowRecurrenceArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        until: pulumi.Input[_builtins.int]
        value: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    SecurityGovernanceRuleTimeWindowRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityGovernanceRuleTimeWindowRecurrenceArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 until: pulumi.Input[_builtins.int],
                 value: Optional[pulumi.Input[_builtins.int]] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "until", until)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def until(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "until")

    @until.setter
    def until(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "until", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetInfrastructureV2ImageRegistryArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Timestamp when the registry was created.
        """
        custom_images: Sequence['GetInfrastructureV2ImageRegistryCustomImageArgsDict']
        """
        Custom image configurations. Required when use*custom*images is true.
        """
        identifiers: Sequence['GetInfrastructureV2ImageRegistryIdentifierArgsDict']
        """
        Scoped identifiers for the registry.
        """
        infra_id: _builtins.str
        """
        ID of the infrastructure.
        """
        is_default: _builtins.bool
        """
        Whether this is the default registry.
        """
        is_override_allowed: _builtins.bool
        """
        Whether override is allowed for this registry.
        """
        is_private: _builtins.bool
        """
        Whether the registry is private.
        """
        registry_account: _builtins.str
        """
        The account name for the container registry.
        """
        registry_server: _builtins.str
        """
        The container image registry server URL (e.g., docker.io, gcr.io).
        """
        updated_at: _builtins.str
        """
        Timestamp when the registry was last updated.
        """
        use_custom_images: _builtins.bool
        """
        Whether to use custom images instead of default ones.
        """
        secret_name: NotRequired[_builtins.str]
        """
        Name of the Kubernetes secret containing registry credentials.
        """
elif False:
    GetInfrastructureV2ImageRegistryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2ImageRegistryArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 custom_images: Sequence['GetInfrastructureV2ImageRegistryCustomImageArgs'],
                 identifiers: Sequence['GetInfrastructureV2ImageRegistryIdentifierArgs'],
                 infra_id: _builtins.str,
                 is_default: _builtins.bool,
                 is_override_allowed: _builtins.bool,
                 is_private: _builtins.bool,
                 registry_account: _builtins.str,
                 registry_server: _builtins.str,
                 updated_at: _builtins.str,
                 use_custom_images: _builtins.bool,
                 secret_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the registry was created.
        :param Sequence['GetInfrastructureV2ImageRegistryCustomImageArgs'] custom_images: Custom image configurations. Required when use*custom*images is true.
        :param Sequence['GetInfrastructureV2ImageRegistryIdentifierArgs'] identifiers: Scoped identifiers for the registry.
        :param _builtins.str infra_id: ID of the infrastructure.
        :param _builtins.bool is_default: Whether this is the default registry.
        :param _builtins.bool is_override_allowed: Whether override is allowed for this registry.
        :param _builtins.bool is_private: Whether the registry is private.
        :param _builtins.str registry_account: The account name for the container registry.
        :param _builtins.str registry_server: The container image registry server URL (e.g., docker.io, gcr.io).
        :param _builtins.str updated_at: Timestamp when the registry was last updated.
        :param _builtins.bool use_custom_images: Whether to use custom images instead of default ones.
        :param _builtins.str secret_name: Name of the Kubernetes secret containing registry credentials.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "custom_images", custom_images)
        pulumi.set(__self__, "identifiers", identifiers)
        pulumi.set(__self__, "infra_id", infra_id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "is_override_allowed", is_override_allowed)
        pulumi.set(__self__, "is_private", is_private)
        pulumi.set(__self__, "registry_account", registry_account)
        pulumi.set(__self__, "registry_server", registry_server)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "use_custom_images", use_custom_images)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the registry was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="customImages")
    def custom_images(self) -> Sequence['GetInfrastructureV2ImageRegistryCustomImageArgs']:
        """
        Custom image configurations. Required when use*custom*images is true.
        """
        return pulumi.get(self, "custom_images")

    @custom_images.setter
    def custom_images(self, value: Sequence['GetInfrastructureV2ImageRegistryCustomImageArgs']):
        pulumi.set(self, "custom_images", value)

    @_builtins.property
    @pulumi.getter
    def identifiers(self) -> Sequence['GetInfrastructureV2ImageRegistryIdentifierArgs']:
        """
        Scoped identifiers for the registry.
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Sequence['GetInfrastructureV2ImageRegistryIdentifierArgs']):
        pulumi.set(self, "identifiers", value)

    @_builtins.property
    @pulumi.getter(name="infraId")
    def infra_id(self) -> _builtins.str:
        """
        ID of the infrastructure.
        """
        return pulumi.get(self, "infra_id")

    @infra_id.setter
    def infra_id(self, value: _builtins.str):
        pulumi.set(self, "infra_id", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        """
        Whether this is the default registry.
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: _builtins.bool):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter(name="isOverrideAllowed")
    def is_override_allowed(self) -> _builtins.bool:
        """
        Whether override is allowed for this registry.
        """
        return pulumi.get(self, "is_override_allowed")

    @is_override_allowed.setter
    def is_override_allowed(self, value: _builtins.bool):
        pulumi.set(self, "is_override_allowed", value)

    @_builtins.property
    @pulumi.getter(name="isPrivate")
    def is_private(self) -> _builtins.bool:
        """
        Whether the registry is private.
        """
        return pulumi.get(self, "is_private")

    @is_private.setter
    def is_private(self, value: _builtins.bool):
        pulumi.set(self, "is_private", value)

    @_builtins.property
    @pulumi.getter(name="registryAccount")
    def registry_account(self) -> _builtins.str:
        """
        The account name for the container registry.
        """
        return pulumi.get(self, "registry_account")

    @registry_account.setter
    def registry_account(self, value: _builtins.str):
        pulumi.set(self, "registry_account", value)

    @_builtins.property
    @pulumi.getter(name="registryServer")
    def registry_server(self) -> _builtins.str:
        """
        The container image registry server URL (e.g., docker.io, gcr.io).
        """
        return pulumi.get(self, "registry_server")

    @registry_server.setter
    def registry_server(self, value: _builtins.str):
        pulumi.set(self, "registry_server", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the registry was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="useCustomImages")
    def use_custom_images(self) -> _builtins.bool:
        """
        Whether to use custom images instead of default ones.
        """
        return pulumi.get(self, "use_custom_images")

    @use_custom_images.setter
    def use_custom_images(self, value: _builtins.bool):
        pulumi.set(self, "use_custom_images", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[_builtins.str]:
        """
        Name of the Kubernetes secret containing registry credentials.
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "secret_name", value)


if not MYPY:
    class GetInfrastructureV2ImageRegistryCustomImageArgsDict(TypedDict):
        ddcr: _builtins.str
        """
        Custom image for ddcr.
        """
        ddcr_fault: _builtins.str
        """
        Custom image for ddcr-fault.
        """
        ddcr_lib: _builtins.str
        """
        Custom image for ddcr-lib.
        """
        log_watcher: _builtins.str
        """
        Custom image for log-watcher.
        """
elif False:
    GetInfrastructureV2ImageRegistryCustomImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2ImageRegistryCustomImageArgs:
    def __init__(__self__, *,
                 ddcr: _builtins.str,
                 ddcr_fault: _builtins.str,
                 ddcr_lib: _builtins.str,
                 log_watcher: _builtins.str):
        """
        :param _builtins.str ddcr: Custom image for ddcr.
        :param _builtins.str ddcr_fault: Custom image for ddcr-fault.
        :param _builtins.str ddcr_lib: Custom image for ddcr-lib.
        :param _builtins.str log_watcher: Custom image for log-watcher.
        """
        pulumi.set(__self__, "ddcr", ddcr)
        pulumi.set(__self__, "ddcr_fault", ddcr_fault)
        pulumi.set(__self__, "ddcr_lib", ddcr_lib)
        pulumi.set(__self__, "log_watcher", log_watcher)

    @_builtins.property
    @pulumi.getter
    def ddcr(self) -> _builtins.str:
        """
        Custom image for ddcr.
        """
        return pulumi.get(self, "ddcr")

    @ddcr.setter
    def ddcr(self, value: _builtins.str):
        pulumi.set(self, "ddcr", value)

    @_builtins.property
    @pulumi.getter(name="ddcrFault")
    def ddcr_fault(self) -> _builtins.str:
        """
        Custom image for ddcr-fault.
        """
        return pulumi.get(self, "ddcr_fault")

    @ddcr_fault.setter
    def ddcr_fault(self, value: _builtins.str):
        pulumi.set(self, "ddcr_fault", value)

    @_builtins.property
    @pulumi.getter(name="ddcrLib")
    def ddcr_lib(self) -> _builtins.str:
        """
        Custom image for ddcr-lib.
        """
        return pulumi.get(self, "ddcr_lib")

    @ddcr_lib.setter
    def ddcr_lib(self, value: _builtins.str):
        pulumi.set(self, "ddcr_lib", value)

    @_builtins.property
    @pulumi.getter(name="logWatcher")
    def log_watcher(self) -> _builtins.str:
        """
        Custom image for log-watcher.
        """
        return pulumi.get(self, "log_watcher")

    @log_watcher.setter
    def log_watcher(self, value: _builtins.str):
        pulumi.set(self, "log_watcher", value)


if not MYPY:
    class GetInfrastructureV2ImageRegistryIdentifierArgsDict(TypedDict):
        account_identifier: _builtins.str
        """
        Harness account identifier.
        """
        org_identifier: _builtins.str
        """
        Harness organization identifier.
        """
        project_identifier: _builtins.str
        """
        Harness project identifier.
        """
elif False:
    GetInfrastructureV2ImageRegistryIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2ImageRegistryIdentifierArgs:
    def __init__(__self__, *,
                 account_identifier: _builtins.str,
                 org_identifier: _builtins.str,
                 project_identifier: _builtins.str):
        """
        :param _builtins.str account_identifier: Harness account identifier.
        :param _builtins.str org_identifier: Harness organization identifier.
        :param _builtins.str project_identifier: Harness project identifier.
        """
        pulumi.set(__self__, "account_identifier", account_identifier)
        pulumi.set(__self__, "org_identifier", org_identifier)
        pulumi.set(__self__, "project_identifier", project_identifier)

    @_builtins.property
    @pulumi.getter(name="accountIdentifier")
    def account_identifier(self) -> _builtins.str:
        """
        Harness account identifier.
        """
        return pulumi.get(self, "account_identifier")

    @account_identifier.setter
    def account_identifier(self, value: _builtins.str):
        pulumi.set(self, "account_identifier", value)

    @_builtins.property
    @pulumi.getter(name="orgIdentifier")
    def org_identifier(self) -> _builtins.str:
        """
        Harness organization identifier.
        """
        return pulumi.get(self, "org_identifier")

    @org_identifier.setter
    def org_identifier(self, value: _builtins.str):
        pulumi.set(self, "org_identifier", value)

    @_builtins.property
    @pulumi.getter(name="projectIdentifier")
    def project_identifier(self) -> _builtins.str:
        """
        Harness project identifier.
        """
        return pulumi.get(self, "project_identifier")

    @project_identifier.setter
    def project_identifier(self, value: _builtins.str):
        pulumi.set(self, "project_identifier", value)


if not MYPY:
    class GetInfrastructureV2MtlsArgsDict(TypedDict):
        cert_path: NotRequired[_builtins.str]
        """
        Path to the certificate file for mTLS
        """
        key_path: NotRequired[_builtins.str]
        """
        Path to the private key file for mTLS
        """
        secret_name: NotRequired[_builtins.str]
        """
        Name of the Kubernetes secret containing mTLS certificates
        """
        url: NotRequired[_builtins.str]
        """
        URL for the mTLS endpoint
        """
elif False:
    GetInfrastructureV2MtlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2MtlsArgs:
    def __init__(__self__, *,
                 cert_path: Optional[_builtins.str] = None,
                 key_path: Optional[_builtins.str] = None,
                 secret_name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert_path: Path to the certificate file for mTLS
        :param _builtins.str key_path: Path to the private key file for mTLS
        :param _builtins.str secret_name: Name of the Kubernetes secret containing mTLS certificates
        :param _builtins.str url: URL for the mTLS endpoint
        """
        if cert_path is not None:
            pulumi.set(__self__, "cert_path", cert_path)
        if key_path is not None:
            pulumi.set(__self__, "key_path", key_path)
        if secret_name is not None:
            pulumi.set(__self__, "secret_name", secret_name)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="certPath")
    def cert_path(self) -> Optional[_builtins.str]:
        """
        Path to the certificate file for mTLS
        """
        return pulumi.get(self, "cert_path")

    @cert_path.setter
    def cert_path(self, value: Optional[_builtins.str]):
        pulumi.set(self, "cert_path", value)

    @_builtins.property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> Optional[_builtins.str]:
        """
        Path to the private key file for mTLS
        """
        return pulumi.get(self, "key_path")

    @key_path.setter
    def key_path(self, value: Optional[_builtins.str]):
        pulumi.set(self, "key_path", value)

    @_builtins.property
    @pulumi.getter(name="secretName")
    def secret_name(self) -> Optional[_builtins.str]:
        """
        Name of the Kubernetes secret containing mTLS certificates
        """
        return pulumi.get(self, "secret_name")

    @secret_name.setter
    def secret_name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "secret_name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL for the mTLS endpoint
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetInfrastructureV2ProxyArgsDict(TypedDict):
        url: _builtins.str
        """
        Proxy URL.
        """
        http_proxy: NotRequired[_builtins.str]
        """
        HTTP proxy URL.
        """
        https_proxy: NotRequired[_builtins.str]
        """
        HTTPS proxy URL.
        """
        no_proxy: NotRequired[_builtins.str]
        """
        List of hosts that should not use proxy.
        """
elif False:
    GetInfrastructureV2ProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2ProxyArgs:
    def __init__(__self__, *,
                 url: _builtins.str,
                 http_proxy: Optional[_builtins.str] = None,
                 https_proxy: Optional[_builtins.str] = None,
                 no_proxy: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Proxy URL.
        :param _builtins.str http_proxy: HTTP proxy URL.
        :param _builtins.str https_proxy: HTTPS proxy URL.
        :param _builtins.str no_proxy: List of hosts that should not use proxy.
        """
        pulumi.set(__self__, "url", url)
        if http_proxy is not None:
            pulumi.set(__self__, "http_proxy", http_proxy)
        if https_proxy is not None:
            pulumi.set(__self__, "https_proxy", https_proxy)
        if no_proxy is not None:
            pulumi.set(__self__, "no_proxy", no_proxy)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Proxy URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="httpProxy")
    def http_proxy(self) -> Optional[_builtins.str]:
        """
        HTTP proxy URL.
        """
        return pulumi.get(self, "http_proxy")

    @http_proxy.setter
    def http_proxy(self, value: Optional[_builtins.str]):
        pulumi.set(self, "http_proxy", value)

    @_builtins.property
    @pulumi.getter(name="httpsProxy")
    def https_proxy(self) -> Optional[_builtins.str]:
        """
        HTTPS proxy URL.
        """
        return pulumi.get(self, "https_proxy")

    @https_proxy.setter
    def https_proxy(self, value: Optional[_builtins.str]):
        pulumi.set(self, "https_proxy", value)

    @_builtins.property
    @pulumi.getter(name="noProxy")
    def no_proxy(self) -> Optional[_builtins.str]:
        """
        List of hosts that should not use proxy.
        """
        return pulumi.get(self, "no_proxy")

    @no_proxy.setter
    def no_proxy(self, value: Optional[_builtins.str]):
        pulumi.set(self, "no_proxy", value)


if not MYPY:
    class GetInfrastructureV2TolerationArgsDict(TypedDict):
        effect: _builtins.str
        """
        Effect indicates the taint effect to match. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        key: _builtins.str
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists.
        """
        operator: _builtins.str
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal.
        """
        toleration_seconds: NotRequired[_builtins.int]
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        value: NotRequired[_builtins.str]
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
elif False:
    GetInfrastructureV2TolerationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2TolerationArgs:
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 operator: _builtins.str,
                 toleration_seconds: Optional[_builtins.int] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str effect: Effect indicates the taint effect to match. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        :param _builtins.str key: Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists.
        :param _builtins.str operator: Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal.
        :param _builtins.int toleration_seconds: TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        :param _builtins.str value: Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "operator", operator)
        if toleration_seconds is not None:
            pulumi.set(__self__, "toleration_seconds", toleration_seconds)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        Effect indicates the taint effect to match. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: _builtins.str):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: _builtins.str):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter(name="tolerationSeconds")
    def toleration_seconds(self) -> Optional[_builtins.int]:
        """
        TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
        """
        return pulumi.get(self, "toleration_seconds")

    @toleration_seconds.setter
    def toleration_seconds(self, value: Optional[_builtins.int]):
        pulumi.set(self, "toleration_seconds", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetInfrastructureV2VolumeArgsDict(TypedDict):
        name: _builtins.str
        """
        Name of the volume. Must be a DNS_LABEL and unique within the pod.
        """
        size_limit: NotRequired[_builtins.str]
        """
        Size limit of the volume. Example: '10Gi', '100Mi'
        """
elif False:
    GetInfrastructureV2VolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2VolumeArgs:
    def __init__(__self__, *,
                 name: _builtins.str,
                 size_limit: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of the volume. Must be a DNS_LABEL and unique within the pod.
        :param _builtins.str size_limit: Size limit of the volume. Example: '10Gi', '100Mi'
        """
        pulumi.set(__self__, "name", name)
        if size_limit is not None:
            pulumi.set(__self__, "size_limit", size_limit)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the volume. Must be a DNS_LABEL and unique within the pod.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="sizeLimit")
    def size_limit(self) -> Optional[_builtins.str]:
        """
        Size limit of the volume. Example: '10Gi', '100Mi'
        """
        return pulumi.get(self, "size_limit")

    @size_limit.setter
    def size_limit(self, value: Optional[_builtins.str]):
        pulumi.set(self, "size_limit", value)


if not MYPY:
    class GetInfrastructureV2VolumeMountArgsDict(TypedDict):
        mount_path: _builtins.str
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        name: _builtins.str
        """
        This must match the Name of a Volume.
        """
        mount_propagation: NotRequired[_builtins.str]
        """
        Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.
        """
        read_only: NotRequired[_builtins.bool]
        """
        Mounted read-only if true, read-write otherwise.
        """
        sub_path: NotRequired[_builtins.str]
        """
        Path within the volume from which the container's volume should be mounted. Mutually exclusive with sub*path*expr.
        """
        sub_path_expr: NotRequired[_builtins.str]
        """
        Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to sub*path but environment variable references $(VAR*NAME) are expanded using the container's environment. Mutually exclusive with sub_path.
        """
elif False:
    GetInfrastructureV2VolumeMountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureV2VolumeMountArgs:
    def __init__(__self__, *,
                 mount_path: _builtins.str,
                 name: _builtins.str,
                 mount_propagation: Optional[_builtins.str] = None,
                 read_only: Optional[_builtins.bool] = None,
                 sub_path: Optional[_builtins.str] = None,
                 sub_path_expr: Optional[_builtins.str] = None):
        """
        :param _builtins.str mount_path: Path within the container at which the volume should be mounted. Must not contain ':'.
        :param _builtins.str name: This must match the Name of a Volume.
        :param _builtins.str mount_propagation: Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.
        :param _builtins.bool read_only: Mounted read-only if true, read-write otherwise.
        :param _builtins.str sub_path: Path within the volume from which the container's volume should be mounted. Mutually exclusive with sub*path*expr.
        :param _builtins.str sub_path_expr: Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to sub*path but environment variable references $(VAR*NAME) are expanded using the container's environment. Mutually exclusive with sub_path.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "name", name)
        if mount_propagation is not None:
            pulumi.set(__self__, "mount_propagation", mount_propagation)
        if read_only is not None:
            pulumi.set(__self__, "read_only", read_only)
        if sub_path is not None:
            pulumi.set(__self__, "sub_path", sub_path)
        if sub_path_expr is not None:
            pulumi.set(__self__, "sub_path_expr", sub_path_expr)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> _builtins.str:
        """
        Path within the container at which the volume should be mounted. Must not contain ':'.
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: _builtins.str):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        This must match the Name of a Volume.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="mountPropagation")
    def mount_propagation(self) -> Optional[_builtins.str]:
        """
        Determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used.
        """
        return pulumi.get(self, "mount_propagation")

    @mount_propagation.setter
    def mount_propagation(self, value: Optional[_builtins.str]):
        pulumi.set(self, "mount_propagation", value)

    @_builtins.property
    @pulumi.getter(name="readOnly")
    def read_only(self) -> Optional[_builtins.bool]:
        """
        Mounted read-only if true, read-write otherwise.
        """
        return pulumi.get(self, "read_only")

    @read_only.setter
    def read_only(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "read_only", value)

    @_builtins.property
    @pulumi.getter(name="subPath")
    def sub_path(self) -> Optional[_builtins.str]:
        """
        Path within the volume from which the container's volume should be mounted. Mutually exclusive with sub*path*expr.
        """
        return pulumi.get(self, "sub_path")

    @sub_path.setter
    def sub_path(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sub_path", value)

    @_builtins.property
    @pulumi.getter(name="subPathExpr")
    def sub_path_expr(self) -> Optional[_builtins.str]:
        """
        Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to sub*path but environment variable references $(VAR*NAME) are expanded using the container's environment. Mutually exclusive with sub_path.
        """
        return pulumi.get(self, "sub_path_expr")

    @sub_path_expr.setter
    def sub_path_expr(self, value: Optional[_builtins.str]):
        pulumi.set(self, "sub_path_expr", value)


