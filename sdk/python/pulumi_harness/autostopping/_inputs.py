# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AwsProxyCertificatesArgs',
    'AwsProxyCertificatesArgsDict',
    'AzureProxyCertificatesArgs',
    'AzureProxyCertificatesArgsDict',
    'GcpProxyCertificatesArgs',
    'GcpProxyCertificatesArgsDict',
    'RuleEcsContainerArgs',
    'RuleEcsContainerArgsDict',
    'RuleEcsDependArgs',
    'RuleEcsDependArgsDict',
    'RuleEcsHttpArgs',
    'RuleEcsHttpArgsDict',
    'RuleRdsDatabaseArgs',
    'RuleRdsDatabaseArgsDict',
    'RuleRdsDependArgs',
    'RuleRdsDependArgsDict',
    'RuleRdsTcpArgs',
    'RuleRdsTcpArgsDict',
    'RuleRdsTcpForwardRuleArgs',
    'RuleRdsTcpForwardRuleArgsDict',
    'RuleVmDependArgs',
    'RuleVmDependArgsDict',
    'RuleVmFilterArgs',
    'RuleVmFilterArgsDict',
    'RuleVmFilterTagArgs',
    'RuleVmFilterTagArgsDict',
    'RuleVmHttpArgs',
    'RuleVmHttpArgsDict',
    'RuleVmHttpHealthArgs',
    'RuleVmHttpHealthArgsDict',
    'RuleVmHttpRoutingArgs',
    'RuleVmHttpRoutingArgsDict',
    'RuleVmTcpArgs',
    'RuleVmTcpArgsDict',
    'RuleVmTcpForwardRuleArgs',
    'RuleVmTcpForwardRuleArgsDict',
    'RuleVmTcpRdpArgs',
    'RuleVmTcpRdpArgsDict',
    'RuleVmTcpSshArgs',
    'RuleVmTcpSshArgsDict',
    'ScheduleRepeatArgs',
    'ScheduleRepeatArgsDict',
    'GetAwsProxyCertificatesArgs',
    'GetAwsProxyCertificatesArgsDict',
    'GetAzureProxyCertificatesArgs',
    'GetAzureProxyCertificatesArgsDict',
    'GetGcpProxyCertificatesArgs',
    'GetGcpProxyCertificatesArgsDict',
    'GetRuleEcsContainerArgs',
    'GetRuleEcsContainerArgsDict',
    'GetRuleEcsDependArgs',
    'GetRuleEcsDependArgsDict',
    'GetRuleEcsHttpArgs',
    'GetRuleEcsHttpArgsDict',
    'GetRuleRdsDatabaseArgs',
    'GetRuleRdsDatabaseArgsDict',
    'GetRuleRdsDependArgs',
    'GetRuleRdsDependArgsDict',
    'GetRuleRdsTcpArgs',
    'GetRuleRdsTcpArgsDict',
    'GetRuleRdsTcpForwardRuleArgs',
    'GetRuleRdsTcpForwardRuleArgsDict',
    'GetRuleVmDependArgs',
    'GetRuleVmDependArgsDict',
    'GetRuleVmFilterArgs',
    'GetRuleVmFilterArgsDict',
    'GetRuleVmFilterTagArgs',
    'GetRuleVmFilterTagArgsDict',
    'GetRuleVmHttpArgs',
    'GetRuleVmHttpArgsDict',
    'GetRuleVmHttpHealthArgs',
    'GetRuleVmHttpHealthArgsDict',
    'GetRuleVmHttpRoutingArgs',
    'GetRuleVmHttpRoutingArgsDict',
    'GetRuleVmTcpArgs',
    'GetRuleVmTcpArgsDict',
    'GetRuleVmTcpForwardRuleArgs',
    'GetRuleVmTcpForwardRuleArgsDict',
    'GetRuleVmTcpRdpArgs',
    'GetRuleVmTcpRdpArgsDict',
    'GetRuleVmTcpSshArgs',
    'GetRuleVmTcpSshArgsDict',
]

MYPY = False

if not MYPY:
    class AwsProxyCertificatesArgsDict(TypedDict):
        cert_secret_id: pulumi.Input[_builtins.str]
        """
        Certificate secret ID
        """
        key_secret_id: pulumi.Input[_builtins.str]
        """
        Private key secret ID
        """
elif False:
    AwsProxyCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsProxyCertificatesArgs:
    def __init__(__self__, *,
                 cert_secret_id: pulumi.Input[_builtins.str],
                 key_secret_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert_secret_id: Certificate secret ID
        :param pulumi.Input[_builtins.str] key_secret_id: Private key secret ID
        """
        pulumi.set(__self__, "cert_secret_id", cert_secret_id)
        pulumi.set(__self__, "key_secret_id", key_secret_id)

    @_builtins.property
    @pulumi.getter(name="certSecretId")
    def cert_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate secret ID
        """
        return pulumi.get(self, "cert_secret_id")

    @cert_secret_id.setter
    def cert_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="keySecretId")
    def key_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        Private key secret ID
        """
        return pulumi.get(self, "key_secret_id")

    @key_secret_id.setter
    def key_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_secret_id", value)


if not MYPY:
    class AzureProxyCertificatesArgsDict(TypedDict):
        cert_secret_id: pulumi.Input[_builtins.str]
        """
        ID of certificate secret uploaded to vault
        """
        key_secret_id: pulumi.Input[_builtins.str]
        """
        ID of certificate key uploaded to vault
        """
elif False:
    AzureProxyCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureProxyCertificatesArgs:
    def __init__(__self__, *,
                 cert_secret_id: pulumi.Input[_builtins.str],
                 key_secret_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert_secret_id: ID of certificate secret uploaded to vault
        :param pulumi.Input[_builtins.str] key_secret_id: ID of certificate key uploaded to vault
        """
        pulumi.set(__self__, "cert_secret_id", cert_secret_id)
        pulumi.set(__self__, "key_secret_id", key_secret_id)

    @_builtins.property
    @pulumi.getter(name="certSecretId")
    def cert_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of certificate secret uploaded to vault
        """
        return pulumi.get(self, "cert_secret_id")

    @cert_secret_id.setter
    def cert_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="keySecretId")
    def key_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of certificate key uploaded to vault
        """
        return pulumi.get(self, "key_secret_id")

    @key_secret_id.setter
    def key_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_secret_id", value)


if not MYPY:
    class GcpProxyCertificatesArgsDict(TypedDict):
        cert_secret_id: pulumi.Input[_builtins.str]
        """
        Certificate secret ID
        """
        key_secret_id: pulumi.Input[_builtins.str]
        """
        Private key secret ID
        """
elif False:
    GcpProxyCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpProxyCertificatesArgs:
    def __init__(__self__, *,
                 cert_secret_id: pulumi.Input[_builtins.str],
                 key_secret_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert_secret_id: Certificate secret ID
        :param pulumi.Input[_builtins.str] key_secret_id: Private key secret ID
        """
        pulumi.set(__self__, "cert_secret_id", cert_secret_id)
        pulumi.set(__self__, "key_secret_id", key_secret_id)

    @_builtins.property
    @pulumi.getter(name="certSecretId")
    def cert_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        Certificate secret ID
        """
        return pulumi.get(self, "cert_secret_id")

    @cert_secret_id.setter
    def cert_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="keySecretId")
    def key_secret_id(self) -> pulumi.Input[_builtins.str]:
        """
        Private key secret ID
        """
        return pulumi.get(self, "key_secret_id")

    @key_secret_id.setter
    def key_secret_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_secret_id", value)


if not MYPY:
    class RuleEcsContainerArgsDict(TypedDict):
        cluster: pulumi.Input[_builtins.str]
        """
        Name of cluster in which service belong to
        """
        region: pulumi.Input[_builtins.str]
        """
        Region of cluster
        """
        service: pulumi.Input[_builtins.str]
        """
        Name of service to be onboarded
        """
        task_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Desired number of tasks on warming up a rule
        """
elif False:
    RuleEcsContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleEcsContainerArgs:
    def __init__(__self__, *,
                 cluster: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 service: pulumi.Input[_builtins.str],
                 task_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster: Name of cluster in which service belong to
        :param pulumi.Input[_builtins.str] region: Region of cluster
        :param pulumi.Input[_builtins.str] service: Name of service to be onboarded
        :param pulumi.Input[_builtins.int] task_count: Desired number of tasks on warming up a rule
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service", service)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> pulumi.Input[_builtins.str]:
        """
        Name of cluster in which service belong to
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region of cluster
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        Name of service to be onboarded
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Desired number of tasks on warming up a rule
        """
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "task_count", value)


if not MYPY:
    class RuleEcsDependArgsDict(TypedDict):
        rule_id: pulumi.Input[_builtins.int]
        """
        Rule id of the dependent rule
        """
        delay_in_sec: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
elif False:
    RuleEcsDependArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleEcsDependArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[_builtins.int],
                 delay_in_sec: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] rule_id: Rule id of the dependent rule
        :param pulumi.Input[_builtins.int] delay_in_sec: Number of seconds the rule should wait after warming up the dependent rule
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if delay_in_sec is not None:
            pulumi.set(__self__, "delay_in_sec", delay_in_sec)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[_builtins.int]:
        """
        Rule id of the dependent rule
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="delayInSec")
    def delay_in_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
        return pulumi.get(self, "delay_in_sec")

    @delay_in_sec.setter
    def delay_in_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay_in_sec", value)


if not MYPY:
    class RuleEcsHttpArgsDict(TypedDict):
        proxy_id: pulumi.Input[_builtins.str]
        """
        Id of the proxy
        """
elif False:
    RuleEcsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleEcsHttpArgs:
    def __init__(__self__, *,
                 proxy_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] proxy_id: Id of the proxy
        """
        pulumi.set(__self__, "proxy_id", proxy_id)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id of the proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "proxy_id", value)


if not MYPY:
    class RuleRdsDatabaseArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        ID of the database
        """
        region: pulumi.Input[_builtins.str]
        """
        Region to which database belong to
        """
elif False:
    RuleRdsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRdsDatabaseArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: ID of the database
        :param pulumi.Input[_builtins.str] region: Region to which database belong to
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region to which database belong to
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class RuleRdsDependArgsDict(TypedDict):
        rule_id: pulumi.Input[_builtins.int]
        """
        Rule id of the dependent rule
        """
        delay_in_sec: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
elif False:
    RuleRdsDependArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRdsDependArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[_builtins.int],
                 delay_in_sec: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] rule_id: Rule id of the dependent rule
        :param pulumi.Input[_builtins.int] delay_in_sec: Number of seconds the rule should wait after warming up the dependent rule
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if delay_in_sec is not None:
            pulumi.set(__self__, "delay_in_sec", delay_in_sec)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[_builtins.int]:
        """
        Rule id of the dependent rule
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="delayInSec")
    def delay_in_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
        return pulumi.get(self, "delay_in_sec")

    @delay_in_sec.setter
    def delay_in_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay_in_sec", value)


if not MYPY:
    class RuleRdsTcpArgsDict(TypedDict):
        proxy_id: pulumi.Input[_builtins.str]
        """
        Id of the Proxy
        """
        forward_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleRdsTcpForwardRuleArgsDict']]]]
        """
        Additional tcp forwarding rules
        """
elif False:
    RuleRdsTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRdsTcpArgs:
    def __init__(__self__, *,
                 proxy_id: pulumi.Input[_builtins.str],
                 forward_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRdsTcpForwardRuleArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] proxy_id: Id of the Proxy
        :param pulumi.Input[Sequence[pulumi.Input['RuleRdsTcpForwardRuleArgs']]] forward_rules: Additional tcp forwarding rules
        """
        pulumi.set(__self__, "proxy_id", proxy_id)
        if forward_rules is not None:
            pulumi.set(__self__, "forward_rules", forward_rules)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id of the Proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "proxy_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardRules")
    def forward_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleRdsTcpForwardRuleArgs']]]]:
        """
        Additional tcp forwarding rules
        """
        return pulumi.get(self, "forward_rules")

    @forward_rules.setter
    def forward_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleRdsTcpForwardRuleArgs']]]]):
        pulumi.set(self, "forward_rules", value)


if not MYPY:
    class RuleRdsTcpForwardRuleArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        Port to listen on the vm
        """
        connect_on: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port to listen on the proxy
        """
elif False:
    RuleRdsTcpForwardRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleRdsTcpForwardRuleArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 connect_on: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: Port to listen on the vm
        :param pulumi.Input[_builtins.int] connect_on: Port to listen on the proxy
        """
        pulumi.set(__self__, "port", port)
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_on", value)


if not MYPY:
    class RuleVmDependArgsDict(TypedDict):
        rule_id: pulumi.Input[_builtins.int]
        """
        Rule id of the dependent rule
        """
        delay_in_sec: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
elif False:
    RuleVmDependArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmDependArgs:
    def __init__(__self__, *,
                 rule_id: pulumi.Input[_builtins.int],
                 delay_in_sec: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] rule_id: Rule id of the dependent rule
        :param pulumi.Input[_builtins.int] delay_in_sec: Number of seconds the rule should wait after warming up the dependent rule
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if delay_in_sec is not None:
            pulumi.set(__self__, "delay_in_sec", delay_in_sec)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[_builtins.int]:
        """
        Rule id of the dependent rule
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="delayInSec")
    def delay_in_sec(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
        return pulumi.get(self, "delay_in_sec")

    @delay_in_sec.setter
    def delay_in_sec(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "delay_in_sec", value)


if not MYPY:
    class RuleVmFilterArgsDict(TypedDict):
        vm_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Ids of instances that needs to be managed using the AutoStopping rules
        """
        regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Regions of instances that needs to be managed using the AutoStopping rules
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleVmFilterTagArgsDict']]]]
        """
        Tags of instances that needs to be managed using the AutoStopping rules
        """
        zones: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Zones of instances that needs to be managed using the AutoStopping rules
        """
elif False:
    RuleVmFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmFilterArgs:
    def __init__(__self__, *,
                 vm_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 regions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmFilterTagArgs']]]] = None,
                 zones: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] vm_ids: Ids of instances that needs to be managed using the AutoStopping rules
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] regions: Regions of instances that needs to be managed using the AutoStopping rules
        :param pulumi.Input[Sequence[pulumi.Input['RuleVmFilterTagArgs']]] tags: Tags of instances that needs to be managed using the AutoStopping rules
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] zones: Zones of instances that needs to be managed using the AutoStopping rules
        """
        pulumi.set(__self__, "vm_ids", vm_ids)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Ids of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "vm_ids")

    @vm_ids.setter
    def vm_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "vm_ids", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Regions of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmFilterTagArgs']]]]:
        """
        Tags of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmFilterTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Zones of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class RuleVmFilterTagArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        value: pulumi.Input[_builtins.str]
elif False:
    RuleVmFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmFilterTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RuleVmHttpArgsDict(TypedDict):
        proxy_id: pulumi.Input[_builtins.str]
        """
        Id of the proxy
        """
        healths: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpHealthArgsDict']]]]
        """
        Health Check Details
        """
        routings: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpRoutingArgsDict']]]]
        """
        Routing configuration used to access the instances
        """
elif False:
    RuleVmHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmHttpArgs:
    def __init__(__self__, *,
                 proxy_id: pulumi.Input[_builtins.str],
                 healths: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpHealthArgs']]]] = None,
                 routings: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpRoutingArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] proxy_id: Id of the proxy
        :param pulumi.Input[Sequence[pulumi.Input['RuleVmHttpHealthArgs']]] healths: Health Check Details
        :param pulumi.Input[Sequence[pulumi.Input['RuleVmHttpRoutingArgs']]] routings: Routing configuration used to access the instances
        """
        pulumi.set(__self__, "proxy_id", proxy_id)
        if healths is not None:
            pulumi.set(__self__, "healths", healths)
        if routings is not None:
            pulumi.set(__self__, "routings", routings)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id of the proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "proxy_id", value)

    @_builtins.property
    @pulumi.getter
    def healths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpHealthArgs']]]]:
        """
        Health Check Details
        """
        return pulumi.get(self, "healths")

    @healths.setter
    def healths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpHealthArgs']]]]):
        pulumi.set(self, "healths", value)

    @_builtins.property
    @pulumi.getter
    def routings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpRoutingArgs']]]]:
        """
        Routing configuration used to access the instances
        """
        return pulumi.get(self, "routings")

    @routings.setter
    def routings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmHttpRoutingArgs']]]]):
        pulumi.set(self, "routings", value)


if not MYPY:
    class RuleVmHttpHealthArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        Health check port on the VM
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Protocol can be http or https
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        API path to use for health check
        """
        status_code_from: NotRequired[pulumi.Input[_builtins.int]]
        """
        Lower limit for acceptable status code
        """
        status_code_to: NotRequired[pulumi.Input[_builtins.int]]
        """
        Upper limit for acceptable status code
        """
        timeout: NotRequired[pulumi.Input[_builtins.int]]
        """
        Health check timeout
        """
elif False:
    RuleVmHttpHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmHttpHealthArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 status_code_from: Optional[pulumi.Input[_builtins.int]] = None,
                 status_code_to: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: Health check port on the VM
        :param pulumi.Input[_builtins.str] protocol: Protocol can be http or https
        :param pulumi.Input[_builtins.str] path: API path to use for health check
        :param pulumi.Input[_builtins.int] status_code_from: Lower limit for acceptable status code
        :param pulumi.Input[_builtins.int] status_code_to: Upper limit for acceptable status code
        :param pulumi.Input[_builtins.int] timeout: Health check timeout
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status_code_from is not None:
            pulumi.set(__self__, "status_code_from", status_code_from)
        if status_code_to is not None:
            pulumi.set(__self__, "status_code_to", status_code_to)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Health check port on the VM
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Protocol can be http or https
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API path to use for health check
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="statusCodeFrom")
    def status_code_from(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Lower limit for acceptable status code
        """
        return pulumi.get(self, "status_code_from")

    @status_code_from.setter
    def status_code_from(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code_from", value)

    @_builtins.property
    @pulumi.getter(name="statusCodeTo")
    def status_code_to(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Upper limit for acceptable status code
        """
        return pulumi.get(self, "status_code_to")

    @status_code_to.setter
    def status_code_to(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "status_code_to", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Health check timeout
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class RuleVmHttpRoutingArgsDict(TypedDict):
        source_protocol: pulumi.Input[_builtins.str]
        """
        Source protocol of the proxy can be http or https
        """
        target_protocol: pulumi.Input[_builtins.str]
        """
        Target protocol of the instance can be http or https
        """
        action: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization Identifier for the Entity
        """
        source_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port on the proxy
        """
        target_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port on the VM
        """
elif False:
    RuleVmHttpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmHttpRoutingArgs:
    def __init__(__self__, *,
                 source_protocol: pulumi.Input[_builtins.str],
                 target_protocol: pulumi.Input[_builtins.str],
                 action: Optional[pulumi.Input[_builtins.str]] = None,
                 source_port: Optional[pulumi.Input[_builtins.int]] = None,
                 target_port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] source_protocol: Source protocol of the proxy can be http or https
        :param pulumi.Input[_builtins.str] target_protocol: Target protocol of the instance can be http or https
        :param pulumi.Input[_builtins.str] action: Organization Identifier for the Entity
        :param pulumi.Input[_builtins.int] source_port: Port on the proxy
        :param pulumi.Input[_builtins.int] target_port: Port on the VM
        """
        pulumi.set(__self__, "source_protocol", source_protocol)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter(name="sourceProtocol")
    def source_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Source protocol of the proxy can be http or https
        """
        return pulumi.get(self, "source_protocol")

    @source_protocol.setter
    def source_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Target protocol of the instance can be http or https
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_protocol", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization Identifier for the Entity
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port on the proxy
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "source_port", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port on the VM
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class RuleVmTcpArgsDict(TypedDict):
        proxy_id: pulumi.Input[_builtins.str]
        """
        Id of the Proxy
        """
        forward_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpForwardRuleArgsDict']]]]
        """
        Additional tcp forwarding rules
        """
        rdps: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpRdpArgsDict']]]]
        """
        RDP configuration
        """
        sshes: NotRequired[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpSshArgsDict']]]]
        """
        SSH configuration
        """
elif False:
    RuleVmTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmTcpArgs:
    def __init__(__self__, *,
                 proxy_id: pulumi.Input[_builtins.str],
                 forward_rules: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpForwardRuleArgs']]]] = None,
                 rdps: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpRdpArgs']]]] = None,
                 sshes: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpSshArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] proxy_id: Id of the Proxy
        :param pulumi.Input[Sequence[pulumi.Input['RuleVmTcpForwardRuleArgs']]] forward_rules: Additional tcp forwarding rules
        :param pulumi.Input[Sequence[pulumi.Input['RuleVmTcpRdpArgs']]] rdps: RDP configuration
        :param pulumi.Input[Sequence[pulumi.Input['RuleVmTcpSshArgs']]] sshes: SSH configuration
        """
        pulumi.set(__self__, "proxy_id", proxy_id)
        if forward_rules is not None:
            pulumi.set(__self__, "forward_rules", forward_rules)
        if rdps is not None:
            pulumi.set(__self__, "rdps", rdps)
        if sshes is not None:
            pulumi.set(__self__, "sshes", sshes)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> pulumi.Input[_builtins.str]:
        """
        Id of the Proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "proxy_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardRules")
    def forward_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpForwardRuleArgs']]]]:
        """
        Additional tcp forwarding rules
        """
        return pulumi.get(self, "forward_rules")

    @forward_rules.setter
    def forward_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpForwardRuleArgs']]]]):
        pulumi.set(self, "forward_rules", value)

    @_builtins.property
    @pulumi.getter
    def rdps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpRdpArgs']]]]:
        """
        RDP configuration
        """
        return pulumi.get(self, "rdps")

    @rdps.setter
    def rdps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpRdpArgs']]]]):
        pulumi.set(self, "rdps", value)

    @_builtins.property
    @pulumi.getter
    def sshes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpSshArgs']]]]:
        """
        SSH configuration
        """
        return pulumi.get(self, "sshes")

    @sshes.setter
    def sshes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RuleVmTcpSshArgs']]]]):
        pulumi.set(self, "sshes", value)


if not MYPY:
    class RuleVmTcpForwardRuleArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        Port to listen on the vm
        """
        connect_on: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port to listen on the proxy
        """
elif False:
    RuleVmTcpForwardRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmTcpForwardRuleArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 connect_on: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: Port to listen on the vm
        :param pulumi.Input[_builtins.int] connect_on: Port to listen on the proxy
        """
        pulumi.set(__self__, "port", port)
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_on", value)


if not MYPY:
    class RuleVmTcpRdpArgsDict(TypedDict):
        connect_on: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port to listen on the proxy
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port to listen on the vm
        """
elif False:
    RuleVmTcpRdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmTcpRdpArgs:
    def __init__(__self__, *,
                 connect_on: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] connect_on: Port to listen on the proxy
        :param pulumi.Input[_builtins.int] port: Port to listen on the vm
        """
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_on", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class RuleVmTcpSshArgsDict(TypedDict):
        connect_on: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port to listen on the proxy
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port to listen on the vm
        """
elif False:
    RuleVmTcpSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleVmTcpSshArgs:
    def __init__(__self__, *,
                 connect_on: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] connect_on: Port to listen on the proxy
        :param pulumi.Input[_builtins.int] port: Port to listen on the vm
        """
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "connect_on", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ScheduleRepeatArgsDict(TypedDict):
        days: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        end_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ending time of schedule action on the day. Defaults to 24:00Hrs unless specified. Accepted format is HH:MM. Eg : 20:00 for 8pm
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Starting time of schedule action on the day. Defaults to 00:00Hrs unless specified. Accepted format is HH:MM. Eg : 13:15 for 01:15pm
        """
elif False:
    ScheduleRepeatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleRepeatArgs:
    def __init__(__self__, *,
                 days: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 end_time: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] days: List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        :param pulumi.Input[_builtins.str] end_time: Ending time of schedule action on the day. Defaults to 24:00Hrs unless specified. Accepted format is HH:MM. Eg : 20:00 for 8pm
        :param pulumi.Input[_builtins.str] start_time: Starting time of schedule action on the day. Defaults to 00:00Hrs unless specified. Accepted format is HH:MM. Eg : 13:15 for 01:15pm
        """
        pulumi.set(__self__, "days", days)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def days(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of days on which schedule need to be active. Valid values are SUN, MON, TUE, WED, THU, FRI and SAT.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ending time of schedule action on the day. Defaults to 24:00Hrs unless specified. Accepted format is HH:MM. Eg : 20:00 for 8pm
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "end_time", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Starting time of schedule action on the day. Defaults to 00:00Hrs unless specified. Accepted format is HH:MM. Eg : 13:15 for 01:15pm
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class GetAwsProxyCertificatesArgsDict(TypedDict):
        cert_secret_id: _builtins.str
        """
        Certificate secret ID
        """
        key_secret_id: _builtins.str
        """
        Private key secret ID
        """
elif False:
    GetAwsProxyCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAwsProxyCertificatesArgs:
    def __init__(__self__, *,
                 cert_secret_id: _builtins.str,
                 key_secret_id: _builtins.str):
        """
        :param _builtins.str cert_secret_id: Certificate secret ID
        :param _builtins.str key_secret_id: Private key secret ID
        """
        pulumi.set(__self__, "cert_secret_id", cert_secret_id)
        pulumi.set(__self__, "key_secret_id", key_secret_id)

    @_builtins.property
    @pulumi.getter(name="certSecretId")
    def cert_secret_id(self) -> _builtins.str:
        """
        Certificate secret ID
        """
        return pulumi.get(self, "cert_secret_id")

    @cert_secret_id.setter
    def cert_secret_id(self, value: _builtins.str):
        pulumi.set(self, "cert_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="keySecretId")
    def key_secret_id(self) -> _builtins.str:
        """
        Private key secret ID
        """
        return pulumi.get(self, "key_secret_id")

    @key_secret_id.setter
    def key_secret_id(self, value: _builtins.str):
        pulumi.set(self, "key_secret_id", value)


if not MYPY:
    class GetAzureProxyCertificatesArgsDict(TypedDict):
        cert_secret_id: _builtins.str
        """
        ID of certificate secret uploaded to vault
        """
        key_secret_id: _builtins.str
        """
        ID of certificate key uploaded to vault
        """
elif False:
    GetAzureProxyCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAzureProxyCertificatesArgs:
    def __init__(__self__, *,
                 cert_secret_id: _builtins.str,
                 key_secret_id: _builtins.str):
        """
        :param _builtins.str cert_secret_id: ID of certificate secret uploaded to vault
        :param _builtins.str key_secret_id: ID of certificate key uploaded to vault
        """
        pulumi.set(__self__, "cert_secret_id", cert_secret_id)
        pulumi.set(__self__, "key_secret_id", key_secret_id)

    @_builtins.property
    @pulumi.getter(name="certSecretId")
    def cert_secret_id(self) -> _builtins.str:
        """
        ID of certificate secret uploaded to vault
        """
        return pulumi.get(self, "cert_secret_id")

    @cert_secret_id.setter
    def cert_secret_id(self, value: _builtins.str):
        pulumi.set(self, "cert_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="keySecretId")
    def key_secret_id(self) -> _builtins.str:
        """
        ID of certificate key uploaded to vault
        """
        return pulumi.get(self, "key_secret_id")

    @key_secret_id.setter
    def key_secret_id(self, value: _builtins.str):
        pulumi.set(self, "key_secret_id", value)


if not MYPY:
    class GetGcpProxyCertificatesArgsDict(TypedDict):
        cert_secret_id: _builtins.str
        """
        Certificate secret ID
        """
        key_secret_id: _builtins.str
        """
        Private key secret ID
        """
elif False:
    GetGcpProxyCertificatesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGcpProxyCertificatesArgs:
    def __init__(__self__, *,
                 cert_secret_id: _builtins.str,
                 key_secret_id: _builtins.str):
        """
        :param _builtins.str cert_secret_id: Certificate secret ID
        :param _builtins.str key_secret_id: Private key secret ID
        """
        pulumi.set(__self__, "cert_secret_id", cert_secret_id)
        pulumi.set(__self__, "key_secret_id", key_secret_id)

    @_builtins.property
    @pulumi.getter(name="certSecretId")
    def cert_secret_id(self) -> _builtins.str:
        """
        Certificate secret ID
        """
        return pulumi.get(self, "cert_secret_id")

    @cert_secret_id.setter
    def cert_secret_id(self, value: _builtins.str):
        pulumi.set(self, "cert_secret_id", value)

    @_builtins.property
    @pulumi.getter(name="keySecretId")
    def key_secret_id(self) -> _builtins.str:
        """
        Private key secret ID
        """
        return pulumi.get(self, "key_secret_id")

    @key_secret_id.setter
    def key_secret_id(self, value: _builtins.str):
        pulumi.set(self, "key_secret_id", value)


if not MYPY:
    class GetRuleEcsContainerArgsDict(TypedDict):
        cluster: _builtins.str
        """
        Name of cluster in which service belong to
        """
        region: _builtins.str
        """
        Region of cluster
        """
        service: _builtins.str
        """
        Name of service to be onboarded
        """
        task_count: NotRequired[_builtins.int]
        """
        Desired number of tasks on warming up a rule
        """
elif False:
    GetRuleEcsContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleEcsContainerArgs:
    def __init__(__self__, *,
                 cluster: _builtins.str,
                 region: _builtins.str,
                 service: _builtins.str,
                 task_count: Optional[_builtins.int] = None):
        """
        :param _builtins.str cluster: Name of cluster in which service belong to
        :param _builtins.str region: Region of cluster
        :param _builtins.str service: Name of service to be onboarded
        :param _builtins.int task_count: Desired number of tasks on warming up a rule
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "service", service)
        if task_count is not None:
            pulumi.set(__self__, "task_count", task_count)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> _builtins.str:
        """
        Name of cluster in which service belong to
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: _builtins.str):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region of cluster
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: _builtins.str):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        Name of service to be onboarded
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: _builtins.str):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="taskCount")
    def task_count(self) -> Optional[_builtins.int]:
        """
        Desired number of tasks on warming up a rule
        """
        return pulumi.get(self, "task_count")

    @task_count.setter
    def task_count(self, value: Optional[_builtins.int]):
        pulumi.set(self, "task_count", value)


if not MYPY:
    class GetRuleEcsDependArgsDict(TypedDict):
        rule_id: _builtins.int
        """
        Rule id of the dependent rule
        """
        delay_in_sec: NotRequired[_builtins.int]
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
elif False:
    GetRuleEcsDependArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleEcsDependArgs:
    def __init__(__self__, *,
                 rule_id: _builtins.int,
                 delay_in_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int rule_id: Rule id of the dependent rule
        :param _builtins.int delay_in_sec: Number of seconds the rule should wait after warming up the dependent rule
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if delay_in_sec is not None:
            pulumi.set(__self__, "delay_in_sec", delay_in_sec)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.int:
        """
        Rule id of the dependent rule
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: _builtins.int):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="delayInSec")
    def delay_in_sec(self) -> Optional[_builtins.int]:
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
        return pulumi.get(self, "delay_in_sec")

    @delay_in_sec.setter
    def delay_in_sec(self, value: Optional[_builtins.int]):
        pulumi.set(self, "delay_in_sec", value)


if not MYPY:
    class GetRuleEcsHttpArgsDict(TypedDict):
        proxy_id: _builtins.str
        """
        Id of the proxy
        """
elif False:
    GetRuleEcsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleEcsHttpArgs:
    def __init__(__self__, *,
                 proxy_id: _builtins.str):
        """
        :param _builtins.str proxy_id: Id of the proxy
        """
        pulumi.set(__self__, "proxy_id", proxy_id)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> _builtins.str:
        """
        Id of the proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: _builtins.str):
        pulumi.set(self, "proxy_id", value)


if not MYPY:
    class GetRuleRdsDatabaseArgsDict(TypedDict):
        id: _builtins.str
        """
        ID of the database
        """
        region: _builtins.str
        """
        Region to which database belong to
        """
elif False:
    GetRuleRdsDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleRdsDatabaseArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str id: ID of the database
        :param _builtins.str region: Region to which database belong to
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the database
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region to which database belong to
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: _builtins.str):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetRuleRdsDependArgsDict(TypedDict):
        rule_id: _builtins.int
        """
        Rule id of the dependent rule
        """
        delay_in_sec: NotRequired[_builtins.int]
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
elif False:
    GetRuleRdsDependArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleRdsDependArgs:
    def __init__(__self__, *,
                 rule_id: _builtins.int,
                 delay_in_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int rule_id: Rule id of the dependent rule
        :param _builtins.int delay_in_sec: Number of seconds the rule should wait after warming up the dependent rule
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if delay_in_sec is not None:
            pulumi.set(__self__, "delay_in_sec", delay_in_sec)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.int:
        """
        Rule id of the dependent rule
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: _builtins.int):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="delayInSec")
    def delay_in_sec(self) -> Optional[_builtins.int]:
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
        return pulumi.get(self, "delay_in_sec")

    @delay_in_sec.setter
    def delay_in_sec(self, value: Optional[_builtins.int]):
        pulumi.set(self, "delay_in_sec", value)


if not MYPY:
    class GetRuleRdsTcpArgsDict(TypedDict):
        proxy_id: _builtins.str
        """
        Id of the Proxy
        """
        forward_rules: NotRequired[Sequence['GetRuleRdsTcpForwardRuleArgsDict']]
        """
        Additional tcp forwarding rules
        """
elif False:
    GetRuleRdsTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleRdsTcpArgs:
    def __init__(__self__, *,
                 proxy_id: _builtins.str,
                 forward_rules: Optional[Sequence['GetRuleRdsTcpForwardRuleArgs']] = None):
        """
        :param _builtins.str proxy_id: Id of the Proxy
        :param Sequence['GetRuleRdsTcpForwardRuleArgs'] forward_rules: Additional tcp forwarding rules
        """
        pulumi.set(__self__, "proxy_id", proxy_id)
        if forward_rules is not None:
            pulumi.set(__self__, "forward_rules", forward_rules)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> _builtins.str:
        """
        Id of the Proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: _builtins.str):
        pulumi.set(self, "proxy_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardRules")
    def forward_rules(self) -> Optional[Sequence['GetRuleRdsTcpForwardRuleArgs']]:
        """
        Additional tcp forwarding rules
        """
        return pulumi.get(self, "forward_rules")

    @forward_rules.setter
    def forward_rules(self, value: Optional[Sequence['GetRuleRdsTcpForwardRuleArgs']]):
        pulumi.set(self, "forward_rules", value)


if not MYPY:
    class GetRuleRdsTcpForwardRuleArgsDict(TypedDict):
        port: _builtins.int
        """
        Port to listen on the vm
        """
        connect_on: NotRequired[_builtins.int]
        """
        Port to listen on the proxy
        """
elif False:
    GetRuleRdsTcpForwardRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleRdsTcpForwardRuleArgs:
    def __init__(__self__, *,
                 port: _builtins.int,
                 connect_on: Optional[_builtins.int] = None):
        """
        :param _builtins.int port: Port to listen on the vm
        :param _builtins.int connect_on: Port to listen on the proxy
        """
        pulumi.set(__self__, "port", port)
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[_builtins.int]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[_builtins.int]):
        pulumi.set(self, "connect_on", value)


if not MYPY:
    class GetRuleVmDependArgsDict(TypedDict):
        rule_id: _builtins.int
        """
        Rule id of the dependent rule
        """
        delay_in_sec: NotRequired[_builtins.int]
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
elif False:
    GetRuleVmDependArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmDependArgs:
    def __init__(__self__, *,
                 rule_id: _builtins.int,
                 delay_in_sec: Optional[_builtins.int] = None):
        """
        :param _builtins.int rule_id: Rule id of the dependent rule
        :param _builtins.int delay_in_sec: Number of seconds the rule should wait after warming up the dependent rule
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if delay_in_sec is not None:
            pulumi.set(__self__, "delay_in_sec", delay_in_sec)

    @_builtins.property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> _builtins.int:
        """
        Rule id of the dependent rule
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: _builtins.int):
        pulumi.set(self, "rule_id", value)

    @_builtins.property
    @pulumi.getter(name="delayInSec")
    def delay_in_sec(self) -> Optional[_builtins.int]:
        """
        Number of seconds the rule should wait after warming up the dependent rule
        """
        return pulumi.get(self, "delay_in_sec")

    @delay_in_sec.setter
    def delay_in_sec(self, value: Optional[_builtins.int]):
        pulumi.set(self, "delay_in_sec", value)


if not MYPY:
    class GetRuleVmFilterArgsDict(TypedDict):
        vm_ids: Sequence[_builtins.str]
        """
        Ids of instances that needs to be managed using the AutoStopping rules
        """
        regions: NotRequired[Sequence[_builtins.str]]
        """
        Regions of instances that needs to be managed using the AutoStopping rules
        """
        tags: NotRequired[Sequence['GetRuleVmFilterTagArgsDict']]
        """
        Tags of instances that needs to be managed using the AutoStopping rules
        """
        zones: NotRequired[Sequence[_builtins.str]]
        """
        Zones of instances that needs to be managed using the AutoStopping rules
        """
elif False:
    GetRuleVmFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmFilterArgs:
    def __init__(__self__, *,
                 vm_ids: Sequence[_builtins.str],
                 regions: Optional[Sequence[_builtins.str]] = None,
                 tags: Optional[Sequence['GetRuleVmFilterTagArgs']] = None,
                 zones: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] vm_ids: Ids of instances that needs to be managed using the AutoStopping rules
        :param Sequence[_builtins.str] regions: Regions of instances that needs to be managed using the AutoStopping rules
        :param Sequence['GetRuleVmFilterTagArgs'] tags: Tags of instances that needs to be managed using the AutoStopping rules
        :param Sequence[_builtins.str] zones: Zones of instances that needs to be managed using the AutoStopping rules
        """
        pulumi.set(__self__, "vm_ids", vm_ids)
        if regions is not None:
            pulumi.set(__self__, "regions", regions)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if zones is not None:
            pulumi.set(__self__, "zones", zones)

    @_builtins.property
    @pulumi.getter(name="vmIds")
    def vm_ids(self) -> Sequence[_builtins.str]:
        """
        Ids of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "vm_ids")

    @vm_ids.setter
    def vm_ids(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "vm_ids", value)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Optional[Sequence[_builtins.str]]:
        """
        Regions of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "regions", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['GetRuleVmFilterTagArgs']]:
        """
        Tags of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Sequence['GetRuleVmFilterTagArgs']]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> Optional[Sequence[_builtins.str]]:
        """
        Zones of instances that needs to be managed using the AutoStopping rules
        """
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "zones", value)


if not MYPY:
    class GetRuleVmFilterTagArgsDict(TypedDict):
        key: _builtins.str
        value: _builtins.str
elif False:
    GetRuleVmFilterTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmFilterTagArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: _builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetRuleVmHttpArgsDict(TypedDict):
        proxy_id: _builtins.str
        """
        Id of the proxy
        """
        healths: NotRequired[Sequence['GetRuleVmHttpHealthArgsDict']]
        """
        Health Check Details
        """
        routings: NotRequired[Sequence['GetRuleVmHttpRoutingArgsDict']]
        """
        Routing configuration used to access the instances
        """
elif False:
    GetRuleVmHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmHttpArgs:
    def __init__(__self__, *,
                 proxy_id: _builtins.str,
                 healths: Optional[Sequence['GetRuleVmHttpHealthArgs']] = None,
                 routings: Optional[Sequence['GetRuleVmHttpRoutingArgs']] = None):
        """
        :param _builtins.str proxy_id: Id of the proxy
        :param Sequence['GetRuleVmHttpHealthArgs'] healths: Health Check Details
        :param Sequence['GetRuleVmHttpRoutingArgs'] routings: Routing configuration used to access the instances
        """
        pulumi.set(__self__, "proxy_id", proxy_id)
        if healths is not None:
            pulumi.set(__self__, "healths", healths)
        if routings is not None:
            pulumi.set(__self__, "routings", routings)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> _builtins.str:
        """
        Id of the proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: _builtins.str):
        pulumi.set(self, "proxy_id", value)

    @_builtins.property
    @pulumi.getter
    def healths(self) -> Optional[Sequence['GetRuleVmHttpHealthArgs']]:
        """
        Health Check Details
        """
        return pulumi.get(self, "healths")

    @healths.setter
    def healths(self, value: Optional[Sequence['GetRuleVmHttpHealthArgs']]):
        pulumi.set(self, "healths", value)

    @_builtins.property
    @pulumi.getter
    def routings(self) -> Optional[Sequence['GetRuleVmHttpRoutingArgs']]:
        """
        Routing configuration used to access the instances
        """
        return pulumi.get(self, "routings")

    @routings.setter
    def routings(self, value: Optional[Sequence['GetRuleVmHttpRoutingArgs']]):
        pulumi.set(self, "routings", value)


if not MYPY:
    class GetRuleVmHttpHealthArgsDict(TypedDict):
        port: _builtins.int
        """
        Health check port on the VM
        """
        protocol: _builtins.str
        """
        Protocol can be http or https
        """
        path: NotRequired[_builtins.str]
        """
        API path to use for health check
        """
        status_code_from: NotRequired[_builtins.int]
        """
        Lower limit for acceptable status code
        """
        status_code_to: NotRequired[_builtins.int]
        """
        Upper limit for acceptable status code
        """
        timeout: NotRequired[_builtins.int]
        """
        Health check timeout
        """
elif False:
    GetRuleVmHttpHealthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmHttpHealthArgs:
    def __init__(__self__, *,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 path: Optional[_builtins.str] = None,
                 status_code_from: Optional[_builtins.int] = None,
                 status_code_to: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.int port: Health check port on the VM
        :param _builtins.str protocol: Protocol can be http or https
        :param _builtins.str path: API path to use for health check
        :param _builtins.int status_code_from: Lower limit for acceptable status code
        :param _builtins.int status_code_to: Upper limit for acceptable status code
        :param _builtins.int timeout: Health check timeout
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if status_code_from is not None:
            pulumi.set(__self__, "status_code_from", status_code_from)
        if status_code_to is not None:
            pulumi.set(__self__, "status_code_to", status_code_to)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Health check port on the VM
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol can be http or https
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        API path to use for health check
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="statusCodeFrom")
    def status_code_from(self) -> Optional[_builtins.int]:
        """
        Lower limit for acceptable status code
        """
        return pulumi.get(self, "status_code_from")

    @status_code_from.setter
    def status_code_from(self, value: Optional[_builtins.int]):
        pulumi.set(self, "status_code_from", value)

    @_builtins.property
    @pulumi.getter(name="statusCodeTo")
    def status_code_to(self) -> Optional[_builtins.int]:
        """
        Upper limit for acceptable status code
        """
        return pulumi.get(self, "status_code_to")

    @status_code_to.setter
    def status_code_to(self, value: Optional[_builtins.int]):
        pulumi.set(self, "status_code_to", value)

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Health check timeout
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[_builtins.int]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class GetRuleVmHttpRoutingArgsDict(TypedDict):
        source_protocol: _builtins.str
        """
        Source protocol of the proxy can be http or https
        """
        target_protocol: _builtins.str
        """
        Target protocol of the instance can be http or https
        """
        action: NotRequired[_builtins.str]
        """
        Organization Identifier for the Entity
        """
        source_port: NotRequired[_builtins.int]
        """
        Port on the proxy
        """
        target_port: NotRequired[_builtins.int]
        """
        Port on the VM
        """
elif False:
    GetRuleVmHttpRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmHttpRoutingArgs:
    def __init__(__self__, *,
                 source_protocol: _builtins.str,
                 target_protocol: _builtins.str,
                 action: Optional[_builtins.str] = None,
                 source_port: Optional[_builtins.int] = None,
                 target_port: Optional[_builtins.int] = None):
        """
        :param _builtins.str source_protocol: Source protocol of the proxy can be http or https
        :param _builtins.str target_protocol: Target protocol of the instance can be http or https
        :param _builtins.str action: Organization Identifier for the Entity
        :param _builtins.int source_port: Port on the proxy
        :param _builtins.int target_port: Port on the VM
        """
        pulumi.set(__self__, "source_protocol", source_protocol)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if source_port is not None:
            pulumi.set(__self__, "source_port", source_port)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @_builtins.property
    @pulumi.getter(name="sourceProtocol")
    def source_protocol(self) -> _builtins.str:
        """
        Source protocol of the proxy can be http or https
        """
        return pulumi.get(self, "source_protocol")

    @source_protocol.setter
    def source_protocol(self, value: _builtins.str):
        pulumi.set(self, "source_protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> _builtins.str:
        """
        Target protocol of the instance can be http or https
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: _builtins.str):
        pulumi.set(self, "target_protocol", value)

    @_builtins.property
    @pulumi.getter
    def action(self) -> Optional[_builtins.str]:
        """
        Organization Identifier for the Entity
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="sourcePort")
    def source_port(self) -> Optional[_builtins.int]:
        """
        Port on the proxy
        """
        return pulumi.get(self, "source_port")

    @source_port.setter
    def source_port(self, value: Optional[_builtins.int]):
        pulumi.set(self, "source_port", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[_builtins.int]:
        """
        Port on the VM
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[_builtins.int]):
        pulumi.set(self, "target_port", value)


if not MYPY:
    class GetRuleVmTcpArgsDict(TypedDict):
        proxy_id: _builtins.str
        """
        Id of the Proxy
        """
        forward_rules: NotRequired[Sequence['GetRuleVmTcpForwardRuleArgsDict']]
        """
        Additional tcp forwarding rules
        """
        rdps: NotRequired[Sequence['GetRuleVmTcpRdpArgsDict']]
        """
        RDP configuration
        """
        sshes: NotRequired[Sequence['GetRuleVmTcpSshArgsDict']]
        """
        SSH configuration
        """
elif False:
    GetRuleVmTcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmTcpArgs:
    def __init__(__self__, *,
                 proxy_id: _builtins.str,
                 forward_rules: Optional[Sequence['GetRuleVmTcpForwardRuleArgs']] = None,
                 rdps: Optional[Sequence['GetRuleVmTcpRdpArgs']] = None,
                 sshes: Optional[Sequence['GetRuleVmTcpSshArgs']] = None):
        """
        :param _builtins.str proxy_id: Id of the Proxy
        :param Sequence['GetRuleVmTcpForwardRuleArgs'] forward_rules: Additional tcp forwarding rules
        :param Sequence['GetRuleVmTcpRdpArgs'] rdps: RDP configuration
        :param Sequence['GetRuleVmTcpSshArgs'] sshes: SSH configuration
        """
        pulumi.set(__self__, "proxy_id", proxy_id)
        if forward_rules is not None:
            pulumi.set(__self__, "forward_rules", forward_rules)
        if rdps is not None:
            pulumi.set(__self__, "rdps", rdps)
        if sshes is not None:
            pulumi.set(__self__, "sshes", sshes)

    @_builtins.property
    @pulumi.getter(name="proxyId")
    def proxy_id(self) -> _builtins.str:
        """
        Id of the Proxy
        """
        return pulumi.get(self, "proxy_id")

    @proxy_id.setter
    def proxy_id(self, value: _builtins.str):
        pulumi.set(self, "proxy_id", value)

    @_builtins.property
    @pulumi.getter(name="forwardRules")
    def forward_rules(self) -> Optional[Sequence['GetRuleVmTcpForwardRuleArgs']]:
        """
        Additional tcp forwarding rules
        """
        return pulumi.get(self, "forward_rules")

    @forward_rules.setter
    def forward_rules(self, value: Optional[Sequence['GetRuleVmTcpForwardRuleArgs']]):
        pulumi.set(self, "forward_rules", value)

    @_builtins.property
    @pulumi.getter
    def rdps(self) -> Optional[Sequence['GetRuleVmTcpRdpArgs']]:
        """
        RDP configuration
        """
        return pulumi.get(self, "rdps")

    @rdps.setter
    def rdps(self, value: Optional[Sequence['GetRuleVmTcpRdpArgs']]):
        pulumi.set(self, "rdps", value)

    @_builtins.property
    @pulumi.getter
    def sshes(self) -> Optional[Sequence['GetRuleVmTcpSshArgs']]:
        """
        SSH configuration
        """
        return pulumi.get(self, "sshes")

    @sshes.setter
    def sshes(self, value: Optional[Sequence['GetRuleVmTcpSshArgs']]):
        pulumi.set(self, "sshes", value)


if not MYPY:
    class GetRuleVmTcpForwardRuleArgsDict(TypedDict):
        port: _builtins.int
        """
        Port to listen on the vm
        """
        connect_on: NotRequired[_builtins.int]
        """
        Port to listen on the proxy
        """
elif False:
    GetRuleVmTcpForwardRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmTcpForwardRuleArgs:
    def __init__(__self__, *,
                 port: _builtins.int,
                 connect_on: Optional[_builtins.int] = None):
        """
        :param _builtins.int port: Port to listen on the vm
        :param _builtins.int connect_on: Port to listen on the proxy
        """
        pulumi.set(__self__, "port", port)
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[_builtins.int]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[_builtins.int]):
        pulumi.set(self, "connect_on", value)


if not MYPY:
    class GetRuleVmTcpRdpArgsDict(TypedDict):
        connect_on: NotRequired[_builtins.int]
        """
        Port to listen on the proxy
        """
        port: NotRequired[_builtins.int]
        """
        Port to listen on the vm
        """
elif False:
    GetRuleVmTcpRdpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmTcpRdpArgs:
    def __init__(__self__, *,
                 connect_on: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.int connect_on: Port to listen on the proxy
        :param _builtins.int port: Port to listen on the vm
        """
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[_builtins.int]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[_builtins.int]):
        pulumi.set(self, "connect_on", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[_builtins.int]):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetRuleVmTcpSshArgsDict(TypedDict):
        connect_on: NotRequired[_builtins.int]
        """
        Port to listen on the proxy
        """
        port: NotRequired[_builtins.int]
        """
        Port to listen on the vm
        """
elif False:
    GetRuleVmTcpSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRuleVmTcpSshArgs:
    def __init__(__self__, *,
                 connect_on: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.int connect_on: Port to listen on the proxy
        :param _builtins.int port: Port to listen on the vm
        """
        if connect_on is not None:
            pulumi.set(__self__, "connect_on", connect_on)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="connectOn")
    def connect_on(self) -> Optional[_builtins.int]:
        """
        Port to listen on the proxy
        """
        return pulumi.get(self, "connect_on")

    @connect_on.setter
    def connect_on(self, value: Optional[_builtins.int]):
        pulumi.set(self, "connect_on", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port to listen on the vm
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[_builtins.int]):
        pulumi.set(self, "port", value)


