# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = [
    'GetInfraModuleTestingResult',
    'AwaitableGetInfraModuleTestingResult',
    'get_infra_module_testing',
    'get_infra_module_testing_output',
]

@pulumi.output_type
class GetInfraModuleTestingResult:
    """
    A collection of values returned by getInfraModuleTesting.
    """
    def __init__(__self__, account=None, created=None, description=None, git_tag_style=None, id=None, module_error=None, module_id=None, name=None, org=None, pipelines=None, project=None, provider_connector=None, provisioner_type=None, provisioner_version=None, release_pipeline=None, repository=None, repository_branch=None, repository_commit=None, repository_connector=None, repository_path=None, repository_url=None, synced=None, system=None, tags=None, testing_enabled=None, testing_metadata=None, updated=None, versions=None):
        if account and not isinstance(account, str):
            raise TypeError("Expected argument 'account' to be a str")
        pulumi.set(__self__, "account", account)
        if created and not isinstance(created, int):
            raise TypeError("Expected argument 'created' to be a int")
        pulumi.set(__self__, "created", created)
        if description and not isinstance(description, str):
            raise TypeError("Expected argument 'description' to be a str")
        pulumi.set(__self__, "description", description)
        if git_tag_style and not isinstance(git_tag_style, str):
            raise TypeError("Expected argument 'git_tag_style' to be a str")
        pulumi.set(__self__, "git_tag_style", git_tag_style)
        if id and not isinstance(id, str):
            raise TypeError("Expected argument 'id' to be a str")
        pulumi.set(__self__, "id", id)
        if module_error and not isinstance(module_error, str):
            raise TypeError("Expected argument 'module_error' to be a str")
        pulumi.set(__self__, "module_error", module_error)
        if module_id and not isinstance(module_id, str):
            raise TypeError("Expected argument 'module_id' to be a str")
        pulumi.set(__self__, "module_id", module_id)
        if name and not isinstance(name, str):
            raise TypeError("Expected argument 'name' to be a str")
        pulumi.set(__self__, "name", name)
        if org and not isinstance(org, str):
            raise TypeError("Expected argument 'org' to be a str")
        pulumi.set(__self__, "org", org)
        if pipelines and not isinstance(pipelines, list):
            raise TypeError("Expected argument 'pipelines' to be a list")
        pulumi.set(__self__, "pipelines", pipelines)
        if project and not isinstance(project, str):
            raise TypeError("Expected argument 'project' to be a str")
        pulumi.set(__self__, "project", project)
        if provider_connector and not isinstance(provider_connector, str):
            raise TypeError("Expected argument 'provider_connector' to be a str")
        pulumi.set(__self__, "provider_connector", provider_connector)
        if provisioner_type and not isinstance(provisioner_type, str):
            raise TypeError("Expected argument 'provisioner_type' to be a str")
        pulumi.set(__self__, "provisioner_type", provisioner_type)
        if provisioner_version and not isinstance(provisioner_version, str):
            raise TypeError("Expected argument 'provisioner_version' to be a str")
        pulumi.set(__self__, "provisioner_version", provisioner_version)
        if release_pipeline and not isinstance(release_pipeline, str):
            raise TypeError("Expected argument 'release_pipeline' to be a str")
        pulumi.set(__self__, "release_pipeline", release_pipeline)
        if repository and not isinstance(repository, str):
            raise TypeError("Expected argument 'repository' to be a str")
        pulumi.set(__self__, "repository", repository)
        if repository_branch and not isinstance(repository_branch, str):
            raise TypeError("Expected argument 'repository_branch' to be a str")
        pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit and not isinstance(repository_commit, str):
            raise TypeError("Expected argument 'repository_commit' to be a str")
        pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_connector and not isinstance(repository_connector, str):
            raise TypeError("Expected argument 'repository_connector' to be a str")
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_path and not isinstance(repository_path, str):
            raise TypeError("Expected argument 'repository_path' to be a str")
        pulumi.set(__self__, "repository_path", repository_path)
        if repository_url and not isinstance(repository_url, str):
            raise TypeError("Expected argument 'repository_url' to be a str")
        pulumi.set(__self__, "repository_url", repository_url)
        if synced and not isinstance(synced, int):
            raise TypeError("Expected argument 'synced' to be a int")
        pulumi.set(__self__, "synced", synced)
        if system and not isinstance(system, str):
            raise TypeError("Expected argument 'system' to be a str")
        pulumi.set(__self__, "system", system)
        if tags and not isinstance(tags, str):
            raise TypeError("Expected argument 'tags' to be a str")
        pulumi.set(__self__, "tags", tags)
        if testing_enabled and not isinstance(testing_enabled, bool):
            raise TypeError("Expected argument 'testing_enabled' to be a bool")
        pulumi.set(__self__, "testing_enabled", testing_enabled)
        if testing_metadata and not isinstance(testing_metadata, dict):
            raise TypeError("Expected argument 'testing_metadata' to be a dict")
        pulumi.set(__self__, "testing_metadata", testing_metadata)
        if updated and not isinstance(updated, int):
            raise TypeError("Expected argument 'updated' to be a int")
        pulumi.set(__self__, "updated", updated)
        if versions and not isinstance(versions, list):
            raise TypeError("Expected argument 'versions' to be a list")
        pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def account(self) -> _builtins.str:
        """
        Account that owns the module
        """
        return pulumi.get(self, "account")

    @_builtins.property
    @pulumi.getter
    def created(self) -> _builtins.int:
        """
        Timestamp when the module was created
        """
        return pulumi.get(self, "created")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the module
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="gitTagStyle")
    def git_tag_style(self) -> _builtins.str:
        """
        Git Tag Style
        """
        return pulumi.get(self, "git_tag_style")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The provider-assigned unique ID for this managed resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="moduleError")
    def module_error(self) -> _builtins.str:
        """
        Error while retrieving the module
        """
        return pulumi.get(self, "module_error")

    @_builtins.property
    @pulumi.getter(name="moduleId")
    def module_id(self) -> _builtins.str:
        """
        Identifier of the module to enable testing for
        """
        return pulumi.get(self, "module_id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the module
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def org(self) -> _builtins.str:
        """
        Organization identifier
        """
        return pulumi.get(self, "org")

    @_builtins.property
    @pulumi.getter
    def pipelines(self) -> Sequence[_builtins.str]:
        """
        List of pipeline IDs to create webhooks for triggering test executions
        """
        return pulumi.get(self, "pipelines")

    @_builtins.property
    @pulumi.getter
    def project(self) -> _builtins.str:
        """
        Project identifier
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="providerConnector")
    def provider_connector(self) -> _builtins.str:
        """
        Provider connector for testing purposes
        """
        return pulumi.get(self, "provider_connector")

    @_builtins.property
    @pulumi.getter(name="provisionerType")
    def provisioner_type(self) -> _builtins.str:
        return pulumi.get(self, "provisioner_type")

    @_builtins.property
    @pulumi.getter(name="provisionerVersion")
    def provisioner_version(self) -> _builtins.str:
        """
        Provisioner version for testing purposes
        """
        return pulumi.get(self, "provisioner_version")

    @_builtins.property
    @pulumi.getter(name="releasePipeline")
    def release_pipeline(self) -> Optional[_builtins.str]:
        """
        Pipeline ID to create webhooks for releases
        """
        return pulumi.get(self, "release_pipeline")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        For account connectors, the repository where the module is stored
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> _builtins.str:
        """
        Repository Branch in which the module should be accessed
        """
        return pulumi.get(self, "repository_branch")

    @_builtins.property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> _builtins.str:
        """
        Repository Commit in which the module should be accessed
        """
        return pulumi.get(self, "repository_commit")

    @_builtins.property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> _builtins.str:
        """
        Repository Connector is the reference to the connector for the repository
        """
        return pulumi.get(self, "repository_connector")

    @_builtins.property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> _builtins.str:
        """
        Repository Path is the path in which the module resides
        """
        return pulumi.get(self, "repository_path")

    @_builtins.property
    @pulumi.getter(name="repositoryUrl")
    def repository_url(self) -> _builtins.str:
        """
        URL where the module is stored
        """
        return pulumi.get(self, "repository_url")

    @_builtins.property
    @pulumi.getter
    def synced(self) -> _builtins.int:
        """
        Timestamp when the module was last synced
        """
        return pulumi.get(self, "synced")

    @_builtins.property
    @pulumi.getter
    def system(self) -> _builtins.str:
        """
        Provider of the module
        """
        return pulumi.get(self, "system")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> _builtins.str:
        """
        Tags associated with the module
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="testingEnabled")
    def testing_enabled(self) -> _builtins.bool:
        """
        Whether testing is enabled for the module
        """
        return pulumi.get(self, "testing_enabled")

    @_builtins.property
    @pulumi.getter(name="testingMetadata")
    def testing_metadata(self) -> 'outputs.GetInfraModuleTestingTestingMetadataResult':
        """
        Testing metadata for the module
        """
        return pulumi.get(self, "testing_metadata")

    @_builtins.property
    @pulumi.getter
    def updated(self) -> _builtins.int:
        """
        Timestamp when the module was last modified
        """
        return pulumi.get(self, "updated")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Sequence[_builtins.str]:
        """
        Versions of the module
        """
        return pulumi.get(self, "versions")


class AwaitableGetInfraModuleTestingResult(GetInfraModuleTestingResult):
    # pylint: disable=using-constant-test
    def __await__(self):
        if False:
            yield self
        return GetInfraModuleTestingResult(
            account=self.account,
            created=self.created,
            description=self.description,
            git_tag_style=self.git_tag_style,
            id=self.id,
            module_error=self.module_error,
            module_id=self.module_id,
            name=self.name,
            org=self.org,
            pipelines=self.pipelines,
            project=self.project,
            provider_connector=self.provider_connector,
            provisioner_type=self.provisioner_type,
            provisioner_version=self.provisioner_version,
            release_pipeline=self.release_pipeline,
            repository=self.repository,
            repository_branch=self.repository_branch,
            repository_commit=self.repository_commit,
            repository_connector=self.repository_connector,
            repository_path=self.repository_path,
            repository_url=self.repository_url,
            synced=self.synced,
            system=self.system,
            tags=self.tags,
            testing_enabled=self.testing_enabled,
            testing_metadata=self.testing_metadata,
            updated=self.updated,
            versions=self.versions)


def get_infra_module_testing(module_id: Optional[_builtins.str] = None,
                             org: Optional[_builtins.str] = None,
                             pipelines: Optional[Sequence[_builtins.str]] = None,
                             project: Optional[_builtins.str] = None,
                             provider_connector: Optional[_builtins.str] = None,
                             provisioner_type: Optional[_builtins.str] = None,
                             provisioner_version: Optional[_builtins.str] = None,
                             release_pipeline: Optional[_builtins.str] = None,
                             testing_enabled: Optional[_builtins.bool] = None,
                             testing_metadata: Optional[Union['GetInfraModuleTestingTestingMetadataArgs', 'GetInfraModuleTestingTestingMetadataArgsDict']] = None,
                             updated: Optional[_builtins.int] = None,
                             versions: Optional[Sequence[_builtins.str]] = None,
                             opts: Optional[pulumi.InvokeOptions] = None) -> AwaitableGetInfraModuleTestingResult:
    """
    Data source for retrieving modules testing metadata from the module registry.


    :param _builtins.str module_id: Identifier of the module to enable testing for
    :param _builtins.str org: Organization identifier
    :param Sequence[_builtins.str] pipelines: List of pipeline IDs to create webhooks for triggering test executions
    :param _builtins.str project: Project identifier
    :param _builtins.str provider_connector: Provider connector for testing purposes
    :param _builtins.str provisioner_version: Provisioner version for testing purposes
    :param _builtins.str release_pipeline: Pipeline ID to create webhooks for releases
    :param _builtins.bool testing_enabled: Whether testing is enabled for the module
    :param Union['GetInfraModuleTestingTestingMetadataArgs', 'GetInfraModuleTestingTestingMetadataArgsDict'] testing_metadata: Testing metadata for the module
    :param _builtins.int updated: Timestamp when the module was last modified
    :param Sequence[_builtins.str] versions: Versions of the module
    """
    __args__ = dict()
    __args__['moduleId'] = module_id
    __args__['org'] = org
    __args__['pipelines'] = pipelines
    __args__['project'] = project
    __args__['providerConnector'] = provider_connector
    __args__['provisionerType'] = provisioner_type
    __args__['provisionerVersion'] = provisioner_version
    __args__['releasePipeline'] = release_pipeline
    __args__['testingEnabled'] = testing_enabled
    __args__['testingMetadata'] = testing_metadata
    __args__['updated'] = updated
    __args__['versions'] = versions
    opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke('harness:platform/getInfraModuleTesting:getInfraModuleTesting', __args__, opts=opts, typ=GetInfraModuleTestingResult).value

    return AwaitableGetInfraModuleTestingResult(
        account=pulumi.get(__ret__, 'account'),
        created=pulumi.get(__ret__, 'created'),
        description=pulumi.get(__ret__, 'description'),
        git_tag_style=pulumi.get(__ret__, 'git_tag_style'),
        id=pulumi.get(__ret__, 'id'),
        module_error=pulumi.get(__ret__, 'module_error'),
        module_id=pulumi.get(__ret__, 'module_id'),
        name=pulumi.get(__ret__, 'name'),
        org=pulumi.get(__ret__, 'org'),
        pipelines=pulumi.get(__ret__, 'pipelines'),
        project=pulumi.get(__ret__, 'project'),
        provider_connector=pulumi.get(__ret__, 'provider_connector'),
        provisioner_type=pulumi.get(__ret__, 'provisioner_type'),
        provisioner_version=pulumi.get(__ret__, 'provisioner_version'),
        release_pipeline=pulumi.get(__ret__, 'release_pipeline'),
        repository=pulumi.get(__ret__, 'repository'),
        repository_branch=pulumi.get(__ret__, 'repository_branch'),
        repository_commit=pulumi.get(__ret__, 'repository_commit'),
        repository_connector=pulumi.get(__ret__, 'repository_connector'),
        repository_path=pulumi.get(__ret__, 'repository_path'),
        repository_url=pulumi.get(__ret__, 'repository_url'),
        synced=pulumi.get(__ret__, 'synced'),
        system=pulumi.get(__ret__, 'system'),
        tags=pulumi.get(__ret__, 'tags'),
        testing_enabled=pulumi.get(__ret__, 'testing_enabled'),
        testing_metadata=pulumi.get(__ret__, 'testing_metadata'),
        updated=pulumi.get(__ret__, 'updated'),
        versions=pulumi.get(__ret__, 'versions'))
def get_infra_module_testing_output(module_id: Optional[pulumi.Input[_builtins.str]] = None,
                                    org: Optional[pulumi.Input[_builtins.str]] = None,
                                    pipelines: Optional[pulumi.Input[Sequence[_builtins.str]]] = None,
                                    project: Optional[pulumi.Input[_builtins.str]] = None,
                                    provider_connector: Optional[pulumi.Input[_builtins.str]] = None,
                                    provisioner_type: Optional[pulumi.Input[_builtins.str]] = None,
                                    provisioner_version: Optional[pulumi.Input[_builtins.str]] = None,
                                    release_pipeline: Optional[pulumi.Input[Optional[_builtins.str]]] = None,
                                    testing_enabled: Optional[pulumi.Input[Optional[_builtins.bool]]] = None,
                                    testing_metadata: Optional[pulumi.Input[Optional[Union['GetInfraModuleTestingTestingMetadataArgs', 'GetInfraModuleTestingTestingMetadataArgsDict']]]] = None,
                                    updated: Optional[pulumi.Input[Optional[_builtins.int]]] = None,
                                    versions: Optional[pulumi.Input[Optional[Sequence[_builtins.str]]]] = None,
                                    opts: Optional[Union[pulumi.InvokeOptions, pulumi.InvokeOutputOptions]] = None) -> pulumi.Output[GetInfraModuleTestingResult]:
    """
    Data source for retrieving modules testing metadata from the module registry.


    :param _builtins.str module_id: Identifier of the module to enable testing for
    :param _builtins.str org: Organization identifier
    :param Sequence[_builtins.str] pipelines: List of pipeline IDs to create webhooks for triggering test executions
    :param _builtins.str project: Project identifier
    :param _builtins.str provider_connector: Provider connector for testing purposes
    :param _builtins.str provisioner_version: Provisioner version for testing purposes
    :param _builtins.str release_pipeline: Pipeline ID to create webhooks for releases
    :param _builtins.bool testing_enabled: Whether testing is enabled for the module
    :param Union['GetInfraModuleTestingTestingMetadataArgs', 'GetInfraModuleTestingTestingMetadataArgsDict'] testing_metadata: Testing metadata for the module
    :param _builtins.int updated: Timestamp when the module was last modified
    :param Sequence[_builtins.str] versions: Versions of the module
    """
    __args__ = dict()
    __args__['moduleId'] = module_id
    __args__['org'] = org
    __args__['pipelines'] = pipelines
    __args__['project'] = project
    __args__['providerConnector'] = provider_connector
    __args__['provisionerType'] = provisioner_type
    __args__['provisionerVersion'] = provisioner_version
    __args__['releasePipeline'] = release_pipeline
    __args__['testingEnabled'] = testing_enabled
    __args__['testingMetadata'] = testing_metadata
    __args__['updated'] = updated
    __args__['versions'] = versions
    opts = pulumi.InvokeOutputOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
    __ret__ = pulumi.runtime.invoke_output('harness:platform/getInfraModuleTesting:getInfraModuleTesting', __args__, opts=opts, typ=GetInfraModuleTestingResult)
    return __ret__.apply(lambda __response__: GetInfraModuleTestingResult(
        account=pulumi.get(__response__, 'account'),
        created=pulumi.get(__response__, 'created'),
        description=pulumi.get(__response__, 'description'),
        git_tag_style=pulumi.get(__response__, 'git_tag_style'),
        id=pulumi.get(__response__, 'id'),
        module_error=pulumi.get(__response__, 'module_error'),
        module_id=pulumi.get(__response__, 'module_id'),
        name=pulumi.get(__response__, 'name'),
        org=pulumi.get(__response__, 'org'),
        pipelines=pulumi.get(__response__, 'pipelines'),
        project=pulumi.get(__response__, 'project'),
        provider_connector=pulumi.get(__response__, 'provider_connector'),
        provisioner_type=pulumi.get(__response__, 'provisioner_type'),
        provisioner_version=pulumi.get(__response__, 'provisioner_version'),
        release_pipeline=pulumi.get(__response__, 'release_pipeline'),
        repository=pulumi.get(__response__, 'repository'),
        repository_branch=pulumi.get(__response__, 'repository_branch'),
        repository_commit=pulumi.get(__response__, 'repository_commit'),
        repository_connector=pulumi.get(__response__, 'repository_connector'),
        repository_path=pulumi.get(__response__, 'repository_path'),
        repository_url=pulumi.get(__response__, 'repository_url'),
        synced=pulumi.get(__response__, 'synced'),
        system=pulumi.get(__response__, 'system'),
        tags=pulumi.get(__response__, 'tags'),
        testing_enabled=pulumi.get(__response__, 'testing_enabled'),
        testing_metadata=pulumi.get(__response__, 'testing_metadata'),
        updated=pulumi.get(__response__, 'updated'),
        versions=pulumi.get(__response__, 'versions')))
