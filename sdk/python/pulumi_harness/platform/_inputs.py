# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppDynamicsConnectorApiTokenArgs',
    'AppDynamicsConnectorApiTokenArgsDict',
    'AppDynamicsConnectorUsernamePasswordArgs',
    'AppDynamicsConnectorUsernamePasswordArgsDict',
    'ArtifactoryConnectorCredentialsArgs',
    'ArtifactoryConnectorCredentialsArgsDict',
    'AwsCCConnectorCrossAccountAccessArgs',
    'AwsCCConnectorCrossAccountAccessArgsDict',
    'AwsConnectorCrossAccountAccessArgs',
    'AwsConnectorCrossAccountAccessArgsDict',
    'AwsConnectorEqualJitterBackoffStrategyArgs',
    'AwsConnectorEqualJitterBackoffStrategyArgsDict',
    'AwsConnectorFixedDelayBackoffStrategyArgs',
    'AwsConnectorFixedDelayBackoffStrategyArgsDict',
    'AwsConnectorFullJitterBackoffStrategyArgs',
    'AwsConnectorFullJitterBackoffStrategyArgsDict',
    'AwsConnectorInheritFromDelegateArgs',
    'AwsConnectorInheritFromDelegateArgsDict',
    'AwsConnectorIrsaArgs',
    'AwsConnectorIrsaArgsDict',
    'AwsConnectorManualArgs',
    'AwsConnectorManualArgsDict',
    'AwsConnectorOidcAuthenticationArgs',
    'AwsConnectorOidcAuthenticationArgsDict',
    'AwsKmsConnectorCredentialsArgs',
    'AwsKmsConnectorCredentialsArgsDict',
    'AwsKmsConnectorCredentialsAssumeRoleArgs',
    'AwsKmsConnectorCredentialsAssumeRoleArgsDict',
    'AwsKmsConnectorCredentialsManualArgs',
    'AwsKmsConnectorCredentialsManualArgsDict',
    'AwsKmsConnectorCredentialsOidcAuthenticationArgs',
    'AwsKmsConnectorCredentialsOidcAuthenticationArgsDict',
    'AwsSecretManagerConnectorCredentialsArgs',
    'AwsSecretManagerConnectorCredentialsArgsDict',
    'AwsSecretManagerConnectorCredentialsAssumeRoleArgs',
    'AwsSecretManagerConnectorCredentialsAssumeRoleArgsDict',
    'AwsSecretManagerConnectorCredentialsManualArgs',
    'AwsSecretManagerConnectorCredentialsManualArgsDict',
    'AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs',
    'AwsSecretManagerConnectorCredentialsOidcAuthenticationArgsDict',
    'AzureCloudCostConnectorBillingExportSpecArgs',
    'AzureCloudCostConnectorBillingExportSpecArgsDict',
    'AzureCloudProviderConnectorCredentialsArgs',
    'AzureCloudProviderConnectorCredentialsArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgsDict',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgsDict',
    'BitbucketConnectorApiAuthenticationArgs',
    'BitbucketConnectorApiAuthenticationArgsDict',
    'BitbucketConnectorCredentialsArgs',
    'BitbucketConnectorCredentialsArgsDict',
    'BitbucketConnectorCredentialsHttpArgs',
    'BitbucketConnectorCredentialsHttpArgsDict',
    'BitbucketConnectorCredentialsSshArgs',
    'BitbucketConnectorCredentialsSshArgsDict',
    'ConnectorAzureArtifactsCredentialsArgs',
    'ConnectorAzureArtifactsCredentialsArgsDict',
    'ConnectorAzureRepoApiAuthenticationArgs',
    'ConnectorAzureRepoApiAuthenticationArgsDict',
    'ConnectorAzureRepoCredentialsArgs',
    'ConnectorAzureRepoCredentialsArgsDict',
    'ConnectorAzureRepoCredentialsHttpArgs',
    'ConnectorAzureRepoCredentialsHttpArgsDict',
    'ConnectorAzureRepoCredentialsSshArgs',
    'ConnectorAzureRepoCredentialsSshArgsDict',
    'ConnectorCustomSecretManagerTemplateInputArgs',
    'ConnectorCustomSecretManagerTemplateInputArgsDict',
    'ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgs',
    'ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgsDict',
    'ConnectorCustomhealthsourceHeaderArgs',
    'ConnectorCustomhealthsourceHeaderArgsDict',
    'ConnectorCustomhealthsourceParamArgs',
    'ConnectorCustomhealthsourceParamArgsDict',
    'ConnectorGcpKmsManualArgs',
    'ConnectorGcpKmsManualArgsDict',
    'ConnectorGcpKmsOidcAuthenticationArgs',
    'ConnectorGcpKmsOidcAuthenticationArgsDict',
    'ConnectorJdbcCredentialsArgs',
    'ConnectorJdbcCredentialsArgsDict',
    'ConnectorJdbcCredentialsServiceAccountArgs',
    'ConnectorJdbcCredentialsServiceAccountArgsDict',
    'ConnectorJdbcCredentialsUsernamePasswordArgs',
    'ConnectorJdbcCredentialsUsernamePasswordArgsDict',
    'ConnectorPdcHostArgs',
    'ConnectorPdcHostArgsDict',
    'ConnectorRancherBearerTokenArgs',
    'ConnectorRancherBearerTokenArgsDict',
    'DbSchemaChangelogScriptArgs',
    'DbSchemaChangelogScriptArgsDict',
    'DbSchemaSchemaSourceArgs',
    'DbSchemaSchemaSourceArgsDict',
    'DockerConnectorCredentialsArgs',
    'DockerConnectorCredentialsArgsDict',
    'ElasticsearchConnectorApiTokenArgs',
    'ElasticsearchConnectorApiTokenArgsDict',
    'ElasticsearchConnectorNoAuthenticationArgs',
    'ElasticsearchConnectorNoAuthenticationArgsDict',
    'ElasticsearchConnectorUsernamePasswordArgs',
    'ElasticsearchConnectorUsernamePasswordArgsDict',
    'EnvironmentClustersMappingClusterArgs',
    'EnvironmentClustersMappingClusterArgsDict',
    'EnvironmentGitDetailsArgs',
    'EnvironmentGitDetailsArgsDict',
    'FeatureFlagEnvironmentArgs',
    'FeatureFlagEnvironmentArgsDict',
    'FeatureFlagEnvironmentAddTargetRuleArgs',
    'FeatureFlagEnvironmentAddTargetRuleArgsDict',
    'FeatureFlagTagArgs',
    'FeatureFlagTagArgsDict',
    'FeatureFlagTargetGroupRuleArgs',
    'FeatureFlagTargetGroupRuleArgsDict',
    'FeatureFlagVariationArgs',
    'FeatureFlagVariationArgsDict',
    'FileStoreFileCreatedByArgs',
    'FileStoreFileCreatedByArgsDict',
    'FileStoreFileLastModifiedByArgs',
    'FileStoreFileLastModifiedByArgsDict',
    'FileStoreFolderCreatedByArgs',
    'FileStoreFolderCreatedByArgsDict',
    'FileStoreFolderLastModifiedByArgs',
    'FileStoreFolderLastModifiedByArgsDict',
    'FiltersFilterPropertiesArgs',
    'FiltersFilterPropertiesArgsDict',
    'GcpCloudCostConnectorBillingExportSpecArgs',
    'GcpCloudCostConnectorBillingExportSpecArgsDict',
    'GcpConnectorInheritFromDelegateArgs',
    'GcpConnectorInheritFromDelegateArgsDict',
    'GcpConnectorManualArgs',
    'GcpConnectorManualArgsDict',
    'GcpConnectorOidcAuthenticationArgs',
    'GcpConnectorOidcAuthenticationArgsDict',
    'GcpSecretManagerConnectorOidcAuthenticationArgs',
    'GcpSecretManagerConnectorOidcAuthenticationArgsDict',
    'GitConnectorCredentialsArgs',
    'GitConnectorCredentialsArgsDict',
    'GitConnectorCredentialsHttpArgs',
    'GitConnectorCredentialsHttpArgsDict',
    'GitConnectorCredentialsSshArgs',
    'GitConnectorCredentialsSshArgsDict',
    'GitOpsAgentMetadataArgs',
    'GitOpsAgentMetadataArgsDict',
    'GitOpsApplicationsApplicationArgs',
    'GitOpsApplicationsApplicationArgsDict',
    'GitOpsApplicationsApplicationMetadataArgs',
    'GitOpsApplicationsApplicationMetadataArgsDict',
    'GitOpsApplicationsApplicationMetadataOwnerReferenceArgs',
    'GitOpsApplicationsApplicationMetadataOwnerReferenceArgsDict',
    'GitOpsApplicationsApplicationSpecArgs',
    'GitOpsApplicationsApplicationSpecArgsDict',
    'GitOpsApplicationsApplicationSpecDestinationArgs',
    'GitOpsApplicationsApplicationSpecDestinationArgsDict',
    'GitOpsApplicationsApplicationSpecSourceArgs',
    'GitOpsApplicationsApplicationSpecSourceArgsDict',
    'GitOpsApplicationsApplicationSpecSourceDirectoryArgs',
    'GitOpsApplicationsApplicationSpecSourceDirectoryArgsDict',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgsDict',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgsDict',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgsDict',
    'GitOpsApplicationsApplicationSpecSourceHelmArgs',
    'GitOpsApplicationsApplicationSpecSourceHelmArgsDict',
    'GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs',
    'GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgsDict',
    'GitOpsApplicationsApplicationSpecSourceHelmParameterArgs',
    'GitOpsApplicationsApplicationSpecSourceHelmParameterArgsDict',
    'GitOpsApplicationsApplicationSpecSourceKsonnetArgs',
    'GitOpsApplicationsApplicationSpecSourceKsonnetArgsDict',
    'GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs',
    'GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgsDict',
    'GitOpsApplicationsApplicationSpecSourceKustomizeArgs',
    'GitOpsApplicationsApplicationSpecSourceKustomizeArgsDict',
    'GitOpsApplicationsApplicationSpecSourcePluginArgs',
    'GitOpsApplicationsApplicationSpecSourcePluginArgsDict',
    'GitOpsApplicationsApplicationSpecSourcePluginEnvArgs',
    'GitOpsApplicationsApplicationSpecSourcePluginEnvArgsDict',
    'GitOpsApplicationsApplicationSpecSyncPolicyArgs',
    'GitOpsApplicationsApplicationSpecSyncPolicyArgsDict',
    'GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs',
    'GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgsDict',
    'GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs',
    'GitOpsApplicationsApplicationSpecSyncPolicyRetryArgsDict',
    'GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs',
    'GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgsDict',
    'GitOpsClusterRequestArgs',
    'GitOpsClusterRequestArgsDict',
    'GitOpsClusterRequestClusterArgs',
    'GitOpsClusterRequestClusterArgsDict',
    'GitOpsClusterRequestClusterConfigArgs',
    'GitOpsClusterRequestClusterConfigArgsDict',
    'GitOpsClusterRequestClusterConfigExecProviderConfigArgs',
    'GitOpsClusterRequestClusterConfigExecProviderConfigArgsDict',
    'GitOpsClusterRequestClusterConfigTlsClientConfigArgs',
    'GitOpsClusterRequestClusterConfigTlsClientConfigArgsDict',
    'GitOpsClusterRequestClusterInfoArgs',
    'GitOpsClusterRequestClusterInfoArgsDict',
    'GitOpsClusterRequestClusterInfoCacheInfoArgs',
    'GitOpsClusterRequestClusterInfoCacheInfoArgsDict',
    'GitOpsClusterRequestClusterInfoConnectionStateArgs',
    'GitOpsClusterRequestClusterInfoConnectionStateArgsDict',
    'GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs',
    'GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgsDict',
    'GitOpsClusterRequestClusterRefreshRequestedAtArgs',
    'GitOpsClusterRequestClusterRefreshRequestedAtArgsDict',
    'GitOpsGnupgRequestArgs',
    'GitOpsGnupgRequestArgsDict',
    'GitOpsGnupgRequestPublickeyArgs',
    'GitOpsGnupgRequestPublickeyArgsDict',
    'GitOpsRepoCertRequestArgs',
    'GitOpsRepoCertRequestArgsDict',
    'GitOpsRepoCertRequestCertificateArgs',
    'GitOpsRepoCertRequestCertificateArgsDict',
    'GitOpsRepoCertRequestCertificateItemArgs',
    'GitOpsRepoCertRequestCertificateItemArgsDict',
    'GitOpsRepoCertRequestCertificateMetadataArgs',
    'GitOpsRepoCertRequestCertificateMetadataArgsDict',
    'GitOpsRepoCredCredArgs',
    'GitOpsRepoCredCredArgsDict',
    'GitOpsRepositoryEcrGenArgs',
    'GitOpsRepositoryEcrGenArgsDict',
    'GitOpsRepositoryEcrGenJwtAuthArgs',
    'GitOpsRepositoryEcrGenJwtAuthArgsDict',
    'GitOpsRepositoryEcrGenSecretRefArgs',
    'GitOpsRepositoryEcrGenSecretRefArgsDict',
    'GitOpsRepositoryGcrGenArgs',
    'GitOpsRepositoryGcrGenArgsDict',
    'GitOpsRepositoryGcrGenWorkloadIdentityArgs',
    'GitOpsRepositoryGcrGenWorkloadIdentityArgsDict',
    'GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs',
    'GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgsDict',
    'GitOpsRepositoryRepoArgs',
    'GitOpsRepositoryRepoArgsDict',
    'GitOpsRepositoryUpdateMaskArgs',
    'GitOpsRepositoryUpdateMaskArgsDict',
    'GithubConnectorApiAuthenticationArgs',
    'GithubConnectorApiAuthenticationArgsDict',
    'GithubConnectorApiAuthenticationGithubAppArgs',
    'GithubConnectorApiAuthenticationGithubAppArgsDict',
    'GithubConnectorCredentialsArgs',
    'GithubConnectorCredentialsArgsDict',
    'GithubConnectorCredentialsHttpArgs',
    'GithubConnectorCredentialsHttpArgsDict',
    'GithubConnectorCredentialsHttpAnonymouseArgs',
    'GithubConnectorCredentialsHttpAnonymouseArgsDict',
    'GithubConnectorCredentialsHttpGithubAppArgs',
    'GithubConnectorCredentialsHttpGithubAppArgsDict',
    'GithubConnectorCredentialsSshArgs',
    'GithubConnectorCredentialsSshArgsDict',
    'GitlabConnectorApiAuthenticationArgs',
    'GitlabConnectorApiAuthenticationArgsDict',
    'GitlabConnectorCredentialsArgs',
    'GitlabConnectorCredentialsArgsDict',
    'GitlabConnectorCredentialsHttpArgs',
    'GitlabConnectorCredentialsHttpArgsDict',
    'GitlabConnectorCredentialsSshArgs',
    'GitlabConnectorCredentialsSshArgsDict',
    'GitopsAppProjectProjectArgs',
    'GitopsAppProjectProjectArgsDict',
    'GitopsAppProjectProjectMetadataArgs',
    'GitopsAppProjectProjectMetadataArgsDict',
    'GitopsAppProjectProjectMetadataManagedFieldArgs',
    'GitopsAppProjectProjectMetadataManagedFieldArgsDict',
    'GitopsAppProjectProjectSpecArgs',
    'GitopsAppProjectProjectSpecArgsDict',
    'GitopsAppProjectProjectSpecClusterResourceBlacklistArgs',
    'GitopsAppProjectProjectSpecClusterResourceBlacklistArgsDict',
    'GitopsAppProjectProjectSpecClusterResourceWhitelistArgs',
    'GitopsAppProjectProjectSpecClusterResourceWhitelistArgsDict',
    'GitopsAppProjectProjectSpecDestinationArgs',
    'GitopsAppProjectProjectSpecDestinationArgsDict',
    'GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs',
    'GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgsDict',
    'GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs',
    'GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgsDict',
    'GitopsAppProjectProjectSpecOrphanedResourceArgs',
    'GitopsAppProjectProjectSpecOrphanedResourceArgsDict',
    'GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs',
    'GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgsDict',
    'GitopsAppProjectProjectSpecRoleArgs',
    'GitopsAppProjectProjectSpecRoleArgsDict',
    'GitopsAppProjectProjectSpecRoleJwtTokenArgs',
    'GitopsAppProjectProjectSpecRoleJwtTokenArgsDict',
    'GitopsAppProjectProjectSpecSignatureKeyArgs',
    'GitopsAppProjectProjectSpecSignatureKeyArgsDict',
    'GitopsAppProjectProjectSpecSyncWindowArgs',
    'GitopsAppProjectProjectSpecSyncWindowArgsDict',
    'HarRegistryConfigArgs',
    'HarRegistryConfigArgsDict',
    'HarRegistryConfigAuthArgs',
    'HarRegistryConfigAuthArgsDict',
    'HelmConnectorCredentialsArgs',
    'HelmConnectorCredentialsArgsDict',
    'InfraVariableSetConnectorArgs',
    'InfraVariableSetConnectorArgsDict',
    'InfraVariableSetEnvironmentVariableArgs',
    'InfraVariableSetEnvironmentVariableArgsDict',
    'InfraVariableSetTerraformVariableArgs',
    'InfraVariableSetTerraformVariableArgsDict',
    'InfraVariableSetTerraformVariableFileArgs',
    'InfraVariableSetTerraformVariableFileArgsDict',
    'InfrastructureGitDetailsArgs',
    'InfrastructureGitDetailsArgsDict',
    'InputSetGitDetailsArgs',
    'InputSetGitDetailsArgsDict',
    'InputSetGitImportInfoArgs',
    'InputSetGitImportInfoArgsDict',
    'InputSetInputSetImportRequestArgs',
    'InputSetInputSetImportRequestArgsDict',
    'JenkinsConnectorAuthArgs',
    'JenkinsConnectorAuthArgsDict',
    'JenkinsConnectorAuthJenkinsBearerTokenArgs',
    'JenkinsConnectorAuthJenkinsBearerTokenArgsDict',
    'JenkinsConnectorAuthJenkinsUserNamePasswordArgs',
    'JenkinsConnectorAuthJenkinsUserNamePasswordArgsDict',
    'JiraConnectorAuthArgs',
    'JiraConnectorAuthArgsDict',
    'JiraConnectorAuthPersonalAccessTokenArgs',
    'JiraConnectorAuthPersonalAccessTokenArgsDict',
    'JiraConnectorAuthUsernamePasswordArgs',
    'JiraConnectorAuthUsernamePasswordArgsDict',
    'KubernetesConnectorClientKeyCertArgs',
    'KubernetesConnectorClientKeyCertArgsDict',
    'KubernetesConnectorInheritFromDelegateArgs',
    'KubernetesConnectorInheritFromDelegateArgsDict',
    'KubernetesConnectorOpenidConnectArgs',
    'KubernetesConnectorOpenidConnectArgsDict',
    'KubernetesConnectorServiceAccountArgs',
    'KubernetesConnectorServiceAccountArgsDict',
    'KubernetesConnectorUsernamePasswordArgs',
    'KubernetesConnectorUsernamePasswordArgsDict',
    'ManualFreezeCurrentOrUpcomingWindowArgs',
    'ManualFreezeCurrentOrUpcomingWindowArgsDict',
    'ManualFreezeFreezeWindowArgs',
    'ManualFreezeFreezeWindowArgsDict',
    'ManualFreezeFreezeWindowRecurrenceArgs',
    'ManualFreezeFreezeWindowRecurrenceArgsDict',
    'ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs',
    'ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgsDict',
    'MonitoredServiceRequestArgs',
    'MonitoredServiceRequestArgsDict',
    'MonitoredServiceRequestChangeSourceArgs',
    'MonitoredServiceRequestChangeSourceArgsDict',
    'MonitoredServiceRequestDependencyArgs',
    'MonitoredServiceRequestDependencyArgsDict',
    'MonitoredServiceRequestHealthSourceArgs',
    'MonitoredServiceRequestHealthSourceArgsDict',
    'MonitoredServiceRequestNotificationRuleRefArgs',
    'MonitoredServiceRequestNotificationRuleRefArgsDict',
    'NexusConnectorCredentialsArgs',
    'NexusConnectorCredentialsArgsDict',
    'NotificationRuleRequestArgs',
    'NotificationRuleRequestArgsDict',
    'NotificationRuleRequestConditionArgs',
    'NotificationRuleRequestConditionArgsDict',
    'NotificationRuleRequestNotificationMethodArgs',
    'NotificationRuleRequestNotificationMethodArgsDict',
    'OciHelmConnectorCredentialsArgs',
    'OciHelmConnectorCredentialsArgsDict',
    'OverridesGitDetailsArgs',
    'OverridesGitDetailsArgsDict',
    'PipelineFiltersFilterPropertiesArgs',
    'PipelineFiltersFilterPropertiesArgsDict',
    'PipelineFiltersFilterPropertiesModulePropertiesArgs',
    'PipelineFiltersFilterPropertiesModulePropertiesArgsDict',
    'PipelineFiltersFilterPropertiesModulePropertiesCdArgs',
    'PipelineFiltersFilterPropertiesModulePropertiesCdArgsDict',
    'PipelineFiltersFilterPropertiesModulePropertiesCiArgs',
    'PipelineFiltersFilterPropertiesModulePropertiesCiArgsDict',
    'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs',
    'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgsDict',
    'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs',
    'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgsDict',
    'PipelineGitDetailsArgs',
    'PipelineGitDetailsArgsDict',
    'PipelineGitImportInfoArgs',
    'PipelineGitImportInfoArgsDict',
    'PipelinePipelineImportRequestArgs',
    'PipelinePipelineImportRequestArgsDict',
    'PolicySetPolicyArgs',
    'PolicySetPolicyArgsDict',
    'PrometheusConnectorHeaderArgs',
    'PrometheusConnectorHeaderArgsDict',
    'ProviderSpecArgs',
    'ProviderSpecArgsDict',
    'RepoRuleBranchBypassArgs',
    'RepoRuleBranchBypassArgsDict',
    'RepoRuleBranchPatternArgs',
    'RepoRuleBranchPatternArgsDict',
    'RepoRuleBranchPolicyArgs',
    'RepoRuleBranchPolicyArgsDict',
    'RepoSourceArgs',
    'RepoSourceArgsDict',
    'ResourceGroupIncludedScopeArgs',
    'ResourceGroupIncludedScopeArgsDict',
    'ResourceGroupResourceFilterArgs',
    'ResourceGroupResourceFilterArgsDict',
    'ResourceGroupResourceFilterResourceArgs',
    'ResourceGroupResourceFilterResourceArgsDict',
    'ResourceGroupResourceFilterResourceAttributeFilterArgs',
    'ResourceGroupResourceFilterResourceAttributeFilterArgsDict',
    'RoleAssignmentsPrincipalArgs',
    'RoleAssignmentsPrincipalArgsDict',
    'SecretSshkeyKerberosArgs',
    'SecretSshkeyKerberosArgsDict',
    'SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs',
    'SecretSshkeyKerberosTgtKeyTabFilePathSpecArgsDict',
    'SecretSshkeyKerberosTgtPasswordSpecArgs',
    'SecretSshkeyKerberosTgtPasswordSpecArgsDict',
    'SecretSshkeySshArgs',
    'SecretSshkeySshArgsDict',
    'SecretSshkeySshSshPasswordCredentialArgs',
    'SecretSshkeySshSshPasswordCredentialArgsDict',
    'SecretSshkeySshSshkeyPathCredentialArgs',
    'SecretSshkeySshSshkeyPathCredentialArgsDict',
    'SecretSshkeySshSshkeyReferenceCredentialArgs',
    'SecretSshkeySshSshkeyReferenceCredentialArgsDict',
    'SecretTextAdditionalMetadataArgs',
    'SecretTextAdditionalMetadataArgsDict',
    'SecretTextAdditionalMetadataValueArgs',
    'SecretTextAdditionalMetadataValueArgsDict',
    'ServiceGitDetailsArgs',
    'ServiceGitDetailsArgsDict',
    'ServiceNowConnectorAuthArgs',
    'ServiceNowConnectorAuthArgsDict',
    'ServiceNowConnectorAuthAdfsArgs',
    'ServiceNowConnectorAuthAdfsArgsDict',
    'ServiceNowConnectorAuthRefreshTokenArgs',
    'ServiceNowConnectorAuthRefreshTokenArgsDict',
    'ServiceNowConnectorAuthUsernamePasswordArgs',
    'ServiceNowConnectorAuthUsernamePasswordArgsDict',
    'ServiceOverridesV2GitDetailsArgs',
    'ServiceOverridesV2GitDetailsArgsDict',
    'SloRequestArgs',
    'SloRequestArgsDict',
    'SloRequestNotificationRuleRefArgs',
    'SloRequestNotificationRuleRefArgsDict',
    'SloRequestSloTargetArgs',
    'SloRequestSloTargetArgsDict',
    'SpotConnectorPermanentTokenArgs',
    'SpotConnectorPermanentTokenArgsDict',
    'TasConnectorCredentialsArgs',
    'TasConnectorCredentialsArgsDict',
    'TasConnectorCredentialsTasManualDetailsArgs',
    'TasConnectorCredentialsTasManualDetailsArgsDict',
    'TemplateFiltersFilterPropertiesArgs',
    'TemplateFiltersFilterPropertiesArgsDict',
    'TemplateGitDetailsArgs',
    'TemplateGitDetailsArgsDict',
    'TemplateGitImportDetailsArgs',
    'TemplateGitImportDetailsArgsDict',
    'TemplateTemplateImportRequestArgs',
    'TemplateTemplateImportRequestArgsDict',
    'TerraformCloudConnectorCredentialsArgs',
    'TerraformCloudConnectorCredentialsArgsDict',
    'TerraformCloudConnectorCredentialsApiTokenArgs',
    'TerraformCloudConnectorCredentialsApiTokenArgsDict',
    'UserRoleBindingArgs',
    'UserRoleBindingArgsDict',
    'UsergroupNotificationConfigArgs',
    'UsergroupNotificationConfigArgsDict',
    'VariablesSpecArgs',
    'VariablesSpecArgsDict',
    'WorkspaceEnvironmentVariableArgs',
    'WorkspaceEnvironmentVariableArgsDict',
    'WorkspaceTerraformVariableArgs',
    'WorkspaceTerraformVariableArgsDict',
    'WorkspaceTerraformVariableFileArgs',
    'WorkspaceTerraformVariableFileArgsDict',
    'GetConnectorRancherBearerTokenArgs',
    'GetConnectorRancherBearerTokenArgsDict',
    'GetDbSchemaChangelogScriptArgs',
    'GetDbSchemaChangelogScriptArgsDict',
    'GetDbSchemaSchemaSourceArgs',
    'GetDbSchemaSchemaSourceArgsDict',
    'GetEnvironmentClustersMappingClusterArgs',
    'GetEnvironmentClustersMappingClusterArgsDict',
    'GetEnvironmentGitDetailsArgs',
    'GetEnvironmentGitDetailsArgsDict',
    'GetGitopsAgentDeployYamlArgocdSettingsArgs',
    'GetGitopsAgentDeployYamlArgocdSettingsArgsDict',
    'GetGitopsAgentDeployYamlProxyArgs',
    'GetGitopsAgentDeployYamlProxyArgsDict',
    'GetGitopsAgentOperatorYamlProxyArgs',
    'GetGitopsAgentOperatorYamlProxyArgsDict',
    'GetGitopsGnupgRequestArgs',
    'GetGitopsGnupgRequestArgsDict',
    'GetGitopsGnupgRequestPublickeyArgs',
    'GetGitopsGnupgRequestPublickeyArgsDict',
    'GetGitopsRepoCredCredArgs',
    'GetGitopsRepoCredCredArgsDict',
    'GetHarRegistryConfigArgs',
    'GetHarRegistryConfigArgsDict',
    'GetHarRegistryConfigAuthArgs',
    'GetHarRegistryConfigAuthArgsDict',
    'GetHarRegistryConfigAuthUserPasswordArgs',
    'GetHarRegistryConfigAuthUserPasswordArgsDict',
    'GetInfraVariableSetConnectorArgs',
    'GetInfraVariableSetConnectorArgsDict',
    'GetInfraVariableSetEnvironmentVariableArgs',
    'GetInfraVariableSetEnvironmentVariableArgsDict',
    'GetInfraVariableSetTerraformVariableArgs',
    'GetInfraVariableSetTerraformVariableArgsDict',
    'GetInfraVariableSetTerraformVariableFileArgs',
    'GetInfraVariableSetTerraformVariableFileArgsDict',
    'GetInfrastructureGitDetailsArgs',
    'GetInfrastructureGitDetailsArgsDict',
    'GetInputSetGitDetailsArgs',
    'GetInputSetGitDetailsArgsDict',
    'GetOverridesGitDetailsArgs',
    'GetOverridesGitDetailsArgsDict',
    'GetPipelineGitDetailsArgs',
    'GetPipelineGitDetailsArgsDict',
    'GetPolicySetPolicyArgs',
    'GetPolicySetPolicyArgsDict',
    'GetRepoRuleBranchBypassArgs',
    'GetRepoRuleBranchBypassArgsDict',
    'GetRepoRuleBranchPatternArgs',
    'GetRepoRuleBranchPatternArgsDict',
    'GetRepoRuleBranchPolicyArgs',
    'GetRepoRuleBranchPolicyArgsDict',
    'GetRepoSourceArgs',
    'GetRepoSourceArgsDict',
    'GetSecretTextAdditionalMetadataArgs',
    'GetSecretTextAdditionalMetadataArgsDict',
    'GetSecretTextAdditionalMetadataValueArgs',
    'GetSecretTextAdditionalMetadataValueArgsDict',
    'GetServiceGitDetailsArgs',
    'GetServiceGitDetailsArgsDict',
    'GetServiceOverridesV2GitDetailsArgs',
    'GetServiceOverridesV2GitDetailsArgsDict',
    'GetTemplateGitDetailsArgs',
    'GetTemplateGitDetailsArgsDict',
    'GetUsergroupNotificationConfigArgs',
    'GetUsergroupNotificationConfigArgsDict',
    'GetWorkspaceEnvironmentVariableArgs',
    'GetWorkspaceEnvironmentVariableArgsDict',
    'GetWorkspaceTerraformVariableArgs',
    'GetWorkspaceTerraformVariableArgsDict',
    'GetWorkspaceTerraformVariableFileArgs',
    'GetWorkspaceTerraformVariableFileArgsDict',
]

MYPY = False

if not MYPY:
    class AppDynamicsConnectorApiTokenArgsDict(TypedDict):
        client_id: pulumi.Input[builtins.str]
        """
        The client id used for connecting to App Dynamics.
        """
        client_secret_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    AppDynamicsConnectorApiTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDynamicsConnectorApiTokenArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[builtins.str],
                 client_secret_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] client_id: The client id used for connecting to App Dynamics.
        :param pulumi.Input[builtins.str] client_secret_ref: Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        """
        The client id used for connecting to App Dynamics.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")

    @client_secret_ref.setter
    def client_secret_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_secret_ref", value)


if not MYPY:
    class AppDynamicsConnectorUsernamePasswordArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: pulumi.Input[builtins.str]
        """
        Username to use for authentication.
        """
elif False:
    AppDynamicsConnectorUsernamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDynamicsConnectorUsernamePasswordArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ArtifactoryConnectorCredentialsArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ArtifactoryConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ArtifactoryConnectorCredentialsArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class AwsCCConnectorCrossAccountAccessArgsDict(TypedDict):
        external_id: pulumi.Input[builtins.str]
        """
        The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        """
        role_arn: pulumi.Input[builtins.str]
        """
        The ARN of the role to use for cross-account access.
        """
elif False:
    AwsCCConnectorCrossAccountAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsCCConnectorCrossAccountAccessArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[builtins.str],
                 role_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] external_id: The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        :param pulumi.Input[builtins.str] role_arn: The ARN of the role to use for cross-account access.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[builtins.str]:
        """
        The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The ARN of the role to use for cross-account access.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class AwsConnectorCrossAccountAccessArgsDict(TypedDict):
        role_arn: pulumi.Input[builtins.str]
        """
        The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        """
        external_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
elif False:
    AwsConnectorCrossAccountAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorCrossAccountAccessArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[builtins.str],
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] role_arn: The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        :param pulumi.Input[builtins.str] external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class AwsConnectorEqualJitterBackoffStrategyArgsDict(TypedDict):
        base_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Base delay.
        """
        max_backoff_time: NotRequired[pulumi.Input[builtins.int]]
        """
        Max BackOff Time.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Retry Count.
        """
elif False:
    AwsConnectorEqualJitterBackoffStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorEqualJitterBackoffStrategyArgs:
    def __init__(__self__, *,
                 base_delay: Optional[pulumi.Input[builtins.int]] = None,
                 max_backoff_time: Optional[pulumi.Input[builtins.int]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] base_delay: Base delay.
        :param pulumi.Input[builtins.int] max_backoff_time: Max BackOff Time.
        :param pulumi.Input[builtins.int] retry_count: Retry Count.
        """
        if base_delay is not None:
            pulumi.set(__self__, "base_delay", base_delay)
        if max_backoff_time is not None:
            pulumi.set(__self__, "max_backoff_time", max_backoff_time)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="baseDelay")
    def base_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Base delay.
        """
        return pulumi.get(self, "base_delay")

    @base_delay.setter
    def base_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "base_delay", value)

    @property
    @pulumi.getter(name="maxBackoffTime")
    def max_backoff_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max BackOff Time.
        """
        return pulumi.get(self, "max_backoff_time")

    @max_backoff_time.setter
    def max_backoff_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_backoff_time", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)


if not MYPY:
    class AwsConnectorFixedDelayBackoffStrategyArgsDict(TypedDict):
        fixed_backoff: NotRequired[pulumi.Input[builtins.int]]
        """
        Fixed Backoff.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Retry Count.
        """
elif False:
    AwsConnectorFixedDelayBackoffStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorFixedDelayBackoffStrategyArgs:
    def __init__(__self__, *,
                 fixed_backoff: Optional[pulumi.Input[builtins.int]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] fixed_backoff: Fixed Backoff.
        :param pulumi.Input[builtins.int] retry_count: Retry Count.
        """
        if fixed_backoff is not None:
            pulumi.set(__self__, "fixed_backoff", fixed_backoff)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="fixedBackoff")
    def fixed_backoff(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fixed Backoff.
        """
        return pulumi.get(self, "fixed_backoff")

    @fixed_backoff.setter
    def fixed_backoff(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "fixed_backoff", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)


if not MYPY:
    class AwsConnectorFullJitterBackoffStrategyArgsDict(TypedDict):
        base_delay: NotRequired[pulumi.Input[builtins.int]]
        """
        Base delay.
        """
        max_backoff_time: NotRequired[pulumi.Input[builtins.int]]
        """
        Max BackOff Time.
        """
        retry_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Retry Count.
        """
elif False:
    AwsConnectorFullJitterBackoffStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorFullJitterBackoffStrategyArgs:
    def __init__(__self__, *,
                 base_delay: Optional[pulumi.Input[builtins.int]] = None,
                 max_backoff_time: Optional[pulumi.Input[builtins.int]] = None,
                 retry_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] base_delay: Base delay.
        :param pulumi.Input[builtins.int] max_backoff_time: Max BackOff Time.
        :param pulumi.Input[builtins.int] retry_count: Retry Count.
        """
        if base_delay is not None:
            pulumi.set(__self__, "base_delay", base_delay)
        if max_backoff_time is not None:
            pulumi.set(__self__, "max_backoff_time", max_backoff_time)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="baseDelay")
    def base_delay(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Base delay.
        """
        return pulumi.get(self, "base_delay")

    @base_delay.setter
    def base_delay(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "base_delay", value)

    @property
    @pulumi.getter(name="maxBackoffTime")
    def max_backoff_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Max BackOff Time.
        """
        return pulumi.get(self, "max_backoff_time")

    @max_backoff_time.setter
    def max_backoff_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_backoff_time", value)

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")

    @retry_count.setter
    def retry_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "retry_count", value)


if not MYPY:
    class AwsConnectorInheritFromDelegateArgsDict(TypedDict):
        delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The delegates to inherit the credentials from.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        Test Region to perform Connection test of AWS Connector.
        """
elif False:
    AwsConnectorInheritFromDelegateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorInheritFromDelegateArgs:
    def __init__(__self__, *,
                 delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to inherit the credentials from.
        :param pulumi.Input[builtins.str] region: Test Region to perform Connection test of AWS Connector.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "delegate_selectors", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Test Region to perform Connection test of AWS Connector.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class AwsConnectorIrsaArgsDict(TypedDict):
        delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The delegates to inherit the credentials from.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        Test Region to perform Connection test of AWS Connector.
        """
elif False:
    AwsConnectorIrsaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorIrsaArgs:
    def __init__(__self__, *,
                 delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to inherit the credentials from.
        :param pulumi.Input[builtins.str] region: Test Region to perform Connection test of AWS Connector.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "delegate_selectors", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Test Region to perform Connection test of AWS Connector.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class AwsConnectorManualArgsDict(TypedDict):
        secret_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        access_key: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS access key.
        """
        access_key_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Connect only use delegates with these tags.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        Test Region to perform Connection test of AWS Connector.
        """
        session_token_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the Harness secret containing the aws session token.
        """
elif False:
    AwsConnectorManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorManualArgs:
    def __init__(__self__, *,
                 secret_key_ref: pulumi.Input[builtins.str],
                 access_key: Optional[pulumi.Input[builtins.str]] = None,
                 access_key_ref: Optional[pulumi.Input[builtins.str]] = None,
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 session_token_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] secret_key_ref: Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] access_key: AWS access key.
        :param pulumi.Input[builtins.str] access_key_ref: Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: Connect only use delegates with these tags.
        :param pulumi.Input[builtins.str] region: Test Region to perform Connection test of AWS Connector.
        :param pulumi.Input[builtins.str] session_token_ref: Reference to the Harness secret containing the aws session token.
        """
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_key_ref is not None:
            pulumi.set(__self__, "access_key_ref", access_key_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if session_token_ref is not None:
            pulumi.set(__self__, "session_token_ref", session_token_ref)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key_ref", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS access key.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @access_key_ref.setter
    def access_key_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key_ref", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Connect only use delegates with these tags.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Test Region to perform Connection test of AWS Connector.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="sessionTokenRef")
    def session_token_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the Harness secret containing the aws session token.
        """
        return pulumi.get(self, "session_token_ref")

    @session_token_ref.setter
    def session_token_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "session_token_ref", value)


if not MYPY:
    class AwsConnectorOidcAuthenticationArgsDict(TypedDict):
        iam_role_arn: pulumi.Input[builtins.str]
        """
        The IAM Role to assume the credentials from.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The delegates to inherit the credentials from.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS Region to perform Connection test of Connector.
        """
elif False:
    AwsConnectorOidcAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsConnectorOidcAuthenticationArgs:
    def __init__(__self__, *,
                 iam_role_arn: pulumi.Input[builtins.str],
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] iam_role_arn: The IAM Role to assume the credentials from.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to inherit the credentials from.
        :param pulumi.Input[builtins.str] region: AWS Region to perform Connection test of Connector.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The IAM Role to assume the credentials from.
        """
        return pulumi.get(self, "iam_role_arn")

    @iam_role_arn.setter
    def iam_role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "iam_role_arn", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS Region to perform Connection test of Connector.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class AwsKmsConnectorCredentialsArgsDict(TypedDict):
        assume_role: NotRequired[pulumi.Input['AwsKmsConnectorCredentialsAssumeRoleArgsDict']]
        """
        Connect using STS assume role.
        """
        inherit_from_delegate: NotRequired[pulumi.Input[builtins.bool]]
        """
        Inherit the credentials from from the delegate.
        """
        manual: NotRequired[pulumi.Input['AwsKmsConnectorCredentialsManualArgsDict']]
        """
        Specify the AWS key and secret used for authenticating.
        """
        oidc_authentication: NotRequired[pulumi.Input['AwsKmsConnectorCredentialsOidcAuthenticationArgsDict']]
        """
        Connect using OIDC authentication.
        """
elif False:
    AwsKmsConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsKmsConnectorCredentialsArgs:
    def __init__(__self__, *,
                 assume_role: Optional[pulumi.Input['AwsKmsConnectorCredentialsAssumeRoleArgs']] = None,
                 inherit_from_delegate: Optional[pulumi.Input[builtins.bool]] = None,
                 manual: Optional[pulumi.Input['AwsKmsConnectorCredentialsManualArgs']] = None,
                 oidc_authentication: Optional[pulumi.Input['AwsKmsConnectorCredentialsOidcAuthenticationArgs']] = None):
        """
        :param pulumi.Input['AwsKmsConnectorCredentialsAssumeRoleArgs'] assume_role: Connect using STS assume role.
        :param pulumi.Input[builtins.bool] inherit_from_delegate: Inherit the credentials from from the delegate.
        :param pulumi.Input['AwsKmsConnectorCredentialsManualArgs'] manual: Specify the AWS key and secret used for authenticating.
        :param pulumi.Input['AwsKmsConnectorCredentialsOidcAuthenticationArgs'] oidc_authentication: Connect using OIDC authentication.
        """
        if assume_role is not None:
            pulumi.set(__self__, "assume_role", assume_role)
        if inherit_from_delegate is not None:
            pulumi.set(__self__, "inherit_from_delegate", inherit_from_delegate)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)
        if oidc_authentication is not None:
            pulumi.set(__self__, "oidc_authentication", oidc_authentication)

    @property
    @pulumi.getter(name="assumeRole")
    def assume_role(self) -> Optional[pulumi.Input['AwsKmsConnectorCredentialsAssumeRoleArgs']]:
        """
        Connect using STS assume role.
        """
        return pulumi.get(self, "assume_role")

    @assume_role.setter
    def assume_role(self, value: Optional[pulumi.Input['AwsKmsConnectorCredentialsAssumeRoleArgs']]):
        pulumi.set(self, "assume_role", value)

    @property
    @pulumi.getter(name="inheritFromDelegate")
    def inherit_from_delegate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Inherit the credentials from from the delegate.
        """
        return pulumi.get(self, "inherit_from_delegate")

    @inherit_from_delegate.setter
    def inherit_from_delegate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inherit_from_delegate", value)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['AwsKmsConnectorCredentialsManualArgs']]:
        """
        Specify the AWS key and secret used for authenticating.
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['AwsKmsConnectorCredentialsManualArgs']]):
        pulumi.set(self, "manual", value)

    @property
    @pulumi.getter(name="oidcAuthentication")
    def oidc_authentication(self) -> Optional[pulumi.Input['AwsKmsConnectorCredentialsOidcAuthenticationArgs']]:
        """
        Connect using OIDC authentication.
        """
        return pulumi.get(self, "oidc_authentication")

    @oidc_authentication.setter
    def oidc_authentication(self, value: Optional[pulumi.Input['AwsKmsConnectorCredentialsOidcAuthenticationArgs']]):
        pulumi.set(self, "oidc_authentication", value)


if not MYPY:
    class AwsKmsConnectorCredentialsAssumeRoleArgsDict(TypedDict):
        duration: pulumi.Input[builtins.int]
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        role_arn: pulumi.Input[builtins.str]
        """
        The ARN of the role to assume.
        """
        external_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
elif False:
    AwsKmsConnectorCredentialsAssumeRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsKmsConnectorCredentialsAssumeRoleArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[builtins.int],
                 role_arn: pulumi.Input[builtins.str],
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] duration: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        :param pulumi.Input[builtins.str] role_arn: The ARN of the role to assume.
        :param pulumi.Input[builtins.str] external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[builtins.int]:
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The ARN of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class AwsKmsConnectorCredentialsManualArgsDict(TypedDict):
        access_key_ref: pulumi.Input[builtins.str]
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        secret_key_ref: pulumi.Input[builtins.str]
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    AwsKmsConnectorCredentialsManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsKmsConnectorCredentialsManualArgs:
    def __init__(__self__, *,
                 access_key_ref: pulumi.Input[builtins.str],
                 secret_key_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] access_key_ref: The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] secret_key_ref: The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "access_key_ref", access_key_ref)
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @access_key_ref.setter
    def access_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "access_key_ref", value)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key_ref", value)


if not MYPY:
    class AwsKmsConnectorCredentialsOidcAuthenticationArgsDict(TypedDict):
        iam_role_arn: pulumi.Input[builtins.str]
        """
        The ARN of the IAM role to assume.
        """
elif False:
    AwsKmsConnectorCredentialsOidcAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsKmsConnectorCredentialsOidcAuthenticationArgs:
    def __init__(__self__, *,
                 iam_role_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] iam_role_arn: The ARN of the IAM role to assume.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The ARN of the IAM role to assume.
        """
        return pulumi.get(self, "iam_role_arn")

    @iam_role_arn.setter
    def iam_role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "iam_role_arn", value)


if not MYPY:
    class AwsSecretManagerConnectorCredentialsArgsDict(TypedDict):
        assume_role: NotRequired[pulumi.Input['AwsSecretManagerConnectorCredentialsAssumeRoleArgsDict']]
        """
        Connect using STS assume role.
        """
        inherit_from_delegate: NotRequired[pulumi.Input[builtins.bool]]
        """
        Inherit the credentials from from the delegate.
        """
        manual: NotRequired[pulumi.Input['AwsSecretManagerConnectorCredentialsManualArgsDict']]
        """
        Specify the AWS key and secret used for authenticating.
        """
        oidc_authentication: NotRequired[pulumi.Input['AwsSecretManagerConnectorCredentialsOidcAuthenticationArgsDict']]
        """
        Authentication using harness oidc.
        """
elif False:
    AwsSecretManagerConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsSecretManagerConnectorCredentialsArgs:
    def __init__(__self__, *,
                 assume_role: Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsAssumeRoleArgs']] = None,
                 inherit_from_delegate: Optional[pulumi.Input[builtins.bool]] = None,
                 manual: Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsManualArgs']] = None,
                 oidc_authentication: Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs']] = None):
        """
        :param pulumi.Input['AwsSecretManagerConnectorCredentialsAssumeRoleArgs'] assume_role: Connect using STS assume role.
        :param pulumi.Input[builtins.bool] inherit_from_delegate: Inherit the credentials from from the delegate.
        :param pulumi.Input['AwsSecretManagerConnectorCredentialsManualArgs'] manual: Specify the AWS key and secret used for authenticating.
        :param pulumi.Input['AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs'] oidc_authentication: Authentication using harness oidc.
        """
        if assume_role is not None:
            pulumi.set(__self__, "assume_role", assume_role)
        if inherit_from_delegate is not None:
            pulumi.set(__self__, "inherit_from_delegate", inherit_from_delegate)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)
        if oidc_authentication is not None:
            pulumi.set(__self__, "oidc_authentication", oidc_authentication)

    @property
    @pulumi.getter(name="assumeRole")
    def assume_role(self) -> Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsAssumeRoleArgs']]:
        """
        Connect using STS assume role.
        """
        return pulumi.get(self, "assume_role")

    @assume_role.setter
    def assume_role(self, value: Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsAssumeRoleArgs']]):
        pulumi.set(self, "assume_role", value)

    @property
    @pulumi.getter(name="inheritFromDelegate")
    def inherit_from_delegate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Inherit the credentials from from the delegate.
        """
        return pulumi.get(self, "inherit_from_delegate")

    @inherit_from_delegate.setter
    def inherit_from_delegate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inherit_from_delegate", value)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsManualArgs']]:
        """
        Specify the AWS key and secret used for authenticating.
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsManualArgs']]):
        pulumi.set(self, "manual", value)

    @property
    @pulumi.getter(name="oidcAuthentication")
    def oidc_authentication(self) -> Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs']]:
        """
        Authentication using harness oidc.
        """
        return pulumi.get(self, "oidc_authentication")

    @oidc_authentication.setter
    def oidc_authentication(self, value: Optional[pulumi.Input['AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs']]):
        pulumi.set(self, "oidc_authentication", value)


if not MYPY:
    class AwsSecretManagerConnectorCredentialsAssumeRoleArgsDict(TypedDict):
        duration: pulumi.Input[builtins.int]
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        role_arn: pulumi.Input[builtins.str]
        """
        The ARN of the role to assume.
        """
        external_id: NotRequired[pulumi.Input[builtins.str]]
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
elif False:
    AwsSecretManagerConnectorCredentialsAssumeRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsSecretManagerConnectorCredentialsAssumeRoleArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[builtins.int],
                 role_arn: pulumi.Input[builtins.str],
                 external_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] duration: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        :param pulumi.Input[builtins.str] role_arn: The ARN of the role to assume.
        :param pulumi.Input[builtins.str] external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[builtins.int]:
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The ARN of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class AwsSecretManagerConnectorCredentialsManualArgsDict(TypedDict):
        secret_key_ref: pulumi.Input[builtins.str]
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        access_key_plain_text: NotRequired[pulumi.Input[builtins.str]]
        """
        The plain text AWS access key. This is required if the access*key*ref is not provided.
        """
        access_key_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    AwsSecretManagerConnectorCredentialsManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsSecretManagerConnectorCredentialsManualArgs:
    def __init__(__self__, *,
                 secret_key_ref: pulumi.Input[builtins.str],
                 access_key_plain_text: Optional[pulumi.Input[builtins.str]] = None,
                 access_key_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] secret_key_ref: The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] access_key_plain_text: The plain text AWS access key. This is required if the access*key*ref is not provided.
        :param pulumi.Input[builtins.str] access_key_ref: The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if access_key_plain_text is not None:
            pulumi.set(__self__, "access_key_plain_text", access_key_plain_text)
        if access_key_ref is not None:
            pulumi.set(__self__, "access_key_ref", access_key_ref)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key_ref", value)

    @property
    @pulumi.getter(name="accessKeyPlainText")
    def access_key_plain_text(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The plain text AWS access key. This is required if the access*key*ref is not provided.
        """
        return pulumi.get(self, "access_key_plain_text")

    @access_key_plain_text.setter
    def access_key_plain_text(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key_plain_text", value)

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @access_key_ref.setter
    def access_key_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key_ref", value)


if not MYPY:
    class AwsSecretManagerConnectorCredentialsOidcAuthenticationArgsDict(TypedDict):
        iam_role_arn: pulumi.Input[builtins.str]
        """
        The IAM role ARN.
        """
elif False:
    AwsSecretManagerConnectorCredentialsOidcAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs:
    def __init__(__self__, *,
                 iam_role_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] iam_role_arn: The IAM role ARN.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> pulumi.Input[builtins.str]:
        """
        The IAM role ARN.
        """
        return pulumi.get(self, "iam_role_arn")

    @iam_role_arn.setter
    def iam_role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "iam_role_arn", value)


if not MYPY:
    class AzureCloudCostConnectorBillingExportSpecArgsDict(TypedDict):
        container_name: pulumi.Input[builtins.str]
        """
        Name of the container.
        """
        directory_name: pulumi.Input[builtins.str]
        """
        Name of the directory.
        """
        report_name: pulumi.Input[builtins.str]
        """
        Name of the report.
        """
        storage_account_name: pulumi.Input[builtins.str]
        """
        Name of the storage account.
        """
        subscription_id: pulumi.Input[builtins.str]
        """
        Subsription Id.
        """
elif False:
    AzureCloudCostConnectorBillingExportSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudCostConnectorBillingExportSpecArgs:
    def __init__(__self__, *,
                 container_name: pulumi.Input[builtins.str],
                 directory_name: pulumi.Input[builtins.str],
                 report_name: pulumi.Input[builtins.str],
                 storage_account_name: pulumi.Input[builtins.str],
                 subscription_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] container_name: Name of the container.
        :param pulumi.Input[builtins.str] directory_name: Name of the directory.
        :param pulumi.Input[builtins.str] report_name: Name of the report.
        :param pulumi.Input[builtins.str] storage_account_name: Name of the storage account.
        :param pulumi.Input[builtins.str] subscription_id: Subsription Id.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "report_name", report_name)
        pulumi.set(__self__, "storage_account_name", storage_account_name)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the container.
        """
        return pulumi.get(self, "container_name")

    @container_name.setter
    def container_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "container_name", value)

    @property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the directory.
        """
        return pulumi.get(self, "directory_name")

    @directory_name.setter
    def directory_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "directory_name", value)

    @property
    @pulumi.getter(name="reportName")
    def report_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the report.
        """
        return pulumi.get(self, "report_name")

    @report_name.setter
    def report_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "report_name", value)

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "storage_account_name")

    @storage_account_name.setter
    def storage_account_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "storage_account_name", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[builtins.str]:
        """
        Subsription Id.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subscription_id", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type can either be InheritFromDelegate or ManualConfig.
        """
        azure_inherit_from_delegate_details: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgsDict']]
        """
        Authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        azure_manual_details: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsArgsDict']]
        """
        Authenticate to Azure Cloud Provider using manual details.
        """
elif False:
    AzureCloudProviderConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 azure_inherit_from_delegate_details: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs']] = None,
                 azure_manual_details: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Type can either be InheritFromDelegate or ManualConfig.
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs'] azure_inherit_from_delegate_details: Authenticate to Azure Cloud Provider using details inheriting from delegate.
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs'] azure_manual_details: Authenticate to Azure Cloud Provider using manual details.
        """
        pulumi.set(__self__, "type", type)
        if azure_inherit_from_delegate_details is not None:
            pulumi.set(__self__, "azure_inherit_from_delegate_details", azure_inherit_from_delegate_details)
        if azure_manual_details is not None:
            pulumi.set(__self__, "azure_manual_details", azure_manual_details)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type can either be InheritFromDelegate or ManualConfig.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="azureInheritFromDelegateDetails")
    def azure_inherit_from_delegate_details(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs']]:
        """
        Authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        return pulumi.get(self, "azure_inherit_from_delegate_details")

    @azure_inherit_from_delegate_details.setter
    def azure_inherit_from_delegate_details(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs']]):
        pulumi.set(self, "azure_inherit_from_delegate_details", value)

    @property
    @pulumi.getter(name="azureManualDetails")
    def azure_manual_details(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs']]:
        """
        Authenticate to Azure Cloud Provider using manual details.
        """
        return pulumi.get(self, "azure_manual_details")

    @azure_manual_details.setter
    def azure_manual_details(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs']]):
        pulumi.set(self, "azure_manual_details", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgsDict(TypedDict):
        auth: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgsDict']]
        """
        Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs:
    def __init__(__self__, *,
                 auth: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs']] = None):
        """
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs'] auth: Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs']]:
        """
        Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs']]):
        pulumi.set(self, "auth", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        """
        azure_msi_auth_ua: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgsDict']]
        """
        Azure UserAssigned MSI auth details.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 azure_msi_auth_ua: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs'] azure_msi_auth_ua: Azure UserAssigned MSI auth details.
        """
        pulumi.set(__self__, "type", type)
        if azure_msi_auth_ua is not None:
            pulumi.set(__self__, "azure_msi_auth_ua", azure_msi_auth_ua)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="azureMsiAuthUa")
    def azure_msi_auth_ua(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs']]:
        """
        Azure UserAssigned MSI auth details.
        """
        return pulumi.get(self, "azure_msi_auth_ua")

    @azure_msi_auth_ua.setter
    def azure_msi_auth_ua(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs']]):
        pulumi.set(self, "azure_msi_auth_ua", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Id of the ManagedIdentity resource.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id: Client Id of the ManagedIdentity resource.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Id of the ManagedIdentity resource.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureManualDetailsArgsDict(TypedDict):
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Application ID of the Azure App.
        """
        auth: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgsDict']]
        """
        Contains Azure auth details.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure Active Directory (AAD) directory ID where you created your application.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureManualDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 auth: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs']] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] application_id: Application ID of the Azure App.
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs'] auth: Contains Azure auth details.
        :param pulumi.Input[builtins.str] tenant_id: The Azure Active Directory (AAD) directory ID where you created your application.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Application ID of the Azure App.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter
    def auth(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs']]:
        """
        Contains Azure auth details.
        """
        return pulumi.get(self, "auth")

    @auth.setter
    def auth(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs']]):
        pulumi.set(self, "auth", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure Active Directory (AAD) directory ID where you created your application.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgsDict(TypedDict):
        azure_client_key_cert: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgsDict']]
        """
        Azure client key certificate details.
        """
        azure_client_secret_key: NotRequired[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgsDict']]
        """
        Azure Client Secret Key details.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type can either be Certificate or Secret.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs:
    def __init__(__self__, *,
                 azure_client_key_cert: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs']] = None,
                 azure_client_secret_key: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs']] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs'] azure_client_key_cert: Azure client key certificate details.
        :param pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs'] azure_client_secret_key: Azure Client Secret Key details.
        :param pulumi.Input[builtins.str] type: Type can either be Certificate or Secret.
        """
        if azure_client_key_cert is not None:
            pulumi.set(__self__, "azure_client_key_cert", azure_client_key_cert)
        if azure_client_secret_key is not None:
            pulumi.set(__self__, "azure_client_secret_key", azure_client_secret_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="azureClientKeyCert")
    def azure_client_key_cert(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs']]:
        """
        Azure client key certificate details.
        """
        return pulumi.get(self, "azure_client_key_cert")

    @azure_client_key_cert.setter
    def azure_client_key_cert(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs']]):
        pulumi.set(self, "azure_client_key_cert", value)

    @property
    @pulumi.getter(name="azureClientSecretKey")
    def azure_client_secret_key(self) -> Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs']]:
        """
        Azure Client Secret Key details.
        """
        return pulumi.get(self, "azure_client_secret_key")

    @azure_client_secret_key.setter
    def azure_client_secret_key(self, value: Optional[pulumi.Input['AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs']]):
        pulumi.set(self, "azure_client_secret_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type can either be Certificate or Secret.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgsDict(TypedDict):
        certificate_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs:
    def __init__(__self__, *,
                 certificate_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] certificate_ref: Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if certificate_ref is not None:
            pulumi.set(__self__, "certificate_ref", certificate_ref)

    @property
    @pulumi.getter(name="certificateRef")
    def certificate_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "certificate_ref")

    @certificate_ref.setter
    def certificate_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "certificate_ref", value)


if not MYPY:
    class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgsDict(TypedDict):
        secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs:
    def __init__(__self__, *,
                 secret_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] secret_ref: Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class BitbucketConnectorApiAuthenticationArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The username used for connecting to the api.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    BitbucketConnectorApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BitbucketConnectorApiAuthenticationArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] token_ref: Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: The username used for connecting to the api.
        :param pulumi.Input[builtins.str] username_ref: The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The username used for connecting to the api.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class BitbucketConnectorCredentialsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input['BitbucketConnectorCredentialsHttpArgsDict']]
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        ssh: NotRequired[pulumi.Input['BitbucketConnectorCredentialsSshArgsDict']]
        """
        Authenticate using SSH for the connection.
        """
elif False:
    BitbucketConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BitbucketConnectorCredentialsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['BitbucketConnectorCredentialsHttpArgs']] = None,
                 ssh: Optional[pulumi.Input['BitbucketConnectorCredentialsSshArgs']] = None):
        """
        :param pulumi.Input['BitbucketConnectorCredentialsHttpArgs'] http: Authenticate using Username and password over http(s) for the connection.
        :param pulumi.Input['BitbucketConnectorCredentialsSshArgs'] ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['BitbucketConnectorCredentialsHttpArgs']]:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['BitbucketConnectorCredentialsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['BitbucketConnectorCredentialsSshArgs']]:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['BitbucketConnectorCredentialsSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class BitbucketConnectorCredentialsHttpArgsDict(TypedDict):
        password_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    BitbucketConnectorCredentialsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BitbucketConnectorCredentialsHttpArgs:
    def __init__(__self__, *,
                 password_ref: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if password_ref is not None:
            pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class BitbucketConnectorCredentialsSshArgsDict(TypedDict):
        ssh_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    BitbucketConnectorCredentialsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BitbucketConnectorCredentialsSshArgs:
    def __init__(__self__, *,
                 ssh_key_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")

    @ssh_key_ref.setter
    def ssh_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssh_key_ref", value)


if not MYPY:
    class ConnectorAzureArtifactsCredentialsArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorAzureArtifactsCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureArtifactsCredentialsArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] token_ref: Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)


if not MYPY:
    class ConnectorAzureRepoApiAuthenticationArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Personal access token for interacting with the azure api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorAzureRepoApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureRepoApiAuthenticationArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] token_ref: Personal access token for interacting with the azure api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Personal access token for interacting with the azure api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)


if not MYPY:
    class ConnectorAzureRepoCredentialsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input['ConnectorAzureRepoCredentialsHttpArgsDict']]
        """
        Authenticate using Username and token over http(s) for the connection.
        """
        ssh: NotRequired[pulumi.Input['ConnectorAzureRepoCredentialsSshArgsDict']]
        """
        Authenticate using SSH for the connection.
        """
elif False:
    ConnectorAzureRepoCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureRepoCredentialsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['ConnectorAzureRepoCredentialsHttpArgs']] = None,
                 ssh: Optional[pulumi.Input['ConnectorAzureRepoCredentialsSshArgs']] = None):
        """
        :param pulumi.Input['ConnectorAzureRepoCredentialsHttpArgs'] http: Authenticate using Username and token over http(s) for the connection.
        :param pulumi.Input['ConnectorAzureRepoCredentialsSshArgs'] ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['ConnectorAzureRepoCredentialsHttpArgs']]:
        """
        Authenticate using Username and token over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['ConnectorAzureRepoCredentialsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['ConnectorAzureRepoCredentialsSshArgs']]:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['ConnectorAzureRepoCredentialsSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class ConnectorAzureRepoCredentialsHttpArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorAzureRepoCredentialsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureRepoCredentialsHttpArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class ConnectorAzureRepoCredentialsSshArgsDict(TypedDict):
        ssh_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorAzureRepoCredentialsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorAzureRepoCredentialsSshArgs:
    def __init__(__self__, *,
                 ssh_key_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")

    @ssh_key_ref.setter
    def ssh_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssh_key_ref", value)


if not MYPY:
    class ConnectorCustomSecretManagerTemplateInputArgsDict(TypedDict):
        environment_variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgsDict']]]]
elif False:
    ConnectorCustomSecretManagerTemplateInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCustomSecretManagerTemplateInputArgs:
    def __init__(__self__, *,
                 environment_variables: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgs']]]] = None):
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgs']]]]:
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgs']]]]):
        pulumi.set(self, "environment_variables", value)


if not MYPY:
    class ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        : Name of the resource.
        """
        type: pulumi.Input[builtins.str]
        """
        : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        value: pulumi.Input[builtins.str]
        default: NotRequired[pulumi.Input[builtins.bool]]
elif False:
    ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCustomSecretManagerTemplateInputEnvironmentVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 default: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] name: : Name of the resource.
        :param pulumi.Input[builtins.str] type: : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        : Name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "default", value)


if not MYPY:
    class ConnectorCustomhealthsourceHeaderArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key.
        """
        encrypted_value_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value.
        """
        value_encrypted: NotRequired[pulumi.Input[builtins.bool]]
        """
        Encrypted value.
        """
elif False:
    ConnectorCustomhealthsourceHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCustomhealthsourceHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 encrypted_value_ref: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None,
                 value_encrypted: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] key: Key.
        :param pulumi.Input[builtins.str] encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] value: Value.
        :param pulumi.Input[builtins.bool] value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_value_ref is not None:
            pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_encrypted is not None:
            pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @encrypted_value_ref.setter
    def encrypted_value_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encrypted_value_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")

    @value_encrypted.setter
    def value_encrypted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "value_encrypted", value)


if not MYPY:
    class ConnectorCustomhealthsourceParamArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key.
        """
        encrypted_value_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value.
        """
        value_encrypted: NotRequired[pulumi.Input[builtins.bool]]
        """
        Encrypted value.
        """
elif False:
    ConnectorCustomhealthsourceParamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorCustomhealthsourceParamArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 encrypted_value_ref: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None,
                 value_encrypted: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] key: Key.
        :param pulumi.Input[builtins.str] encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] value: Value.
        :param pulumi.Input[builtins.bool] value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_value_ref is not None:
            pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_encrypted is not None:
            pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @encrypted_value_ref.setter
    def encrypted_value_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encrypted_value_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")

    @value_encrypted.setter
    def value_encrypted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "value_encrypted", value)


if not MYPY:
    class ConnectorGcpKmsManualArgsDict(TypedDict):
        credentials: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The delegates to connect with.
        """
elif False:
    ConnectorGcpKmsManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorGcpKmsManualArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[builtins.str],
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] credentials: Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to connect with.
        """
        pulumi.set(__self__, "credentials", credentials)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credentials", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The delegates to connect with.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)


if not MYPY:
    class ConnectorGcpKmsOidcAuthenticationArgsDict(TypedDict):
        gcp_project_id: pulumi.Input[builtins.str]
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        provider_id: pulumi.Input[builtins.str]
        """
        The OIDC provider ID value configured in GCP.
        """
        service_account_email: pulumi.Input[builtins.str]
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        workload_pool_id: pulumi.Input[builtins.str]
        """
        The workload pool ID value created in GCP.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The delegates to inherit the credentials from.
        """
elif False:
    ConnectorGcpKmsOidcAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorGcpKmsOidcAuthenticationArgs:
    def __init__(__self__, *,
                 gcp_project_id: pulumi.Input[builtins.str],
                 provider_id: pulumi.Input[builtins.str],
                 service_account_email: pulumi.Input[builtins.str],
                 workload_pool_id: pulumi.Input[builtins.str],
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] gcp_project_id: The project number of the GCP project that is used to create the workload identity.
        :param pulumi.Input[builtins.str] provider_id: The OIDC provider ID value configured in GCP.
        :param pulumi.Input[builtins.str] service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param pulumi.Input[builtins.str] workload_pool_id: The workload pool ID value created in GCP.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> pulumi.Input[builtins.str]:
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        return pulumi.get(self, "gcp_project_id")

    @gcp_project_id.setter
    def gcp_project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_project_id", value)

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> pulumi.Input[builtins.str]:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> pulumi.Input[builtins.str]:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> pulumi.Input[builtins.str]:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")

    @workload_pool_id.setter
    def workload_pool_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "workload_pool_id", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)


if not MYPY:
    class ConnectorJdbcCredentialsArgsDict(TypedDict):
        auth_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Authentication types for JDBC connector
        """
        password_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        service_account: NotRequired[pulumi.Input['ConnectorJdbcCredentialsServiceAccountArgsDict']]
        """
        Authenticate using service account.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The username to use for the database server.
        """
        username_password: NotRequired[pulumi.Input['ConnectorJdbcCredentialsUsernamePasswordArgsDict']]
        """
        Authenticate using username password.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorJdbcCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorJdbcCredentialsArgs:
    def __init__(__self__, *,
                 auth_type: Optional[pulumi.Input[builtins.str]] = None,
                 password_ref: Optional[pulumi.Input[builtins.str]] = None,
                 service_account: Optional[pulumi.Input['ConnectorJdbcCredentialsServiceAccountArgs']] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_password: Optional[pulumi.Input['ConnectorJdbcCredentialsUsernamePasswordArgs']] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: Authentication types for JDBC connector
        :param pulumi.Input[builtins.str] password_ref: The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input['ConnectorJdbcCredentialsServiceAccountArgs'] service_account: Authenticate using service account.
        :param pulumi.Input[builtins.str] username: The username to use for the database server.
        :param pulumi.Input['ConnectorJdbcCredentialsUsernamePasswordArgs'] username_password: Authenticate using username password.
        :param pulumi.Input[builtins.str] username_ref: The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if password_ref is not None:
            pulumi.set(__self__, "password_ref", password_ref)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Authentication types for JDBC connector
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input['ConnectorJdbcCredentialsServiceAccountArgs']]:
        """
        Authenticate using service account.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input['ConnectorJdbcCredentialsServiceAccountArgs']]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The username to use for the database server.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['ConnectorJdbcCredentialsUsernamePasswordArgs']]:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['ConnectorJdbcCredentialsUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class ConnectorJdbcCredentialsServiceAccountArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorJdbcCredentialsServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorJdbcCredentialsServiceAccountArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] token_ref: Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)


if not MYPY:
    class ConnectorJdbcCredentialsUsernamePasswordArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorJdbcCredentialsUsernamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorJdbcCredentialsUsernamePasswordArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class ConnectorPdcHostArgsDict(TypedDict):
        hostname: pulumi.Input[builtins.str]
        """
        Hostname e.g. 87.23.66.11:80
        """
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Host attributes with values. e.g. type, region, name, ip, etc.
        """
elif False:
    ConnectorPdcHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorPdcHostArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[builtins.str],
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] hostname: Hostname e.g. 87.23.66.11:80
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] attributes: Host attributes with values. e.g. type, region, name, ip, etc.
        """
        pulumi.set(__self__, "hostname", hostname)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[builtins.str]:
        """
        Hostname e.g. 87.23.66.11:80
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Host attributes with values. e.g. type, region, name, ip, etc.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attributes", value)


if not MYPY:
    class ConnectorRancherBearerTokenArgsDict(TypedDict):
        bearer_token_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ConnectorRancherBearerTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectorRancherBearerTokenArgs:
    def __init__(__self__, *,
                 bearer_token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] bearer_token_ref: Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "bearer_token_ref", bearer_token_ref)

    @property
    @pulumi.getter(name="bearerTokenRef")
    def bearer_token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "bearer_token_ref")

    @bearer_token_ref.setter
    def bearer_token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bearer_token_ref", value)


if not MYPY:
    class DbSchemaChangelogScriptArgsDict(TypedDict):
        command: NotRequired[pulumi.Input[builtins.str]]
        """
        Script to clone changeSets
        """
        image: NotRequired[pulumi.Input[builtins.str]]
        """
        The fully-qualified name (FQN) of the image
        """
        location: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to changeLog file
        """
        shell: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the shell. For example Sh or Bash
        """
elif False:
    DbSchemaChangelogScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSchemaChangelogScriptArgs:
    def __init__(__self__, *,
                 command: Optional[pulumi.Input[builtins.str]] = None,
                 image: Optional[pulumi.Input[builtins.str]] = None,
                 location: Optional[pulumi.Input[builtins.str]] = None,
                 shell: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] command: Script to clone changeSets
        :param pulumi.Input[builtins.str] image: The fully-qualified name (FQN) of the image
        :param pulumi.Input[builtins.str] location: Path to changeLog file
        :param pulumi.Input[builtins.str] shell: Type of the shell. For example Sh or Bash
        """
        if command is not None:
            pulumi.set(__self__, "command", command)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if shell is not None:
            pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Script to clone changeSets
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The fully-qualified name (FQN) of the image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to changeLog file
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def shell(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the shell. For example Sh or Bash
        """
        return pulumi.get(self, "shell")

    @shell.setter
    def shell(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "shell", value)


if not MYPY:
    class DbSchemaSchemaSourceArgsDict(TypedDict):
        connector: pulumi.Input[builtins.str]
        """
        Connector to repository at which to find details about the database schema
        """
        location: pulumi.Input[builtins.str]
        """
        The path within the specified repository at which to find details about the database schema
        """
        archive_path: NotRequired[pulumi.Input[builtins.str]]
        """
        If connector type is artifactory, path to the archive file which contains the changeLog
        """
        repo: NotRequired[pulumi.Input[builtins.str]]
        """
        If connector url is of account, which repository to connect to using the connector
        """
elif False:
    DbSchemaSchemaSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DbSchemaSchemaSourceArgs:
    def __init__(__self__, *,
                 connector: pulumi.Input[builtins.str],
                 location: pulumi.Input[builtins.str],
                 archive_path: Optional[pulumi.Input[builtins.str]] = None,
                 repo: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connector: Connector to repository at which to find details about the database schema
        :param pulumi.Input[builtins.str] location: The path within the specified repository at which to find details about the database schema
        :param pulumi.Input[builtins.str] archive_path: If connector type is artifactory, path to the archive file which contains the changeLog
        :param pulumi.Input[builtins.str] repo: If connector url is of account, which repository to connect to using the connector
        """
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "location", location)
        if archive_path is not None:
            pulumi.set(__self__, "archive_path", archive_path)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def connector(self) -> pulumi.Input[builtins.str]:
        """
        Connector to repository at which to find details about the database schema
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[builtins.str]:
        """
        The path within the specified repository at which to find details about the database schema
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="archivePath")
    def archive_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If connector type is artifactory, path to the archive file which contains the changeLog
        """
        return pulumi.get(self, "archive_path")

    @archive_path.setter
    def archive_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "archive_path", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If connector url is of account, which repository to connect to using the connector
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class DockerConnectorCredentialsArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The username to use for the docker registry.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    DockerConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DockerConnectorCredentialsArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        :param pulumi.Input[builtins.str] username: The username to use for the docker registry.
        :param pulumi.Input[builtins.str] username_ref: The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The username to use for the docker registry.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class ElasticsearchConnectorApiTokenArgsDict(TypedDict):
        client_id: pulumi.Input[builtins.str]
        """
        The client id used for connecting to ElasticSearch.
        """
        client_secret_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ElasticsearchConnectorApiTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElasticsearchConnectorApiTokenArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[builtins.str],
                 client_secret_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] client_id: The client id used for connecting to ElasticSearch.
        :param pulumi.Input[builtins.str] client_secret_ref: Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[builtins.str]:
        """
        The client id used for connecting to ElasticSearch.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")

    @client_secret_ref.setter
    def client_secret_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_secret_ref", value)


if not MYPY:
    class ElasticsearchConnectorNoAuthenticationArgsDict(TypedDict):
        pass
elif False:
    ElasticsearchConnectorNoAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElasticsearchConnectorNoAuthenticationArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ElasticsearchConnectorUsernamePasswordArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: pulumi.Input[builtins.str]
        """
        Username to use for authentication.
        """
elif False:
    ElasticsearchConnectorUsernamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElasticsearchConnectorUsernamePasswordArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class EnvironmentClustersMappingClusterArgsDict(TypedDict):
        agent_identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        agent identifier of the cluster (include scope prefix)
        """
        identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        identifier of the cluster
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        name of the cluster
        """
        scope: NotRequired[pulumi.Input[builtins.str]]
        """
        scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
elif False:
    EnvironmentClustersMappingClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentClustersMappingClusterArgs:
    def __init__(__self__, *,
                 agent_identifier: Optional[pulumi.Input[builtins.str]] = None,
                 identifier: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] agent_identifier: agent identifier of the cluster (include scope prefix)
        :param pulumi.Input[builtins.str] identifier: identifier of the cluster
        :param pulumi.Input[builtins.str] name: name of the cluster
        :param pulumi.Input[builtins.str] scope: scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        if agent_identifier is not None:
            pulumi.set(__self__, "agent_identifier", agent_identifier)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        agent identifier of the cluster (include scope prefix)
        """
        return pulumi.get(self, "agent_identifier")

    @agent_identifier.setter
    def agent_identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "agent_identifier", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        identifier of the cluster
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        name of the cluster
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class EnvironmentGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        message for the commit in Git Repo.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        import_from_git: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to set if importing from Git
        """
        is_force_import: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to set if force importing from Git
        """
        is_harnesscode_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the gitProvider is HarnessCode
        """
        is_new_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        If a new branch creation is requested.
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Environment.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating Environment.
        """
        load_from_cache: NotRequired[pulumi.Input[builtins.str]]
        """
        If the Entity is to be fetched from cache
        """
        load_from_fallback_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the file has to be get from fallback_branch.
        """
        parent_entity_connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        parent_entity_repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository where parent entity lies.
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        store type of the entity.
        """
elif False:
    EnvironmentGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 import_from_git: Optional[pulumi.Input[builtins.bool]] = None,
                 is_force_import: Optional[pulumi.Input[builtins.bool]] = None,
                 is_harnesscode_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 is_new_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_cache: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_fallback_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 parent_entity_connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 parent_entity_repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: message for the commit in Git Repo.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] import_from_git: Flag to set if importing from Git
        :param pulumi.Input[builtins.bool] is_force_import: Flag to set if force importing from Git
        :param pulumi.Input[builtins.bool] is_harnesscode_repo: If the gitProvider is HarnessCode
        :param pulumi.Input[builtins.bool] is_new_branch: If a new branch creation is requested.
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Environment.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating Environment.
        :param pulumi.Input[builtins.str] load_from_cache: If the Entity is to be fetched from cache
        :param pulumi.Input[builtins.bool] load_from_fallback_branch: Whether the file has to be get from fallback_branch.
        :param pulumi.Input[builtins.str] parent_entity_connector_ref: Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] parent_entity_repo_name: Name of the repository where parent entity lies.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: store type of the entity.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if import_from_git is not None:
            pulumi.set(__self__, "import_from_git", import_from_git)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if is_harnesscode_repo is not None:
            pulumi.set(__self__, "is_harnesscode_repo", is_harnesscode_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if parent_entity_connector_ref is not None:
            pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        if parent_entity_repo_name is not None:
            pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        message for the commit in Git Repo.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="importFromGit")
    def import_from_git(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to set if importing from Git
        """
        return pulumi.get(self, "import_from_git")

    @import_from_git.setter
    def import_from_git(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "import_from_git", value)

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to set if force importing from Git
        """
        return pulumi.get(self, "is_force_import")

    @is_force_import.setter
    def is_force_import(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_force_import", value)

    @property
    @pulumi.getter(name="isHarnesscodeRepo")
    def is_harnesscode_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the gitProvider is HarnessCode
        """
        return pulumi.get(self, "is_harnesscode_repo")

    @is_harnesscode_repo.setter
    def is_harnesscode_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harnesscode_repo", value)

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If a new branch creation is requested.
        """
        return pulumi.get(self, "is_new_branch")

    @is_new_branch.setter
    def is_new_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_new_branch", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Environment.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating Environment.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the Entity is to be fetched from cache
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the file has to be get from fallback_branch.
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @parent_entity_connector_ref.setter
    def parent_entity_connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parent_entity_connector_ref", value)

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository where parent entity lies.
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @parent_entity_repo_name.setter
    def parent_entity_repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parent_entity_repo_name", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        store type of the entity.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class FeatureFlagEnvironmentArgsDict(TypedDict):
        identifier: pulumi.Input[builtins.str]
        """
        Identifier of the Environment
        """
        add_target_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentAddTargetRuleArgsDict']]]]
        """
        The targeting rules for the flag
        """
        default_off_variation: NotRequired[pulumi.Input[builtins.str]]
        """
        Default variation to be served when flag is 'off'
        """
        default_on_variation: NotRequired[pulumi.Input[builtins.str]]
        """
        Default variation to be served when flag is 'on'
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the flag in this environment. Possible values are 'on' and 'off'
        """
elif False:
    FeatureFlagEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[builtins.str],
                 add_target_rules: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentAddTargetRuleArgs']]]] = None,
                 default_off_variation: Optional[pulumi.Input[builtins.str]] = None,
                 default_on_variation: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] identifier: Identifier of the Environment
        :param pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentAddTargetRuleArgs']]] add_target_rules: The targeting rules for the flag
        :param pulumi.Input[builtins.str] default_off_variation: Default variation to be served when flag is 'off'
        :param pulumi.Input[builtins.str] default_on_variation: Default variation to be served when flag is 'on'
        :param pulumi.Input[builtins.str] state: State of the flag in this environment. Possible values are 'on' and 'off'
        """
        pulumi.set(__self__, "identifier", identifier)
        if add_target_rules is not None:
            pulumi.set(__self__, "add_target_rules", add_target_rules)
        if default_off_variation is not None:
            pulumi.set(__self__, "default_off_variation", default_off_variation)
        if default_on_variation is not None:
            pulumi.set(__self__, "default_on_variation", default_on_variation)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[builtins.str]:
        """
        Identifier of the Environment
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="addTargetRules")
    def add_target_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentAddTargetRuleArgs']]]]:
        """
        The targeting rules for the flag
        """
        return pulumi.get(self, "add_target_rules")

    @add_target_rules.setter
    def add_target_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FeatureFlagEnvironmentAddTargetRuleArgs']]]]):
        pulumi.set(self, "add_target_rules", value)

    @property
    @pulumi.getter(name="defaultOffVariation")
    def default_off_variation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default variation to be served when flag is 'off'
        """
        return pulumi.get(self, "default_off_variation")

    @default_off_variation.setter
    def default_off_variation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_off_variation", value)

    @property
    @pulumi.getter(name="defaultOnVariation")
    def default_on_variation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Default variation to be served when flag is 'on'
        """
        return pulumi.get(self, "default_on_variation")

    @default_on_variation.setter
    def default_on_variation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "default_on_variation", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the flag in this environment. Possible values are 'on' and 'off'
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class FeatureFlagEnvironmentAddTargetRuleArgsDict(TypedDict):
        targets: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The targets of the rule
        """
        variation: NotRequired[pulumi.Input[builtins.str]]
        """
        The identifier of the variation. Valid values are `enabled`, `disabled`
        """
elif False:
    FeatureFlagEnvironmentAddTargetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagEnvironmentAddTargetRuleArgs:
    def __init__(__self__, *,
                 targets: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 variation: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] targets: The targets of the rule
        :param pulumi.Input[builtins.str] variation: The identifier of the variation. Valid values are `enabled`, `disabled`
        """
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @property
    @pulumi.getter
    def targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The targets of the rule
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def variation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The identifier of the variation. Valid values are `enabled`, `disabled`
        """
        return pulumi.get(self, "variation")

    @variation.setter
    def variation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "variation", value)


if not MYPY:
    class FeatureFlagTagArgsDict(TypedDict):
        identifier: pulumi.Input[builtins.str]
        """
        The identifier of the tag
        """
elif False:
    FeatureFlagTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagTagArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] identifier: The identifier of the tag
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[builtins.str]:
        """
        The identifier of the tag
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identifier", value)


if not MYPY:
    class FeatureFlagTargetGroupRuleArgsDict(TypedDict):
        attribute: pulumi.Input[builtins.str]
        """
        The attribute to use in the clause.  This can be any target attribute
        """
        op: pulumi.Input[builtins.str]
        """
        The type of operation such as equals, starts_with, contains
        """
        values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The values that are compared against the operator
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of this resource.
        """
        negate: NotRequired[pulumi.Input[builtins.bool]]
        """
        Is the operation negated?
        """
elif False:
    FeatureFlagTargetGroupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagTargetGroupRuleArgs:
    def __init__(__self__, *,
                 attribute: pulumi.Input[builtins.str],
                 op: pulumi.Input[builtins.str],
                 values: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 id: Optional[pulumi.Input[builtins.str]] = None,
                 negate: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] attribute: The attribute to use in the clause.  This can be any target attribute
        :param pulumi.Input[builtins.str] op: The type of operation such as equals, starts_with, contains
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] values: The values that are compared against the operator
        :param pulumi.Input[builtins.str] id: The ID of this resource.
        :param pulumi.Input[builtins.bool] negate: Is the operation negated?
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def attribute(self) -> pulumi.Input[builtins.str]:
        """
        The attribute to use in the clause.  This can be any target attribute
        """
        return pulumi.get(self, "attribute")

    @attribute.setter
    def attribute(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "attribute", value)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[builtins.str]:
        """
        The type of operation such as equals, starts_with, contains
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The values that are compared against the operator
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def negate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Is the operation negated?
        """
        return pulumi.get(self, "negate")

    @negate.setter
    def negate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "negate", value)


if not MYPY:
    class FeatureFlagVariationArgsDict(TypedDict):
        description: pulumi.Input[builtins.str]
        """
        The description of the variation
        """
        identifier: pulumi.Input[builtins.str]
        """
        The identifier of the variation
        """
        name: pulumi.Input[builtins.str]
        """
        The user friendly name of the variation
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the variation
        """
elif False:
    FeatureFlagVariationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FeatureFlagVariationArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[builtins.str],
                 identifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] description: The description of the variation
        :param pulumi.Input[builtins.str] identifier: The identifier of the variation
        :param pulumi.Input[builtins.str] name: The user friendly name of the variation
        :param pulumi.Input[builtins.str] value: The value of the variation
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[builtins.str]:
        """
        The description of the variation
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[builtins.str]:
        """
        The identifier of the variation
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The user friendly name of the variation
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the variation
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FileStoreFileCreatedByArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[builtins.str]]
        """
        User email
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        User name
        """
elif False:
    FileStoreFileCreatedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileStoreFileCreatedByArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] email: User email
        :param pulumi.Input[builtins.str] name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FileStoreFileLastModifiedByArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[builtins.str]]
        """
        User email
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        User name
        """
elif False:
    FileStoreFileLastModifiedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileStoreFileLastModifiedByArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] email: User email
        :param pulumi.Input[builtins.str] name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FileStoreFolderCreatedByArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[builtins.str]]
        """
        User email
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        User name
        """
elif False:
    FileStoreFolderCreatedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileStoreFolderCreatedByArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] email: User email
        :param pulumi.Input[builtins.str] name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FileStoreFolderLastModifiedByArgsDict(TypedDict):
        email: NotRequired[pulumi.Input[builtins.str]]
        """
        User email
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        User name
        """
elif False:
    FileStoreFolderLastModifiedByArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FileStoreFolderLastModifiedByArgs:
    def __init__(__self__, *,
                 email: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] email: User email
        :param pulumi.Input[builtins.str] name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class FiltersFilterPropertiesArgsDict(TypedDict):
        filter_type: pulumi.Input[builtins.str]
        """
        Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
elif False:
    FiltersFilterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FiltersFilterPropertiesArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[builtins.str],
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] filter_type: Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[builtins.str]:
        """
        Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class GcpCloudCostConnectorBillingExportSpecArgsDict(TypedDict):
        data_set_id: pulumi.Input[builtins.str]
        """
        Data Set Id.
        """
        table_id: pulumi.Input[builtins.str]
        """
        Table Id.
        """
elif False:
    GcpCloudCostConnectorBillingExportSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpCloudCostConnectorBillingExportSpecArgs:
    def __init__(__self__, *,
                 data_set_id: pulumi.Input[builtins.str],
                 table_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] data_set_id: Data Set Id.
        :param pulumi.Input[builtins.str] table_id: Table Id.
        """
        pulumi.set(__self__, "data_set_id", data_set_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="dataSetId")
    def data_set_id(self) -> pulumi.Input[builtins.str]:
        """
        Data Set Id.
        """
        return pulumi.get(self, "data_set_id")

    @data_set_id.setter
    def data_set_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "data_set_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[builtins.str]:
        """
        Table Id.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class GcpConnectorInheritFromDelegateArgsDict(TypedDict):
        delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The delegates to inherit the credentials from.
        """
elif False:
    GcpConnectorInheritFromDelegateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpConnectorInheritFromDelegateArgs:
    def __init__(__self__, *,
                 delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "delegate_selectors", value)


if not MYPY:
    class GcpConnectorManualArgsDict(TypedDict):
        secret_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The delegates to connect with.
        """
elif False:
    GcpConnectorManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpConnectorManualArgs:
    def __init__(__self__, *,
                 secret_key_ref: pulumi.Input[builtins.str],
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] secret_key_ref: Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to connect with.
        """
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @secret_key_ref.setter
    def secret_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "secret_key_ref", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The delegates to connect with.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)


if not MYPY:
    class GcpConnectorOidcAuthenticationArgsDict(TypedDict):
        gcp_project_id: pulumi.Input[builtins.str]
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        provider_id: pulumi.Input[builtins.str]
        """
        The OIDC provider ID value configured in GCP.
        """
        service_account_email: pulumi.Input[builtins.str]
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        workload_pool_id: pulumi.Input[builtins.str]
        """
        The workload pool ID value created in GCP.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The delegates to inherit the credentials from.
        """
elif False:
    GcpConnectorOidcAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpConnectorOidcAuthenticationArgs:
    def __init__(__self__, *,
                 gcp_project_id: pulumi.Input[builtins.str],
                 provider_id: pulumi.Input[builtins.str],
                 service_account_email: pulumi.Input[builtins.str],
                 workload_pool_id: pulumi.Input[builtins.str],
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] gcp_project_id: The project number of the GCP project that is used to create the workload identity.
        :param pulumi.Input[builtins.str] provider_id: The OIDC provider ID value configured in GCP.
        :param pulumi.Input[builtins.str] service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param pulumi.Input[builtins.str] workload_pool_id: The workload pool ID value created in GCP.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> pulumi.Input[builtins.str]:
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        return pulumi.get(self, "gcp_project_id")

    @gcp_project_id.setter
    def gcp_project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_project_id", value)

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> pulumi.Input[builtins.str]:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> pulumi.Input[builtins.str]:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> pulumi.Input[builtins.str]:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")

    @workload_pool_id.setter
    def workload_pool_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "workload_pool_id", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)


if not MYPY:
    class GcpSecretManagerConnectorOidcAuthenticationArgsDict(TypedDict):
        gcp_project_id: pulumi.Input[builtins.str]
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        provider_id: pulumi.Input[builtins.str]
        """
        The OIDC provider ID value configured in GCP.
        """
        service_account_email: pulumi.Input[builtins.str]
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        workload_pool_id: pulumi.Input[builtins.str]
        """
        The workload pool ID value created in GCP.
        """
elif False:
    GcpSecretManagerConnectorOidcAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpSecretManagerConnectorOidcAuthenticationArgs:
    def __init__(__self__, *,
                 gcp_project_id: pulumi.Input[builtins.str],
                 provider_id: pulumi.Input[builtins.str],
                 service_account_email: pulumi.Input[builtins.str],
                 workload_pool_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] gcp_project_id: The project number of the GCP project that is used to create the workload identity.
        :param pulumi.Input[builtins.str] provider_id: The OIDC provider ID value configured in GCP.
        :param pulumi.Input[builtins.str] service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param pulumi.Input[builtins.str] workload_pool_id: The workload pool ID value created in GCP.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> pulumi.Input[builtins.str]:
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        return pulumi.get(self, "gcp_project_id")

    @gcp_project_id.setter
    def gcp_project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_project_id", value)

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> pulumi.Input[builtins.str]:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @provider_id.setter
    def provider_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "provider_id", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> pulumi.Input[builtins.str]:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> pulumi.Input[builtins.str]:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")

    @workload_pool_id.setter
    def workload_pool_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "workload_pool_id", value)


if not MYPY:
    class GitConnectorCredentialsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input['GitConnectorCredentialsHttpArgsDict']]
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        ssh: NotRequired[pulumi.Input['GitConnectorCredentialsSshArgsDict']]
        """
        Authenticate using SSH for the connection.
        """
elif False:
    GitConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitConnectorCredentialsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['GitConnectorCredentialsHttpArgs']] = None,
                 ssh: Optional[pulumi.Input['GitConnectorCredentialsSshArgs']] = None):
        """
        :param pulumi.Input['GitConnectorCredentialsHttpArgs'] http: Authenticate using Username and password over http(s) for the connection.
        :param pulumi.Input['GitConnectorCredentialsSshArgs'] ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['GitConnectorCredentialsHttpArgs']]:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['GitConnectorCredentialsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['GitConnectorCredentialsSshArgs']]:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['GitConnectorCredentialsSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class GitConnectorCredentialsHttpArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GitConnectorCredentialsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitConnectorCredentialsHttpArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class GitConnectorCredentialsSshArgsDict(TypedDict):
        ssh_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GitConnectorCredentialsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitConnectorCredentialsSshArgs:
    def __init__(__self__, *,
                 ssh_key_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")

    @ssh_key_ref.setter
    def ssh_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssh_key_ref", value)


if not MYPY:
    class GitOpsAgentMetadataArgsDict(TypedDict):
        high_availability: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the agent is deployed in HA mode.
        """
        is_namespaced: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the agent is namespaced.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        The kubernetes namespace where the agent should be installed.
        """
elif False:
    GitOpsAgentMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsAgentMetadataArgs:
    def __init__(__self__, *,
                 high_availability: Optional[pulumi.Input[builtins.bool]] = None,
                 is_namespaced: Optional[pulumi.Input[builtins.bool]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] high_availability: Indicates if the agent is deployed in HA mode.
        :param pulumi.Input[builtins.bool] is_namespaced: Indicates if the agent is namespaced.
        :param pulumi.Input[builtins.str] namespace: The kubernetes namespace where the agent should be installed.
        """
        if high_availability is not None:
            pulumi.set(__self__, "high_availability", high_availability)
        if is_namespaced is not None:
            pulumi.set(__self__, "is_namespaced", is_namespaced)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="highAvailability")
    def high_availability(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the agent is deployed in HA mode.
        """
        return pulumi.get(self, "high_availability")

    @high_availability.setter
    def high_availability(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "high_availability", value)

    @property
    @pulumi.getter(name="isNamespaced")
    def is_namespaced(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the agent is namespaced.
        """
        return pulumi.get(self, "is_namespaced")

    @is_namespaced.setter
    def is_namespaced(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_namespaced", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The kubernetes namespace where the agent should be installed.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GitOpsApplicationsApplicationArgsDict(TypedDict):
        metadatas: pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataArgsDict']]]
        """
        Metadata corresponding to the resources. This includes all the objects a user must create.
        """
        specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecArgsDict']]]]
        """
        Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        """
elif False:
    GitOpsApplicationsApplicationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationArgs:
    def __init__(__self__, *,
                 metadatas: pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataArgs']]],
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataArgs']]] metadatas: Metadata corresponding to the resources. This includes all the objects a user must create.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecArgs']]] specs: Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)

    @property
    @pulumi.getter
    def metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataArgs']]]:
        """
        Metadata corresponding to the resources. This includes all the objects a user must create.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataArgs']]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecArgs']]]]:
        """
        Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecArgs']]]]):
        pulumi.set(self, "specs", value)


if not MYPY:
    class GitOpsApplicationsApplicationMetadataArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        """
        cluster_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        """
        finalizers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        """
        generate_name: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        """
        generation: NotRequired[pulumi.Input[builtins.str]]
        """
        A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        """
        owner_references: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataOwnerReferenceArgsDict']]]]
        """
        List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        """
        uid: NotRequired[pulumi.Input[builtins.str]]
        """
        UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
elif False:
    GitOpsApplicationsApplicationMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_name: Optional[pulumi.Input[builtins.str]] = None,
                 finalizers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 generate_name: Optional[pulumi.Input[builtins.str]] = None,
                 generation: Optional[pulumi.Input[builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 owner_references: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataOwnerReferenceArgs']]]] = None,
                 uid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        :param pulumi.Input[builtins.str] cluster_name: Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] finalizers: Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        :param pulumi.Input[builtins.str] generate_name: An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        :param pulumi.Input[builtins.str] generation: A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        :param pulumi.Input[builtins.str] name: Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        :param pulumi.Input[builtins.str] namespace: Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataOwnerReferenceArgs']]] owner_references: List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        :param pulumi.Input[builtins.str] uid: UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if finalizers is not None:
            pulumi.set(__self__, "finalizers", finalizers)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if owner_references is not None:
            pulumi.set(__self__, "owner_references", owner_references)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def finalizers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        """
        return pulumi.get(self, "finalizers")

    @finalizers.setter
    def finalizers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "finalizers", value)

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        """
        return pulumi.get(self, "generate_name")

    @generate_name.setter
    def generate_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "generate_name", value)

    @property
    @pulumi.getter
    def generation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        """
        return pulumi.get(self, "generation")

    @generation.setter
    def generation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "generation", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="ownerReferences")
    def owner_references(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataOwnerReferenceArgs']]]]:
        """
        List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        """
        return pulumi.get(self, "owner_references")

    @owner_references.setter
    def owner_references(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationMetadataOwnerReferenceArgs']]]]):
        pulumi.set(self, "owner_references", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class GitOpsApplicationsApplicationMetadataOwnerReferenceArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[builtins.str]]
        """
        API version of the referent.
        """
        block_owner_deletion: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        """
        controller: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the reference points to the managing controller.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of the referent.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the referent.
        """
        uid: NotRequired[pulumi.Input[builtins.str]]
        """
        UID of the referent.
        """
elif False:
    GitOpsApplicationsApplicationMetadataOwnerReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationMetadataOwnerReferenceArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[builtins.str]] = None,
                 block_owner_deletion: Optional[pulumi.Input[builtins.bool]] = None,
                 controller: Optional[pulumi.Input[builtins.bool]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 uid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_version: API version of the referent.
        :param pulumi.Input[builtins.bool] block_owner_deletion: If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        :param pulumi.Input[builtins.bool] controller: Indicates if the reference points to the managing controller.
        :param pulumi.Input[builtins.str] kind: Kind of the referent.
        :param pulumi.Input[builtins.str] name: Name of the referent.
        :param pulumi.Input[builtins.str] uid: UID of the referent.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if block_owner_deletion is not None:
            pulumi.set(__self__, "block_owner_deletion", block_owner_deletion)
        if controller is not None:
            pulumi.set(__self__, "controller", controller)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="blockOwnerDeletion")
    def block_owner_deletion(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        """
        return pulumi.get(self, "block_owner_deletion")

    @block_owner_deletion.setter
    def block_owner_deletion(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_owner_deletion", value)

    @property
    @pulumi.getter
    def controller(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the reference points to the managing controller.
        """
        return pulumi.get(self, "controller")

    @controller.setter
    def controller(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "controller", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of the referent.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the referent.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        UID of the referent.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecArgsDict(TypedDict):
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecDestinationArgsDict']]]]
        """
        Information about the GitOps application's destination.
        """
        project: NotRequired[pulumi.Input[builtins.str]]
        """
        The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        """
        source: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgsDict']]]]
        """
        Contains all information about the source of the GitOps application.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgsDict']]]]
        """
        List of sources for the GitOps application. Multi Source support
        """
        sync_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyArgsDict']]]]
        """
        Controls when a sync will be performed in response to updates in git.
        """
elif False:
    GitOpsApplicationsApplicationSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecDestinationArgs']]]] = None,
                 project: Optional[pulumi.Input[builtins.str]] = None,
                 source: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]]] = None,
                 sync_policies: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecDestinationArgs']]] destinations: Information about the GitOps application's destination.
        :param pulumi.Input[builtins.str] project: The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]] source: Contains all information about the source of the GitOps application.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]] sources: List of sources for the GitOps application. Multi Source support
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyArgs']]] sync_policies: Controls when a sync will be performed in response to updates in git.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if sync_policies is not None:
            pulumi.set(__self__, "sync_policies", sync_policies)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecDestinationArgs']]]]:
        """
        Information about the GitOps application's destination.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]]]:
        """
        Contains all information about the source of the GitOps application.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]]]:
        """
        List of sources for the GitOps application. Multi Source support
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceArgs']]]]):
        pulumi.set(self, "sources", value)

    @property
    @pulumi.getter(name="syncPolicies")
    def sync_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyArgs']]]]:
        """
        Controls when a sync will be performed in response to updates in git.
        """
        return pulumi.get(self, "sync_policies")

    @sync_policies.setter
    def sync_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyArgs']]]]):
        pulumi.set(self, "sync_policies", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecDestinationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        URL of the target cluster and must be set to the kubernetes control plane API.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        """
        server: NotRequired[pulumi.Input[builtins.str]]
        """
        URL of the target cluster server for the GitOps application.
        """
elif False:
    GitOpsApplicationsApplicationSpecDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 server: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: URL of the target cluster and must be set to the kubernetes control plane API.
        :param pulumi.Input[builtins.str] namespace: Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        :param pulumi.Input[builtins.str] server: URL of the target cluster server for the GitOps application.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of the target cluster and must be set to the kubernetes control plane API.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of the target cluster server for the GitOps application.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceArgsDict(TypedDict):
        repo_url: pulumi.Input[builtins.str]
        """
        URL to the repository (git or helm) that contains the GitOps application manifests.
        """
        target_revision: pulumi.Input[builtins.str]
        """
        Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        """
        chart: NotRequired[pulumi.Input[builtins.str]]
        """
        Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        """
        directories: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryArgsDict']]]]
        """
        Options for applications of type plain YAML or Jsonnet.
        """
        helms: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmArgsDict']]]]
        """
        Holds helm specific options.
        """
        ksonnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetArgsDict']]]]
        """
        Ksonnet specific options.
        """
        kustomizes: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKustomizeArgsDict']]]]
        """
        Options specific to a GitOps application source specific to Kustomize.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        """
        plugins: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginArgsDict']]]]
        """
        Options specific to config management plugins.
        """
        ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference name to be used in other source spec, used for multi-source applications.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceArgs:
    def __init__(__self__, *,
                 repo_url: pulumi.Input[builtins.str],
                 target_revision: pulumi.Input[builtins.str],
                 chart: Optional[pulumi.Input[builtins.str]] = None,
                 directories: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryArgs']]]] = None,
                 helms: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmArgs']]]] = None,
                 ksonnets: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetArgs']]]] = None,
                 kustomizes: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKustomizeArgs']]]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None,
                 plugins: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginArgs']]]] = None,
                 ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] repo_url: URL to the repository (git or helm) that contains the GitOps application manifests.
        :param pulumi.Input[builtins.str] target_revision: Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        :param pulumi.Input[builtins.str] chart: Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryArgs']]] directories: Options for applications of type plain YAML or Jsonnet.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmArgs']]] helms: Holds helm specific options.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetArgs']]] ksonnets: Ksonnet specific options.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKustomizeArgs']]] kustomizes: Options specific to a GitOps application source specific to Kustomize.
        :param pulumi.Input[builtins.str] path: Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginArgs']]] plugins: Options specific to config management plugins.
        :param pulumi.Input[builtins.str] ref: Reference name to be used in other source spec, used for multi-source applications.
        """
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "target_revision", target_revision)
        if chart is not None:
            pulumi.set(__self__, "chart", chart)
        if directories is not None:
            pulumi.set(__self__, "directories", directories)
        if helms is not None:
            pulumi.set(__self__, "helms", helms)
        if ksonnets is not None:
            pulumi.set(__self__, "ksonnets", ksonnets)
        if kustomizes is not None:
            pulumi.set(__self__, "kustomizes", kustomizes)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> pulumi.Input[builtins.str]:
        """
        URL to the repository (git or helm) that contains the GitOps application manifests.
        """
        return pulumi.get(self, "repo_url")

    @repo_url.setter
    def repo_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repo_url", value)

    @property
    @pulumi.getter(name="targetRevision")
    def target_revision(self) -> pulumi.Input[builtins.str]:
        """
        Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        """
        return pulumi.get(self, "target_revision")

    @target_revision.setter
    def target_revision(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "target_revision", value)

    @property
    @pulumi.getter
    def chart(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        """
        return pulumi.get(self, "chart")

    @chart.setter
    def chart(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "chart", value)

    @property
    @pulumi.getter
    def directories(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryArgs']]]]:
        """
        Options for applications of type plain YAML or Jsonnet.
        """
        return pulumi.get(self, "directories")

    @directories.setter
    def directories(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryArgs']]]]):
        pulumi.set(self, "directories", value)

    @property
    @pulumi.getter
    def helms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmArgs']]]]:
        """
        Holds helm specific options.
        """
        return pulumi.get(self, "helms")

    @helms.setter
    def helms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmArgs']]]]):
        pulumi.set(self, "helms", value)

    @property
    @pulumi.getter
    def ksonnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetArgs']]]]:
        """
        Ksonnet specific options.
        """
        return pulumi.get(self, "ksonnets")

    @ksonnets.setter
    def ksonnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetArgs']]]]):
        pulumi.set(self, "ksonnets", value)

    @property
    @pulumi.getter
    def kustomizes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKustomizeArgs']]]]:
        """
        Options specific to a GitOps application source specific to Kustomize.
        """
        return pulumi.get(self, "kustomizes")

    @kustomizes.setter
    def kustomizes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKustomizeArgs']]]]):
        pulumi.set(self, "kustomizes", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def plugins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginArgs']]]]:
        """
        Options specific to config management plugins.
        """
        return pulumi.get(self, "plugins")

    @plugins.setter
    def plugins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginArgs']]]]):
        pulumi.set(self, "plugins", value)

    @property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference name to be used in other source spec, used for multi-source applications.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ref", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceDirectoryArgsDict(TypedDict):
        exclude: NotRequired[pulumi.Input[builtins.str]]
        """
        Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        """
        include: NotRequired[pulumi.Input[builtins.str]]
        """
        Glob pattern to match paths against that should be explicitly included during manifest generation.
        """
        jsonnets: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgsDict']]]]
        """
        Options specific to applications of type Jsonnet.
        """
        recurse: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates to scan a directory recursively for manifests.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceDirectoryArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input[builtins.str]] = None,
                 include: Optional[pulumi.Input[builtins.str]] = None,
                 jsonnets: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs']]]] = None,
                 recurse: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] exclude: Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        :param pulumi.Input[builtins.str] include: Glob pattern to match paths against that should be explicitly included during manifest generation.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs']]] jsonnets: Options specific to applications of type Jsonnet.
        :param pulumi.Input[builtins.bool] recurse: Indicates to scan a directory recursively for manifests.
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if jsonnets is not None:
            pulumi.set(__self__, "jsonnets", jsonnets)
        if recurse is not None:
            pulumi.set(__self__, "recurse", recurse)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        """
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Glob pattern to match paths against that should be explicitly included during manifest generation.
        """
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter
    def jsonnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs']]]]:
        """
        Options specific to applications of type Jsonnet.
        """
        return pulumi.get(self, "jsonnets")

    @jsonnets.setter
    def jsonnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs']]]]):
        pulumi.set(self, "jsonnets", value)

    @property
    @pulumi.getter
    def recurse(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates to scan a directory recursively for manifests.
        """
        return pulumi.get(self, "recurse")

    @recurse.setter
    def recurse(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "recurse", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgsDict(TypedDict):
        ext_vars: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgsDict']]]]
        """
        List of jsonnet external variables.
        """
        libs: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Additional library search dirs.
        """
        tlas: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgsDict']]]]
        """
        List of jsonnet top-level arguments(TLAS).
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs:
    def __init__(__self__, *,
                 ext_vars: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs']]]] = None,
                 libs: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 tlas: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs']]] ext_vars: List of jsonnet external variables.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] libs: Additional library search dirs.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs']]] tlas: List of jsonnet top-level arguments(TLAS).
        """
        if ext_vars is not None:
            pulumi.set(__self__, "ext_vars", ext_vars)
        if libs is not None:
            pulumi.set(__self__, "libs", libs)
        if tlas is not None:
            pulumi.set(__self__, "tlas", tlas)

    @property
    @pulumi.getter(name="extVars")
    def ext_vars(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs']]]]:
        """
        List of jsonnet external variables.
        """
        return pulumi.get(self, "ext_vars")

    @ext_vars.setter
    def ext_vars(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs']]]]):
        pulumi.set(self, "ext_vars", value)

    @property
    @pulumi.getter
    def libs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Additional library search dirs.
        """
        return pulumi.get(self, "libs")

    @libs.setter
    def libs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "libs", value)

    @property
    @pulumi.getter
    def tlas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs']]]]:
        """
        List of jsonnet top-level arguments(TLAS).
        """
        return pulumi.get(self, "tlas")

    @tlas.setter
    def tlas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs']]]]):
        pulumi.set(self, "tlas", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.bool]]
        """
        Code of the external variables of jsonnet application.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the external variables of jsonnet application.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the external variables of jsonnet application.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] code: Code of the external variables of jsonnet application.
        :param pulumi.Input[builtins.str] name: Name of the external variables of jsonnet application.
        :param pulumi.Input[builtins.str] value: Value of the external variables of jsonnet application.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Code of the external variables of jsonnet application.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the external variables of jsonnet application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the external variables of jsonnet application.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.bool]]
        """
        Code of the TLAS of the jsonnet application.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the TLAS of the jsonnet application.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the TLAS of the jsonnet application.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] code: Code of the TLAS of the jsonnet application.
        :param pulumi.Input[builtins.str] name: Name of the TLAS of the jsonnet application.
        :param pulumi.Input[builtins.str] value: Value of the TLAS of the jsonnet application.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Code of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceHelmArgsDict(TypedDict):
        file_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgsDict']]]]
        """
        File parameters to the helm template.
        """
        ignore_missing_value_files: NotRequired[pulumi.Input[builtins.bool]]
        """
        Prevents 'helm template' from failing when value_files do not exist locally.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmParameterArgsDict']]]]
        """
        List of helm parameters which are passed to the helm template command upon manifest generation.
        """
        pass_credentials: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if to pass credentials to all domains (helm's --pass-credentials)
        """
        release_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Helm release name to use. If omitted it will use the GitOps application name.
        """
        skip_crds: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if to skip CRDs during helm template. Corresponds to helm --skip-crds
        """
        skip_schema_validation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
        """
        skip_tests: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
        """
        value_files: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of helm value files to use when generating a template.
        """
        values: NotRequired[pulumi.Input[builtins.str]]
        """
        Helm values to be passed to helm template, typically defined as a block.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Helm version to use for templating (either "2" or "3")
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceHelmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceHelmArgs:
    def __init__(__self__, *,
                 file_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs']]]] = None,
                 ignore_missing_value_files: Optional[pulumi.Input[builtins.bool]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmParameterArgs']]]] = None,
                 pass_credentials: Optional[pulumi.Input[builtins.bool]] = None,
                 release_name: Optional[pulumi.Input[builtins.str]] = None,
                 skip_crds: Optional[pulumi.Input[builtins.bool]] = None,
                 skip_schema_validation: Optional[pulumi.Input[builtins.bool]] = None,
                 skip_tests: Optional[pulumi.Input[builtins.bool]] = None,
                 value_files: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 values: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs']]] file_parameters: File parameters to the helm template.
        :param pulumi.Input[builtins.bool] ignore_missing_value_files: Prevents 'helm template' from failing when value_files do not exist locally.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmParameterArgs']]] parameters: List of helm parameters which are passed to the helm template command upon manifest generation.
        :param pulumi.Input[builtins.bool] pass_credentials: Indicates if to pass credentials to all domains (helm's --pass-credentials)
        :param pulumi.Input[builtins.str] release_name: Helm release name to use. If omitted it will use the GitOps application name.
        :param pulumi.Input[builtins.bool] skip_crds: Indicates if to skip CRDs during helm template. Corresponds to helm --skip-crds
        :param pulumi.Input[builtins.bool] skip_schema_validation: Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
        :param pulumi.Input[builtins.bool] skip_tests: Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] value_files: List of helm value files to use when generating a template.
        :param pulumi.Input[builtins.str] values: Helm values to be passed to helm template, typically defined as a block.
        :param pulumi.Input[builtins.str] version: Helm version to use for templating (either "2" or "3")
        """
        if file_parameters is not None:
            pulumi.set(__self__, "file_parameters", file_parameters)
        if ignore_missing_value_files is not None:
            pulumi.set(__self__, "ignore_missing_value_files", ignore_missing_value_files)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pass_credentials is not None:
            pulumi.set(__self__, "pass_credentials", pass_credentials)
        if release_name is not None:
            pulumi.set(__self__, "release_name", release_name)
        if skip_crds is not None:
            pulumi.set(__self__, "skip_crds", skip_crds)
        if skip_schema_validation is not None:
            pulumi.set(__self__, "skip_schema_validation", skip_schema_validation)
        if skip_tests is not None:
            pulumi.set(__self__, "skip_tests", skip_tests)
        if value_files is not None:
            pulumi.set(__self__, "value_files", value_files)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="fileParameters")
    def file_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs']]]]:
        """
        File parameters to the helm template.
        """
        return pulumi.get(self, "file_parameters")

    @file_parameters.setter
    def file_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs']]]]):
        pulumi.set(self, "file_parameters", value)

    @property
    @pulumi.getter(name="ignoreMissingValueFiles")
    def ignore_missing_value_files(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Prevents 'helm template' from failing when value_files do not exist locally.
        """
        return pulumi.get(self, "ignore_missing_value_files")

    @ignore_missing_value_files.setter
    def ignore_missing_value_files(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "ignore_missing_value_files", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmParameterArgs']]]]:
        """
        List of helm parameters which are passed to the helm template command upon manifest generation.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceHelmParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="passCredentials")
    def pass_credentials(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if to pass credentials to all domains (helm's --pass-credentials)
        """
        return pulumi.get(self, "pass_credentials")

    @pass_credentials.setter
    def pass_credentials(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "pass_credentials", value)

    @property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Helm release name to use. If omitted it will use the GitOps application name.
        """
        return pulumi.get(self, "release_name")

    @release_name.setter
    def release_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "release_name", value)

    @property
    @pulumi.getter(name="skipCrds")
    def skip_crds(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if to skip CRDs during helm template. Corresponds to helm --skip-crds
        """
        return pulumi.get(self, "skip_crds")

    @skip_crds.setter
    def skip_crds(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "skip_crds", value)

    @property
    @pulumi.getter(name="skipSchemaValidation")
    def skip_schema_validation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if to skip schema validation during helm template. Corresponds to helm --skip-schema-validation
        """
        return pulumi.get(self, "skip_schema_validation")

    @skip_schema_validation.setter
    def skip_schema_validation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "skip_schema_validation", value)

    @property
    @pulumi.getter(name="skipTests")
    def skip_tests(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if to skip tests during helm template. Corresponds to helm --skip-tests
        """
        return pulumi.get(self, "skip_tests")

    @skip_tests.setter
    def skip_tests(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "skip_tests", value)

    @property
    @pulumi.getter(name="valueFiles")
    def value_files(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of helm value files to use when generating a template.
        """
        return pulumi.get(self, "value_files")

    @value_files.setter
    def value_files(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "value_files", value)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Helm values to be passed to helm template, typically defined as a block.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Helm version to use for templating (either "2" or "3")
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the helm parameter.
        """
        path: NotRequired[pulumi.Input[builtins.str]]
        """
        Path to the file containing the values of the helm parameter.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the helm parameter.
        :param pulumi.Input[builtins.str] path: Path to the file containing the values of the helm parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the helm parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Path to the file containing the values of the helm parameter.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceHelmParameterArgsDict(TypedDict):
        force_string: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if helm should interpret booleans and numbers as strings.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the helm parameter.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the Helm parameter.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceHelmParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceHelmParameterArgs:
    def __init__(__self__, *,
                 force_string: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] force_string: Indicates if helm should interpret booleans and numbers as strings.
        :param pulumi.Input[builtins.str] name: Name of the helm parameter.
        :param pulumi.Input[builtins.str] value: Value of the Helm parameter.
        """
        if force_string is not None:
            pulumi.set(__self__, "force_string", force_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="forceString")
    def force_string(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if helm should interpret booleans and numbers as strings.
        """
        return pulumi.get(self, "force_string")

    @force_string.setter
    def force_string(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_string", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the helm parameter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the Helm parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceKsonnetArgsDict(TypedDict):
        environment: NotRequired[pulumi.Input[builtins.str]]
        """
        Ksonnet application environment name.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgsDict']]]]
        """
        List of ksonnet component parameter override values.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceKsonnetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceKsonnetArgs:
    def __init__(__self__, *,
                 environment: Optional[pulumi.Input[builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] environment: Ksonnet application environment name.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs']]] parameters: List of ksonnet component parameter override values.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Ksonnet application environment name.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs']]]]:
        """
        List of ksonnet component parameter override values.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgsDict(TypedDict):
        component: NotRequired[pulumi.Input[builtins.str]]
        """
        Component of the parameter of the ksonnet application.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the parameter of the ksonnet application.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the parameter of the ksonnet application.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] component: Component of the parameter of the ksonnet application.
        :param pulumi.Input[builtins.str] name: Name of the parameter of the ksonnet application.
        :param pulumi.Input[builtins.str] value: Value of the parameter of the ksonnet application.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Component of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourceKustomizeArgsDict(TypedDict):
        common_annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        List of additional annotations to add to rendered manifests.
        """
        common_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        List of additional labels to add to rendered manifests.
        """
        force_common_annotations: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if to force applying common annotations to resources for kustomize apps.
        """
        force_common_labels: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if to force apply common labels to resources for kustomize apps.
        """
        images: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of kustomize image override specifications.
        """
        name_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        Prefix prepended to resources for kustomize apps.
        """
        name_suffix: NotRequired[pulumi.Input[builtins.str]]
        """
        Suffix appended to resources for kustomize apps.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of kustomize to use for rendering manifests.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourceKustomizeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourceKustomizeArgs:
    def __init__(__self__, *,
                 common_annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 common_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 force_common_annotations: Optional[pulumi.Input[builtins.bool]] = None,
                 force_common_labels: Optional[pulumi.Input[builtins.bool]] = None,
                 images: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 name_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 name_suffix: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] common_annotations: List of additional annotations to add to rendered manifests.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] common_labels: List of additional labels to add to rendered manifests.
        :param pulumi.Input[builtins.bool] force_common_annotations: Indicates if to force applying common annotations to resources for kustomize apps.
        :param pulumi.Input[builtins.bool] force_common_labels: Indicates if to force apply common labels to resources for kustomize apps.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] images: List of kustomize image override specifications.
        :param pulumi.Input[builtins.str] name_prefix: Prefix prepended to resources for kustomize apps.
        :param pulumi.Input[builtins.str] name_suffix: Suffix appended to resources for kustomize apps.
        :param pulumi.Input[builtins.str] version: Version of kustomize to use for rendering manifests.
        """
        if common_annotations is not None:
            pulumi.set(__self__, "common_annotations", common_annotations)
        if common_labels is not None:
            pulumi.set(__self__, "common_labels", common_labels)
        if force_common_annotations is not None:
            pulumi.set(__self__, "force_common_annotations", force_common_annotations)
        if force_common_labels is not None:
            pulumi.set(__self__, "force_common_labels", force_common_labels)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if name_prefix is not None:
            pulumi.set(__self__, "name_prefix", name_prefix)
        if name_suffix is not None:
            pulumi.set(__self__, "name_suffix", name_suffix)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="commonAnnotations")
    def common_annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        List of additional annotations to add to rendered manifests.
        """
        return pulumi.get(self, "common_annotations")

    @common_annotations.setter
    def common_annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "common_annotations", value)

    @property
    @pulumi.getter(name="commonLabels")
    def common_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        List of additional labels to add to rendered manifests.
        """
        return pulumi.get(self, "common_labels")

    @common_labels.setter
    def common_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "common_labels", value)

    @property
    @pulumi.getter(name="forceCommonAnnotations")
    def force_common_annotations(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if to force applying common annotations to resources for kustomize apps.
        """
        return pulumi.get(self, "force_common_annotations")

    @force_common_annotations.setter
    def force_common_annotations(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_common_annotations", value)

    @property
    @pulumi.getter(name="forceCommonLabels")
    def force_common_labels(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if to force apply common labels to resources for kustomize apps.
        """
        return pulumi.get(self, "force_common_labels")

    @force_common_labels.setter
    def force_common_labels(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "force_common_labels", value)

    @property
    @pulumi.getter
    def images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of kustomize image override specifications.
        """
        return pulumi.get(self, "images")

    @images.setter
    def images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "images", value)

    @property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Prefix prepended to resources for kustomize apps.
        """
        return pulumi.get(self, "name_prefix")

    @name_prefix.setter
    def name_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_prefix", value)

    @property
    @pulumi.getter(name="nameSuffix")
    def name_suffix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Suffix appended to resources for kustomize apps.
        """
        return pulumi.get(self, "name_suffix")

    @name_suffix.setter
    def name_suffix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name_suffix", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of kustomize to use for rendering manifests.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourcePluginArgsDict(TypedDict):
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginEnvArgsDict']]]]
        """
        Entry in the GitOps application's environment.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the plugin.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourcePluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourcePluginArgs:
    def __init__(__self__, *,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginEnvArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginEnvArgs']]] envs: Entry in the GitOps application's environment.
        :param pulumi.Input[builtins.str] name: Name of the plugin.
        """
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginEnvArgs']]]]:
        """
        Entry in the GitOps application's environment.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSourcePluginEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the plugin.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSourcePluginEnvArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the variable, usually expressed in uppercase.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value of the variable.
        """
elif False:
    GitOpsApplicationsApplicationSpecSourcePluginEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSourcePluginEnvArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the variable, usually expressed in uppercase.
        :param pulumi.Input[builtins.str] value: Value of the variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the variable, usually expressed in uppercase.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value of the variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSyncPolicyArgsDict(TypedDict):
        automateds: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgsDict']]]]
        """
        Controls the behavior of an automated sync.
        """
        retries: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryArgsDict']]]]
        """
        Contains information about the strategy to apply when a sync failed.
        """
        sync_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Options allow you to specify whole app sync-options.
        """
elif False:
    GitOpsApplicationsApplicationSpecSyncPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSyncPolicyArgs:
    def __init__(__self__, *,
                 automateds: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs']]]] = None,
                 retries: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs']]]] = None,
                 sync_options: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs']]] automateds: Controls the behavior of an automated sync.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs']]] retries: Contains information about the strategy to apply when a sync failed.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] sync_options: Options allow you to specify whole app sync-options.
        """
        if automateds is not None:
            pulumi.set(__self__, "automateds", automateds)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if sync_options is not None:
            pulumi.set(__self__, "sync_options", sync_options)

    @property
    @pulumi.getter
    def automateds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs']]]]:
        """
        Controls the behavior of an automated sync.
        """
        return pulumi.get(self, "automateds")

    @automateds.setter
    def automateds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs']]]]):
        pulumi.set(self, "automateds", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs']]]]:
        """
        Contains information about the strategy to apply when a sync failed.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs']]]]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter(name="syncOptions")
    def sync_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Options allow you to specify whole app sync-options.
        """
        return pulumi.get(self, "sync_options")

    @sync_options.setter
    def sync_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "sync_options", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgsDict(TypedDict):
        allow_empty: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates to allows apps to have zero live resources (default: false).
        """
        prune: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        """
        self_heal: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
elif False:
    GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs:
    def __init__(__self__, *,
                 allow_empty: Optional[pulumi.Input[builtins.bool]] = None,
                 prune: Optional[pulumi.Input[builtins.bool]] = None,
                 self_heal: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] allow_empty: Indicates to allows apps to have zero live resources (default: false).
        :param pulumi.Input[builtins.bool] prune: Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        :param pulumi.Input[builtins.bool] self_heal: Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
        if allow_empty is not None:
            pulumi.set(__self__, "allow_empty", allow_empty)
        if prune is not None:
            pulumi.set(__self__, "prune", prune)
        if self_heal is not None:
            pulumi.set(__self__, "self_heal", self_heal)

    @property
    @pulumi.getter(name="allowEmpty")
    def allow_empty(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates to allows apps to have zero live resources (default: false).
        """
        return pulumi.get(self, "allow_empty")

    @allow_empty.setter
    def allow_empty(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "allow_empty", value)

    @property
    @pulumi.getter
    def prune(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        """
        return pulumi.get(self, "prune")

    @prune.setter
    def prune(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "prune", value)

    @property
    @pulumi.getter(name="selfHeal")
    def self_heal(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
        return pulumi.get(self, "self_heal")

    @self_heal.setter
    def self_heal(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "self_heal", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSyncPolicyRetryArgsDict(TypedDict):
        backoffs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgsDict']]]]
        """
        Backoff strategy to use on subsequent retries for failing syncs.
        """
        limit: NotRequired[pulumi.Input[builtins.str]]
        """
        Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
elif False:
    GitOpsApplicationsApplicationSpecSyncPolicyRetryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs:
    def __init__(__self__, *,
                 backoffs: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs']]]] = None,
                 limit: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs']]] backoffs: Backoff strategy to use on subsequent retries for failing syncs.
        :param pulumi.Input[builtins.str] limit: Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
        if backoffs is not None:
            pulumi.set(__self__, "backoffs", backoffs)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def backoffs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs']]]]:
        """
        Backoff strategy to use on subsequent retries for failing syncs.
        """
        return pulumi.get(self, "backoffs")

    @backoffs.setter
    def backoffs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs']]]]):
        pulumi.set(self, "backoffs", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "limit", value)


if not MYPY:
    class GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        """
        factor: NotRequired[pulumi.Input[builtins.str]]
        """
        Factor to multiply the base duration after each failed retry.
        """
        max_duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Maximum amount of time allowed of the backoff strategy.
        """
elif False:
    GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[builtins.str]] = None,
                 factor: Optional[pulumi.Input[builtins.str]] = None,
                 max_duration: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] duration: Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        :param pulumi.Input[builtins.str] factor: Factor to multiply the base duration after each failed retry.
        :param pulumi.Input[builtins.str] max_duration: Maximum amount of time allowed of the backoff strategy.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if factor is not None:
            pulumi.set(__self__, "factor", factor)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def factor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Factor to multiply the base duration after each failed retry.
        """
        return pulumi.get(self, "factor")

    @factor.setter
    def factor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "factor", value)

    @property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Maximum amount of time allowed of the backoff strategy.
        """
        return pulumi.get(self, "max_duration")

    @max_duration.setter
    def max_duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "max_duration", value)


if not MYPY:
    class GitOpsClusterRequestArgsDict(TypedDict):
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterArgsDict']]]]
        """
        GitOps cluster details.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        """
        updated_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Fields which are updated.
        """
        upsert: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
elif False:
    GitOpsClusterRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestArgs:
    def __init__(__self__, *,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 updated_fields: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 upsert: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterArgs']]] clusters: GitOps cluster details.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] updated_fields: Fields which are updated.
        :param pulumi.Input[builtins.bool] upsert: Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_fields is not None:
            pulumi.set(__self__, "updated_fields", updated_fields)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterArgs']]]]:
        """
        GitOps cluster details.
        """
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterArgs']]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="updatedFields")
    def updated_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Fields which are updated.
        """
        return pulumi.get(self, "updated_fields")

    @updated_fields.setter
    def updated_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "updated_fields", value)

    @property
    @pulumi.getter
    def upsert(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "upsert", value)


if not MYPY:
    class GitOpsClusterRequestClusterArgsDict(TypedDict):
        configs: pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigArgsDict']]]
        """
        GitOps cluster config.
        """
        server: pulumi.Input[builtins.str]
        """
        API server URL of the kubernetes cluster.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations for cluster secret metadata.
        """
        cluster_resources: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        """
        infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoArgsDict']]]]
        """
        Information about cluster cache and state.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Labels for cluster secret metadata.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the cluster. If omitted, the server address will be used.
        """
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        """
        project: NotRequired[pulumi.Input[builtins.str]]
        """
        The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        """
        refresh_requested_ats: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterRefreshRequestedAtArgsDict']]]]
        """
        Time when cluster cache refresh has been requested.
        """
        shard: NotRequired[pulumi.Input[builtins.str]]
        """
        Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
elif False:
    GitOpsClusterRequestClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterArgs:
    def __init__(__self__, *,
                 configs: pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigArgs']]],
                 server: pulumi.Input[builtins.str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_resources: Optional[pulumi.Input[builtins.bool]] = None,
                 infos: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoArgs']]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 project: Optional[pulumi.Input[builtins.str]] = None,
                 refresh_requested_ats: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterRefreshRequestedAtArgs']]]] = None,
                 shard: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigArgs']]] configs: GitOps cluster config.
        :param pulumi.Input[builtins.str] server: API server URL of the kubernetes cluster.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Annotations for cluster secret metadata.
        :param pulumi.Input[builtins.bool] cluster_resources: Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoArgs']]] infos: Information about cluster cache and state.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Labels for cluster secret metadata.
        :param pulumi.Input[builtins.str] name: Name of the cluster. If omitted, the server address will be used.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] namespaces: List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        :param pulumi.Input[builtins.str] project: The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterRefreshRequestedAtArgs']]] refresh_requested_ats: Time when cluster cache refresh has been requested.
        :param pulumi.Input[builtins.str] shard: Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "server", server)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_resources is not None:
            pulumi.set(__self__, "cluster_resources", cluster_resources)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if refresh_requested_ats is not None:
            pulumi.set(__self__, "refresh_requested_ats", refresh_requested_ats)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)

    @property
    @pulumi.getter
    def configs(self) -> pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigArgs']]]:
        """
        GitOps cluster config.
        """
        return pulumi.get(self, "configs")

    @configs.setter
    def configs(self, value: pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigArgs']]]):
        pulumi.set(self, "configs", value)

    @property
    @pulumi.getter
    def server(self) -> pulumi.Input[builtins.str]:
        """
        API server URL of the kubernetes cluster.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "server", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations for cluster secret metadata.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterResources")
    def cluster_resources(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        """
        return pulumi.get(self, "cluster_resources")

    @cluster_resources.setter
    def cluster_resources(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "cluster_resources", value)

    @property
    @pulumi.getter
    def infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoArgs']]]]:
        """
        Information about cluster cache and state.
        """
        return pulumi.get(self, "infos")

    @infos.setter
    def infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoArgs']]]]):
        pulumi.set(self, "infos", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Labels for cluster secret metadata.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the cluster. If omitted, the server address will be used.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="refreshRequestedAts")
    def refresh_requested_ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterRefreshRequestedAtArgs']]]]:
        """
        Time when cluster cache refresh has been requested.
        """
        return pulumi.get(self, "refresh_requested_ats")

    @refresh_requested_ats.setter
    def refresh_requested_ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterRefreshRequestedAtArgs']]]]):
        pulumi.set(self, "refresh_requested_ats", value)

    @property
    @pulumi.getter
    def shard(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
        return pulumi.get(self, "shard")

    @shard.setter
    def shard(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "shard", value)


if not MYPY:
    class GitOpsClusterRequestClusterConfigArgsDict(TypedDict):
        aws_cluster_name: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        """
        bearer_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Bearer authentication token the cluster.
        """
        cluster_connection_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifies the authentication method used to connect to the cluster.
        """
        disable_compression: NotRequired[pulumi.Input[builtins.bool]]
        """
        DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        """
        exec_provider_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigExecProviderConfigArgsDict']]]]
        """
        Configuration for an exec provider.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password of the server of the cluster.
        """
        proxy_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The URL to the proxy to be used for all requests send to the cluster's API server
        """
        role_arn: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional role ARN. If set then used for AWS IAM Authenticator.
        """
        tls_client_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigTlsClientConfigArgsDict']]]]
        """
        Settings to enable transport layer security.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username of the server of the cluster.
        """
elif False:
    GitOpsClusterRequestClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterConfigArgs:
    def __init__(__self__, *,
                 aws_cluster_name: Optional[pulumi.Input[builtins.str]] = None,
                 bearer_token: Optional[pulumi.Input[builtins.str]] = None,
                 cluster_connection_type: Optional[pulumi.Input[builtins.str]] = None,
                 disable_compression: Optional[pulumi.Input[builtins.bool]] = None,
                 exec_provider_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigExecProviderConfigArgs']]]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 proxy_url: Optional[pulumi.Input[builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[builtins.str]] = None,
                 tls_client_configs: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigTlsClientConfigArgs']]]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] aws_cluster_name: AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        :param pulumi.Input[builtins.str] bearer_token: Bearer authentication token the cluster.
        :param pulumi.Input[builtins.str] cluster_connection_type: Identifies the authentication method used to connect to the cluster.
        :param pulumi.Input[builtins.bool] disable_compression: DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigExecProviderConfigArgs']]] exec_provider_configs: Configuration for an exec provider.
        :param pulumi.Input[builtins.str] password: Password of the server of the cluster.
        :param pulumi.Input[builtins.str] proxy_url: The URL to the proxy to be used for all requests send to the cluster's API server
        :param pulumi.Input[builtins.str] role_arn: Optional role ARN. If set then used for AWS IAM Authenticator.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigTlsClientConfigArgs']]] tls_client_configs: Settings to enable transport layer security.
        :param pulumi.Input[builtins.str] username: Username of the server of the cluster.
        """
        if aws_cluster_name is not None:
            pulumi.set(__self__, "aws_cluster_name", aws_cluster_name)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if cluster_connection_type is not None:
            pulumi.set(__self__, "cluster_connection_type", cluster_connection_type)
        if disable_compression is not None:
            pulumi.set(__self__, "disable_compression", disable_compression)
        if exec_provider_configs is not None:
            pulumi.set(__self__, "exec_provider_configs", exec_provider_configs)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if tls_client_configs is not None:
            pulumi.set(__self__, "tls_client_configs", tls_client_configs)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="awsClusterName")
    def aws_cluster_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        """
        return pulumi.get(self, "aws_cluster_name")

    @aws_cluster_name.setter
    def aws_cluster_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aws_cluster_name", value)

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Bearer authentication token the cluster.
        """
        return pulumi.get(self, "bearer_token")

    @bearer_token.setter
    def bearer_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "bearer_token", value)

    @property
    @pulumi.getter(name="clusterConnectionType")
    def cluster_connection_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifies the authentication method used to connect to the cluster.
        """
        return pulumi.get(self, "cluster_connection_type")

    @cluster_connection_type.setter
    def cluster_connection_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_connection_type", value)

    @property
    @pulumi.getter(name="disableCompression")
    def disable_compression(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        """
        return pulumi.get(self, "disable_compression")

    @disable_compression.setter
    def disable_compression(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_compression", value)

    @property
    @pulumi.getter(name="execProviderConfigs")
    def exec_provider_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigExecProviderConfigArgs']]]]:
        """
        Configuration for an exec provider.
        """
        return pulumi.get(self, "exec_provider_configs")

    @exec_provider_configs.setter
    def exec_provider_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigExecProviderConfigArgs']]]]):
        pulumi.set(self, "exec_provider_configs", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password of the server of the cluster.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The URL to the proxy to be used for all requests send to the cluster's API server
        """
        return pulumi.get(self, "proxy_url")

    @proxy_url.setter
    def proxy_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "proxy_url", value)

    @property
    @pulumi.getter(name="roleARN")
    def role_arn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional role ARN. If set then used for AWS IAM Authenticator.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="tlsClientConfigs")
    def tls_client_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigTlsClientConfigArgs']]]]:
        """
        Settings to enable transport layer security.
        """
        return pulumi.get(self, "tls_client_configs")

    @tls_client_configs.setter
    def tls_client_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterConfigTlsClientConfigArgs']]]]):
        pulumi.set(self, "tls_client_configs", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username of the server of the cluster.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GitOpsClusterRequestClusterConfigExecProviderConfigArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Preferred input version of the ExecInfo.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Arguments to pass to the command when executing it.
        """
        command: NotRequired[pulumi.Input[builtins.str]]
        """
        Command to execute.
        """
        env: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Additional environment variables to expose to the process.
        """
        install_hint: NotRequired[pulumi.Input[builtins.str]]
        """
        Message displayed when the executable is not found.
        """
elif False:
    GitOpsClusterRequestClusterConfigExecProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterConfigExecProviderConfigArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[builtins.str]] = None,
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 command: Optional[pulumi.Input[builtins.str]] = None,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 install_hint: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_version: Preferred input version of the ExecInfo.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] args: Arguments to pass to the command when executing it.
        :param pulumi.Input[builtins.str] command: Command to execute.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] env: Additional environment variables to expose to the process.
        :param pulumi.Input[builtins.str] install_hint: Message displayed when the executable is not found.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if install_hint is not None:
            pulumi.set(__self__, "install_hint", install_hint)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Preferred input version of the ExecInfo.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Arguments to pass to the command when executing it.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "args", value)

    @property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Command to execute.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Additional environment variables to expose to the process.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "env", value)

    @property
    @pulumi.getter(name="installHint")
    def install_hint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Message displayed when the executable is not found.
        """
        return pulumi.get(self, "install_hint")

    @install_hint.setter
    def install_hint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "install_hint", value)


if not MYPY:
    class GitOpsClusterRequestClusterConfigTlsClientConfigArgsDict(TypedDict):
        ca_data: NotRequired[pulumi.Input[builtins.str]]
        """
        CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        """
        cert_data: NotRequired[pulumi.Input[builtins.str]]
        """
        Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        insecure: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the TLS connection to the cluster should be insecure.
        """
        key_data: NotRequired[pulumi.Input[builtins.str]]
        """
        Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        server_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
elif False:
    GitOpsClusterRequestClusterConfigTlsClientConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterConfigTlsClientConfigArgs:
    def __init__(__self__, *,
                 ca_data: Optional[pulumi.Input[builtins.str]] = None,
                 cert_data: Optional[pulumi.Input[builtins.str]] = None,
                 insecure: Optional[pulumi.Input[builtins.bool]] = None,
                 key_data: Optional[pulumi.Input[builtins.str]] = None,
                 server_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ca_data: CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        :param pulumi.Input[builtins.str] cert_data: Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        :param pulumi.Input[builtins.bool] insecure: Indicates if the TLS connection to the cluster should be insecure.
        :param pulumi.Input[builtins.str] key_data: Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        :param pulumi.Input[builtins.str] server_name: Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
        if ca_data is not None:
            pulumi.set(__self__, "ca_data", ca_data)
        if cert_data is not None:
            pulumi.set(__self__, "cert_data", cert_data)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caData")
    def ca_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        """
        return pulumi.get(self, "ca_data")

    @ca_data.setter
    def ca_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ca_data", value)

    @property
    @pulumi.getter(name="certData")
    def cert_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "cert_data")

    @cert_data.setter
    def cert_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert_data", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the TLS connection to the cluster should be insecure.
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class GitOpsClusterRequestClusterInfoArgsDict(TypedDict):
        api_versions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of API versions supported by the cluster.
        """
        applications_count: NotRequired[pulumi.Input[builtins.str]]
        """
        Number of applications managed by Argo CD on the cluster.
        """
        cache_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoCacheInfoArgsDict']]]]
        """
        Information about the cluster cache.
        """
        connection_states: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateArgsDict']]]]
        """
        Information about the connection to the cluster.
        """
        server_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Kubernetes version of the cluster.
        """
elif False:
    GitOpsClusterRequestClusterInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterInfoArgs:
    def __init__(__self__, *,
                 api_versions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 applications_count: Optional[pulumi.Input[builtins.str]] = None,
                 cache_infos: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoCacheInfoArgs']]]] = None,
                 connection_states: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateArgs']]]] = None,
                 server_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] api_versions: List of API versions supported by the cluster.
        :param pulumi.Input[builtins.str] applications_count: Number of applications managed by Argo CD on the cluster.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoCacheInfoArgs']]] cache_infos: Information about the cluster cache.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateArgs']]] connection_states: Information about the connection to the cluster.
        :param pulumi.Input[builtins.str] server_version: Kubernetes version of the cluster.
        """
        if api_versions is not None:
            pulumi.set(__self__, "api_versions", api_versions)
        if applications_count is not None:
            pulumi.set(__self__, "applications_count", applications_count)
        if cache_infos is not None:
            pulumi.set(__self__, "cache_infos", cache_infos)
        if connection_states is not None:
            pulumi.set(__self__, "connection_states", connection_states)
        if server_version is not None:
            pulumi.set(__self__, "server_version", server_version)

    @property
    @pulumi.getter(name="apiVersions")
    def api_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of API versions supported by the cluster.
        """
        return pulumi.get(self, "api_versions")

    @api_versions.setter
    def api_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "api_versions", value)

    @property
    @pulumi.getter(name="applicationsCount")
    def applications_count(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Number of applications managed by Argo CD on the cluster.
        """
        return pulumi.get(self, "applications_count")

    @applications_count.setter
    def applications_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "applications_count", value)

    @property
    @pulumi.getter(name="cacheInfos")
    def cache_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoCacheInfoArgs']]]]:
        """
        Information about the cluster cache.
        """
        return pulumi.get(self, "cache_infos")

    @cache_infos.setter
    def cache_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoCacheInfoArgs']]]]):
        pulumi.set(self, "cache_infos", value)

    @property
    @pulumi.getter(name="connectionStates")
    def connection_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateArgs']]]]:
        """
        Information about the connection to the cluster.
        """
        return pulumi.get(self, "connection_states")

    @connection_states.setter
    def connection_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateArgs']]]]):
        pulumi.set(self, "connection_states", value)

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kubernetes version of the cluster.
        """
        return pulumi.get(self, "server_version")

    @server_version.setter
    def server_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_version", value)


if not MYPY:
    class GitOpsClusterRequestClusterInfoCacheInfoArgsDict(TypedDict):
        apis_count: NotRequired[pulumi.Input[builtins.str]]
        """
        Number of observed kubernetes API count.
        """
        last_cache_sync_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Time of most recent cache synchronization.
        """
        resources_count: NotRequired[pulumi.Input[builtins.str]]
        """
        Number of observed kubernetes resources.
        """
elif False:
    GitOpsClusterRequestClusterInfoCacheInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterInfoCacheInfoArgs:
    def __init__(__self__, *,
                 apis_count: Optional[pulumi.Input[builtins.str]] = None,
                 last_cache_sync_time: Optional[pulumi.Input[builtins.str]] = None,
                 resources_count: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] apis_count: Number of observed kubernetes API count.
        :param pulumi.Input[builtins.str] last_cache_sync_time: Time of most recent cache synchronization.
        :param pulumi.Input[builtins.str] resources_count: Number of observed kubernetes resources.
        """
        if apis_count is not None:
            pulumi.set(__self__, "apis_count", apis_count)
        if last_cache_sync_time is not None:
            pulumi.set(__self__, "last_cache_sync_time", last_cache_sync_time)
        if resources_count is not None:
            pulumi.set(__self__, "resources_count", resources_count)

    @property
    @pulumi.getter(name="apisCount")
    def apis_count(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Number of observed kubernetes API count.
        """
        return pulumi.get(self, "apis_count")

    @apis_count.setter
    def apis_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "apis_count", value)

    @property
    @pulumi.getter(name="lastCacheSyncTime")
    def last_cache_sync_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time of most recent cache synchronization.
        """
        return pulumi.get(self, "last_cache_sync_time")

    @last_cache_sync_time.setter
    def last_cache_sync_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_cache_sync_time", value)

    @property
    @pulumi.getter(name="resourcesCount")
    def resources_count(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Number of observed kubernetes resources.
        """
        return pulumi.get(self, "resources_count")

    @resources_count.setter
    def resources_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resources_count", value)


if not MYPY:
    class GitOpsClusterRequestClusterInfoConnectionStateArgsDict(TypedDict):
        attempted_ats: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgsDict']]]]
        """
        Time when cluster cache refresh has been requested.
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        Information about the connection status.
        """
        status: NotRequired[pulumi.Input[builtins.str]]
        """
        Current status indicator of the connection.
        """
elif False:
    GitOpsClusterRequestClusterInfoConnectionStateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterInfoConnectionStateArgs:
    def __init__(__self__, *,
                 attempted_ats: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs']]]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs']]] attempted_ats: Time when cluster cache refresh has been requested.
        :param pulumi.Input[builtins.str] message: Information about the connection status.
        :param pulumi.Input[builtins.str] status: Current status indicator of the connection.
        """
        if attempted_ats is not None:
            pulumi.set(__self__, "attempted_ats", attempted_ats)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="attemptedAts")
    def attempted_ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs']]]]:
        """
        Time when cluster cache refresh has been requested.
        """
        return pulumi.get(self, "attempted_ats")

    @attempted_ats.setter
    def attempted_ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs']]]]):
        pulumi.set(self, "attempted_ats", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Information about the connection status.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Current status indicator of the connection.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgsDict(TypedDict):
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        seconds: NotRequired[pulumi.Input[builtins.str]]
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
elif False:
    GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs:
    def __init__(__self__, *,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] nanos: Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        :param pulumi.Input[builtins.str] seconds: Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class GitOpsClusterRequestClusterRefreshRequestedAtArgsDict(TypedDict):
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        seconds: NotRequired[pulumi.Input[builtins.str]]
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
elif False:
    GitOpsClusterRequestClusterRefreshRequestedAtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsClusterRequestClusterRefreshRequestedAtArgs:
    def __init__(__self__, *,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] nanos: Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        :param pulumi.Input[builtins.str] seconds: Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class GitOpsGnupgRequestArgsDict(TypedDict):
        upsert: pulumi.Input[builtins.bool]
        """
        Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        publickeys: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsGnupgRequestPublickeyArgsDict']]]]
        """
        Public key details.
        """
elif False:
    GitOpsGnupgRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsGnupgRequestArgs:
    def __init__(__self__, *,
                 upsert: pulumi.Input[builtins.bool],
                 publickeys: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsGnupgRequestPublickeyArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] upsert: Indicates if the GnuPG Key should be inserted if not present or updated if present.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsGnupgRequestPublickeyArgs']]] publickeys: Public key details.
        """
        pulumi.set(__self__, "upsert", upsert)
        if publickeys is not None:
            pulumi.set(__self__, "publickeys", publickeys)

    @property
    @pulumi.getter
    def upsert(self) -> pulumi.Input[builtins.bool]:
        """
        Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "upsert", value)

    @property
    @pulumi.getter
    def publickeys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsGnupgRequestPublickeyArgs']]]]:
        """
        Public key details.
        """
        return pulumi.get(self, "publickeys")

    @publickeys.setter
    def publickeys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsGnupgRequestPublickeyArgs']]]]):
        pulumi.set(self, "publickeys", value)


if not MYPY:
    class GitOpsGnupgRequestPublickeyArgsDict(TypedDict):
        key_data: pulumi.Input[builtins.str]
        """
        KeyData holds the raw key data, in base64 encoded format.
        """
        fingerprint: NotRequired[pulumi.Input[builtins.str]]
        """
        Fingerprint is the fingerprint of the key
        """
        key_id: NotRequired[pulumi.Input[builtins.str]]
        """
        KeyID specifies the key ID, in hexadecimal string format.
        """
        owner: NotRequired[pulumi.Input[builtins.str]]
        """
        Owner holds the owner identification, e.g. a name and e-mail address
        """
        sub_type: NotRequired[pulumi.Input[builtins.str]]
        """
        SubType holds the key's sub type
        """
        trust: NotRequired[pulumi.Input[builtins.str]]
        """
        Trust holds the level of trust assigned to this key
        """
elif False:
    GitOpsGnupgRequestPublickeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsGnupgRequestPublickeyArgs:
    def __init__(__self__, *,
                 key_data: pulumi.Input[builtins.str],
                 fingerprint: Optional[pulumi.Input[builtins.str]] = None,
                 key_id: Optional[pulumi.Input[builtins.str]] = None,
                 owner: Optional[pulumi.Input[builtins.str]] = None,
                 sub_type: Optional[pulumi.Input[builtins.str]] = None,
                 trust: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key_data: KeyData holds the raw key data, in base64 encoded format.
        :param pulumi.Input[builtins.str] fingerprint: Fingerprint is the fingerprint of the key
        :param pulumi.Input[builtins.str] key_id: KeyID specifies the key ID, in hexadecimal string format.
        :param pulumi.Input[builtins.str] owner: Owner holds the owner identification, e.g. a name and e-mail address
        :param pulumi.Input[builtins.str] sub_type: SubType holds the key's sub type
        :param pulumi.Input[builtins.str] trust: Trust holds the level of trust assigned to this key
        """
        pulumi.set(__self__, "key_data", key_data)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)
        if trust is not None:
            pulumi.set(__self__, "trust", trust)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> pulumi.Input[builtins.str]:
        """
        KeyData holds the raw key data, in base64 encoded format.
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fingerprint is the fingerprint of the key
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        KeyID specifies the key ID, in hexadecimal string format.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Owner holds the owner identification, e.g. a name and e-mail address
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SubType holds the key's sub type
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sub_type", value)

    @property
    @pulumi.getter
    def trust(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Trust holds the level of trust assigned to this key
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "trust", value)


if not MYPY:
    class GitOpsRepoCertRequestArgsDict(TypedDict):
        certificates: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateArgsDict']]]]
        """
        certificates details.
        """
        upsert: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
        """
elif False:
    GitOpsRepoCertRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepoCertRequestArgs:
    def __init__(__self__, *,
                 certificates: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateArgs']]]] = None,
                 upsert: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateArgs']]] certificates: certificates details.
        :param pulumi.Input[builtins.bool] upsert: Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
        """
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateArgs']]]]:
        """
        certificates details.
        """
        return pulumi.get(self, "certificates")

    @certificates.setter
    def certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateArgs']]]]):
        pulumi.set(self, "certificates", value)

    @property
    @pulumi.getter
    def upsert(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "upsert", value)


if not MYPY:
    class GitOpsRepoCertRequestCertificateArgsDict(TypedDict):
        items: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateItemArgsDict']]]]
        """
        List of certificates to be processed.
        """
        metadatas: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateMetadataArgsDict']]]]
        """
        metadata details
        """
elif False:
    GitOpsRepoCertRequestCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepoCertRequestCertificateArgs:
    def __init__(__self__, *,
                 items: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateItemArgs']]]] = None,
                 metadatas: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateMetadataArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateItemArgs']]] items: List of certificates to be processed.
        :param pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateMetadataArgs']]] metadatas: metadata details
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)

    @property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateItemArgs']]]]:
        """
        List of certificates to be processed.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateItemArgs']]]]):
        pulumi.set(self, "items", value)

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateMetadataArgs']]]]:
        """
        metadata details
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitOpsRepoCertRequestCertificateMetadataArgs']]]]):
        pulumi.set(self, "metadatas", value)


if not MYPY:
    class GitOpsRepoCertRequestCertificateItemArgsDict(TypedDict):
        cert_data: NotRequired[pulumi.Input[builtins.str]]
        """
        CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
        """
        cert_info: NotRequired[pulumi.Input[builtins.str]]
        """
        CertInfo will hold additional certificate info, dependent on the certificate type .
        """
        cert_sub_type: NotRequired[pulumi.Input[builtins.str]]
        """
        CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
        """
        cert_type: NotRequired[pulumi.Input[builtins.str]]
        """
        CertType specifies the type of the certificate - currently one of https or ssh.
        """
        server_name: NotRequired[pulumi.Input[builtins.str]]
        """
        ServerName specifies the DNS name of the server this certificate is intended.
        """
elif False:
    GitOpsRepoCertRequestCertificateItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepoCertRequestCertificateItemArgs:
    def __init__(__self__, *,
                 cert_data: Optional[pulumi.Input[builtins.str]] = None,
                 cert_info: Optional[pulumi.Input[builtins.str]] = None,
                 cert_sub_type: Optional[pulumi.Input[builtins.str]] = None,
                 cert_type: Optional[pulumi.Input[builtins.str]] = None,
                 server_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cert_data: CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
        :param pulumi.Input[builtins.str] cert_info: CertInfo will hold additional certificate info, dependent on the certificate type .
        :param pulumi.Input[builtins.str] cert_sub_type: CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
        :param pulumi.Input[builtins.str] cert_type: CertType specifies the type of the certificate - currently one of https or ssh.
        :param pulumi.Input[builtins.str] server_name: ServerName specifies the DNS name of the server this certificate is intended.
        """
        if cert_data is not None:
            pulumi.set(__self__, "cert_data", cert_data)
        if cert_info is not None:
            pulumi.set(__self__, "cert_info", cert_info)
        if cert_sub_type is not None:
            pulumi.set(__self__, "cert_sub_type", cert_sub_type)
        if cert_type is not None:
            pulumi.set(__self__, "cert_type", cert_type)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="certData")
    def cert_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
        """
        return pulumi.get(self, "cert_data")

    @cert_data.setter
    def cert_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert_data", value)

    @property
    @pulumi.getter(name="certInfo")
    def cert_info(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CertInfo will hold additional certificate info, dependent on the certificate type .
        """
        return pulumi.get(self, "cert_info")

    @cert_info.setter
    def cert_info(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert_info", value)

    @property
    @pulumi.getter(name="certSubType")
    def cert_sub_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
        """
        return pulumi.get(self, "cert_sub_type")

    @cert_sub_type.setter
    def cert_sub_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert_sub_type", value)

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        CertType specifies the type of the certificate - currently one of https or ssh.
        """
        return pulumi.get(self, "cert_type")

    @cert_type.setter
    def cert_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cert_type", value)

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ServerName specifies the DNS name of the server this certificate is intended.
        """
        return pulumi.get(self, "server_name")

    @server_name.setter
    def server_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_name", value)


if not MYPY:
    class GitOpsRepoCertRequestCertificateMetadataArgsDict(TypedDict):
        continue_: NotRequired[pulumi.Input[builtins.str]]
        """
        continue may be set if the user set a limit on the number of items returned.
        """
        remaining_item_count: NotRequired[pulumi.Input[builtins.str]]
        """
        subsequent items in the list.
        """
        resource_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifies the server's internal version.
        """
        self_link: NotRequired[pulumi.Input[builtins.str]]
        """
        selfLink is a URL representing this object.
        """
elif False:
    GitOpsRepoCertRequestCertificateMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepoCertRequestCertificateMetadataArgs:
    def __init__(__self__, *,
                 continue_: Optional[pulumi.Input[builtins.str]] = None,
                 remaining_item_count: Optional[pulumi.Input[builtins.str]] = None,
                 resource_version: Optional[pulumi.Input[builtins.str]] = None,
                 self_link: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] continue_: continue may be set if the user set a limit on the number of items returned.
        :param pulumi.Input[builtins.str] remaining_item_count: subsequent items in the list.
        :param pulumi.Input[builtins.str] resource_version: Identifies the server's internal version.
        :param pulumi.Input[builtins.str] self_link: selfLink is a URL representing this object.
        """
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if remaining_item_count is not None:
            pulumi.set(__self__, "remaining_item_count", remaining_item_count)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if self_link is not None:
            pulumi.set(__self__, "self_link", self_link)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        continue may be set if the user set a limit on the number of items returned.
        """
        return pulumi.get(self, "continue_")

    @continue_.setter
    def continue_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "continue_", value)

    @property
    @pulumi.getter(name="remainingItemCount")
    def remaining_item_count(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        subsequent items in the list.
        """
        return pulumi.get(self, "remaining_item_count")

    @remaining_item_count.setter
    def remaining_item_count(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "remaining_item_count", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifies the server's internal version.
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_version", value)

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        selfLink is a URL representing this object.
        """
        return pulumi.get(self, "self_link")

    @self_link.setter
    def self_link(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "self_link", value)


if not MYPY:
    class GitOpsRepoCredCredArgsDict(TypedDict):
        enable_oci: NotRequired[pulumi.Input[builtins.bool]]
        """
        Specifies whether helm-oci support should be enabled for this repo.
        """
        github_app_enterprise_base_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the GitHub API URL for GitHub app authentication.
        """
        github_app_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        """
        github_app_installation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies the ID of the installed GitHub App for GitHub app authentication.
        """
        github_app_private_key: NotRequired[pulumi.Input[builtins.str]]
        """
        github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        ssh_private_key: NotRequired[pulumi.Input[builtins.str]]
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        tls_client_cert_data: NotRequired[pulumi.Input[builtins.str]]
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        tls_client_cert_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to be used for authenticating the remote repository.
        """
elif False:
    GitOpsRepoCredCredArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepoCredCredArgs:
    def __init__(__self__, *,
                 enable_oci: Optional[pulumi.Input[builtins.bool]] = None,
                 github_app_enterprise_base_url: Optional[pulumi.Input[builtins.str]] = None,
                 github_app_id: Optional[pulumi.Input[builtins.str]] = None,
                 github_app_installation_id: Optional[pulumi.Input[builtins.str]] = None,
                 github_app_private_key: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 ssh_private_key: Optional[pulumi.Input[builtins.str]] = None,
                 tls_client_cert_data: Optional[pulumi.Input[builtins.str]] = None,
                 tls_client_cert_key: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enable_oci: Specifies whether helm-oci support should be enabled for this repo.
        :param pulumi.Input[builtins.str] github_app_enterprise_base_url: Specifies the GitHub API URL for GitHub app authentication.
        :param pulumi.Input[builtins.str] github_app_id: Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        :param pulumi.Input[builtins.str] github_app_installation_id: Specifies the ID of the installed GitHub App for GitHub app authentication.
        :param pulumi.Input[builtins.str] github_app_private_key: github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        :param pulumi.Input[builtins.str] password: Password or PAT to be used for authenticating the remote repository.
        :param pulumi.Input[builtins.str] ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param pulumi.Input[builtins.str] tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        :param pulumi.Input[builtins.str] tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        :param pulumi.Input[builtins.str] type: Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        :param pulumi.Input[builtins.str] url: URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        :param pulumi.Input[builtins.str] username: Username to be used for authenticating the remote repository.
        """
        if enable_oci is not None:
            pulumi.set(__self__, "enable_oci", enable_oci)
        if github_app_enterprise_base_url is not None:
            pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        if github_app_id is not None:
            pulumi.set(__self__, "github_app_id", github_app_id)
        if github_app_installation_id is not None:
            pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        if github_app_private_key is not None:
            pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_private_key is not None:
            pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        if tls_client_cert_data is not None:
            pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        if tls_client_cert_key is not None:
            pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Specifies whether helm-oci support should be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @enable_oci.setter
    def enable_oci(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_oci", value)

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the GitHub API URL for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @github_app_enterprise_base_url.setter
    def github_app_enterprise_base_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_enterprise_base_url", value)

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_id")

    @github_app_id.setter
    def github_app_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_id", value)

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies the ID of the installed GitHub App for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_installation_id")

    @github_app_installation_id.setter
    def github_app_installation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_installation_id", value)

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        """
        return pulumi.get(self, "github_app_private_key")

    @github_app_private_key.setter
    def github_app_private_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_private_key", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @ssh_private_key.setter
    def ssh_private_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssh_private_key", value)

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @tls_client_cert_data.setter
    def tls_client_cert_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_client_cert_data", value)

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @tls_client_cert_key.setter
    def tls_client_cert_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_client_cert_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GitOpsRepositoryEcrGenArgsDict(TypedDict):
        jwt_auth: NotRequired[pulumi.Input['GitOpsRepositoryEcrGenJwtAuthArgsDict']]
        """
        JWT authentication specific configuration.
        """
        region: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS region.
        """
        secret_ref: NotRequired[pulumi.Input['GitOpsRepositoryEcrGenSecretRefArgsDict']]
        """
        Secret reference to the AWS credentials.
        """
elif False:
    GitOpsRepositoryEcrGenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryEcrGenArgs:
    def __init__(__self__, *,
                 jwt_auth: Optional[pulumi.Input['GitOpsRepositoryEcrGenJwtAuthArgs']] = None,
                 region: Optional[pulumi.Input[builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input['GitOpsRepositoryEcrGenSecretRefArgs']] = None):
        """
        :param pulumi.Input['GitOpsRepositoryEcrGenJwtAuthArgs'] jwt_auth: JWT authentication specific configuration.
        :param pulumi.Input[builtins.str] region: AWS region.
        :param pulumi.Input['GitOpsRepositoryEcrGenSecretRefArgs'] secret_ref: Secret reference to the AWS credentials.
        """
        if jwt_auth is not None:
            pulumi.set(__self__, "jwt_auth", jwt_auth)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="jwtAuth")
    def jwt_auth(self) -> Optional[pulumi.Input['GitOpsRepositoryEcrGenJwtAuthArgs']]:
        """
        JWT authentication specific configuration.
        """
        return pulumi.get(self, "jwt_auth")

    @jwt_auth.setter
    def jwt_auth(self, value: Optional[pulumi.Input['GitOpsRepositoryEcrGenJwtAuthArgs']]):
        pulumi.set(self, "jwt_auth", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input['GitOpsRepositoryEcrGenSecretRefArgs']]:
        """
        Secret reference to the AWS credentials.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input['GitOpsRepositoryEcrGenSecretRefArgs']]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class GitOpsRepositoryEcrGenJwtAuthArgsDict(TypedDict):
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the ServiceAccount resource being referred to.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
elif False:
    GitOpsRepositoryEcrGenJwtAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryEcrGenJwtAuthArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] audiences: Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        :param pulumi.Input[builtins.str] name: The name of the ServiceAccount resource being referred to.
        :param pulumi.Input[builtins.str] namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the ServiceAccount resource being referred to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GitOpsRepositoryEcrGenSecretRefArgsDict(TypedDict):
        aws_access_key_id: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS access key id.
        """
        aws_secret_access_key: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS secret access key.
        """
        aws_session_token: NotRequired[pulumi.Input[builtins.str]]
        """
        AWS session token.
        """
elif False:
    GitOpsRepositoryEcrGenSecretRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryEcrGenSecretRefArgs:
    def __init__(__self__, *,
                 aws_access_key_id: Optional[pulumi.Input[builtins.str]] = None,
                 aws_secret_access_key: Optional[pulumi.Input[builtins.str]] = None,
                 aws_session_token: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] aws_access_key_id: AWS access key id.
        :param pulumi.Input[builtins.str] aws_secret_access_key: AWS secret access key.
        :param pulumi.Input[builtins.str] aws_session_token: AWS session token.
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS access key id.
        """
        return pulumi.get(self, "aws_access_key_id")

    @aws_access_key_id.setter
    def aws_access_key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aws_access_key_id", value)

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS secret access key.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @aws_secret_access_key.setter
    def aws_secret_access_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aws_secret_access_key", value)

    @property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        AWS session token.
        """
        return pulumi.get(self, "aws_session_token")

    @aws_session_token.setter
    def aws_session_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "aws_session_token", value)


if not MYPY:
    class GitOpsRepositoryGcrGenArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[builtins.str]]
        """
        GCP access key.
        """
        project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        GCP project id.
        """
        workload_identity: NotRequired[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityArgsDict']]
        """
        GCP workload identity.
        """
elif False:
    GitOpsRepositoryGcrGenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryGcrGenArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[builtins.str]] = None,
                 project_id: Optional[pulumi.Input[builtins.str]] = None,
                 workload_identity: Optional[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityArgs']] = None):
        """
        :param pulumi.Input[builtins.str] access_key: GCP access key.
        :param pulumi.Input[builtins.str] project_id: GCP project id.
        :param pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityArgs'] workload_identity: GCP workload identity.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if workload_identity is not None:
            pulumi.set(__self__, "workload_identity", workload_identity)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GCP access key.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GCP project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="workloadIdentity")
    def workload_identity(self) -> Optional[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityArgs']]:
        """
        GCP workload identity.
        """
        return pulumi.get(self, "workload_identity")

    @workload_identity.setter
    def workload_identity(self, value: Optional[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityArgs']]):
        pulumi.set(self, "workload_identity", value)


if not MYPY:
    class GitOpsRepositoryGcrGenWorkloadIdentityArgsDict(TypedDict):
        cluster_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Cluster location.
        """
        cluster_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Cluster name.
        """
        cluster_project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Cluster project id.
        """
        service_account_ref: NotRequired[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgsDict']]
        """
        Service account reference.
        """
elif False:
    GitOpsRepositoryGcrGenWorkloadIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryGcrGenWorkloadIdentityArgs:
    def __init__(__self__, *,
                 cluster_location: Optional[pulumi.Input[builtins.str]] = None,
                 cluster_name: Optional[pulumi.Input[builtins.str]] = None,
                 cluster_project_id: Optional[pulumi.Input[builtins.str]] = None,
                 service_account_ref: Optional[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs']] = None):
        """
        :param pulumi.Input[builtins.str] cluster_location: Cluster location.
        :param pulumi.Input[builtins.str] cluster_name: Cluster name.
        :param pulumi.Input[builtins.str] cluster_project_id: Cluster project id.
        :param pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs'] service_account_ref: Service account reference.
        """
        if cluster_location is not None:
            pulumi.set(__self__, "cluster_location", cluster_location)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_project_id is not None:
            pulumi.set(__self__, "cluster_project_id", cluster_project_id)
        if service_account_ref is not None:
            pulumi.set(__self__, "service_account_ref", service_account_ref)

    @property
    @pulumi.getter(name="clusterLocation")
    def cluster_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Cluster location.
        """
        return pulumi.get(self, "cluster_location")

    @cluster_location.setter
    def cluster_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_location", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Cluster name.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="clusterProjectId")
    def cluster_project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Cluster project id.
        """
        return pulumi.get(self, "cluster_project_id")

    @cluster_project_id.setter
    def cluster_project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_project_id", value)

    @property
    @pulumi.getter(name="serviceAccountRef")
    def service_account_ref(self) -> Optional[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs']]:
        """
        Service account reference.
        """
        return pulumi.get(self, "service_account_ref")

    @service_account_ref.setter
    def service_account_ref(self, value: Optional[pulumi.Input['GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs']]):
        pulumi.set(self, "service_account_ref", value)


if not MYPY:
    class GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgsDict(TypedDict):
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the ServiceAccount resource being referred to.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
elif False:
    GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] audiences: Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        :param pulumi.Input[builtins.str] name: The name of the ServiceAccount resource being referred to.
        :param pulumi.Input[builtins.str] namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the ServiceAccount resource being referred to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)


if not MYPY:
    class GitOpsRepositoryRepoArgsDict(TypedDict):
        connection_type: pulumi.Input[builtins.str]
        """
        Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS*ANONYMOUS", "GITHUB*ENTERPRISE".
        """
        repo: pulumi.Input[builtins.str]
        """
        URL to the remote repository.
        """
        enable_lfs: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        """
        enable_oci: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if helm-oci support must be enabled for this repo.
        """
        github_app_enterprise_base_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        """
        github_app_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the GitHub app used to access the repo.
        """
        github_app_installation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Installation id of the GitHub app used to access the repo.
        """
        github_app_private_key: NotRequired[pulumi.Input[builtins.str]]
        """
        GitHub app private key PEM data.
        """
        inherited_creds: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the credentials were inherited from a repository credential.
        """
        insecure: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        """
        insecure_ignore_host_key: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name to be used for this repo. Only used with Helm repos.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        project: NotRequired[pulumi.Input[builtins.str]]
        """
        The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        """
        proxy: NotRequired[pulumi.Input[builtins.str]]
        """
        The HTTP/HTTPS proxy used to access the repo.
        """
        ssh_private_key: NotRequired[pulumi.Input[builtins.str]]
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        tls_client_cert_data: NotRequired[pulumi.Input[builtins.str]]
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        tls_client_cert_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        type_: NotRequired[pulumi.Input[builtins.str]]
        """
        Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to be used for authenticating the remote repository.
        """
elif False:
    GitOpsRepositoryRepoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryRepoArgs:
    def __init__(__self__, *,
                 connection_type: pulumi.Input[builtins.str],
                 repo: pulumi.Input[builtins.str],
                 enable_lfs: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_oci: Optional[pulumi.Input[builtins.bool]] = None,
                 github_app_enterprise_base_url: Optional[pulumi.Input[builtins.str]] = None,
                 github_app_id: Optional[pulumi.Input[builtins.str]] = None,
                 github_app_installation_id: Optional[pulumi.Input[builtins.str]] = None,
                 github_app_private_key: Optional[pulumi.Input[builtins.str]] = None,
                 inherited_creds: Optional[pulumi.Input[builtins.bool]] = None,
                 insecure: Optional[pulumi.Input[builtins.bool]] = None,
                 insecure_ignore_host_key: Optional[pulumi.Input[builtins.bool]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 project: Optional[pulumi.Input[builtins.str]] = None,
                 proxy: Optional[pulumi.Input[builtins.str]] = None,
                 ssh_private_key: Optional[pulumi.Input[builtins.str]] = None,
                 tls_client_cert_data: Optional[pulumi.Input[builtins.str]] = None,
                 tls_client_cert_key: Optional[pulumi.Input[builtins.str]] = None,
                 type_: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connection_type: Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS*ANONYMOUS", "GITHUB*ENTERPRISE".
        :param pulumi.Input[builtins.str] repo: URL to the remote repository.
        :param pulumi.Input[builtins.bool] enable_lfs: Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        :param pulumi.Input[builtins.bool] enable_oci: Indicates if helm-oci support must be enabled for this repo.
        :param pulumi.Input[builtins.str] github_app_enterprise_base_url: Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        :param pulumi.Input[builtins.str] github_app_id: Id of the GitHub app used to access the repo.
        :param pulumi.Input[builtins.str] github_app_installation_id: Installation id of the GitHub app used to access the repo.
        :param pulumi.Input[builtins.str] github_app_private_key: GitHub app private key PEM data.
        :param pulumi.Input[builtins.bool] inherited_creds: Indicates if the credentials were inherited from a repository credential.
        :param pulumi.Input[builtins.bool] insecure: Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        :param pulumi.Input[builtins.bool] insecure_ignore_host_key: Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        :param pulumi.Input[builtins.str] name: Name to be used for this repo. Only used with Helm repos.
        :param pulumi.Input[builtins.str] password: Password or PAT to be used for authenticating the remote repository.
        :param pulumi.Input[builtins.str] project: The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        :param pulumi.Input[builtins.str] proxy: The HTTP/HTTPS proxy used to access the repo.
        :param pulumi.Input[builtins.str] ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param pulumi.Input[builtins.str] tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        :param pulumi.Input[builtins.str] tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        :param pulumi.Input[builtins.str] type_: Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        :param pulumi.Input[builtins.str] username: Username to be used for authenticating the remote repository.
        """
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "repo", repo)
        if enable_lfs is not None:
            pulumi.set(__self__, "enable_lfs", enable_lfs)
        if enable_oci is not None:
            pulumi.set(__self__, "enable_oci", enable_oci)
        if github_app_enterprise_base_url is not None:
            pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        if github_app_id is not None:
            pulumi.set(__self__, "github_app_id", github_app_id)
        if github_app_installation_id is not None:
            pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        if github_app_private_key is not None:
            pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        if inherited_creds is not None:
            pulumi.set(__self__, "inherited_creds", inherited_creds)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if insecure_ignore_host_key is not None:
            pulumi.set(__self__, "insecure_ignore_host_key", insecure_ignore_host_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if ssh_private_key is not None:
            pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        if tls_client_cert_data is not None:
            pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        if tls_client_cert_key is not None:
            pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        if type_ is not None:
            pulumi.set(__self__, "type_", type_)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Input[builtins.str]:
        """
        Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS*ANONYMOUS", "GITHUB*ENTERPRISE".
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter
    def repo(self) -> pulumi.Input[builtins.str]:
        """
        URL to the remote repository.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repo", value)

    @property
    @pulumi.getter(name="enableLfs")
    def enable_lfs(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        """
        return pulumi.get(self, "enable_lfs")

    @enable_lfs.setter
    def enable_lfs(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_lfs", value)

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if helm-oci support must be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @enable_oci.setter
    def enable_oci(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_oci", value)

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @github_app_enterprise_base_url.setter
    def github_app_enterprise_base_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_enterprise_base_url", value)

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the GitHub app used to access the repo.
        """
        return pulumi.get(self, "github_app_id")

    @github_app_id.setter
    def github_app_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_id", value)

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Installation id of the GitHub app used to access the repo.
        """
        return pulumi.get(self, "github_app_installation_id")

    @github_app_installation_id.setter
    def github_app_installation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_installation_id", value)

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        GitHub app private key PEM data.
        """
        return pulumi.get(self, "github_app_private_key")

    @github_app_private_key.setter
    def github_app_private_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "github_app_private_key", value)

    @property
    @pulumi.getter(name="inheritedCreds")
    def inherited_creds(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the credentials were inherited from a repository credential.
        """
        return pulumi.get(self, "inherited_creds")

    @inherited_creds.setter
    def inherited_creds(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "inherited_creds", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter(name="insecureIgnoreHostKey")
    def insecure_ignore_host_key(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        """
        return pulumi.get(self, "insecure_ignore_host_key")

    @insecure_ignore_host_key.setter
    def insecure_ignore_host_key(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "insecure_ignore_host_key", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name to be used for this repo. Only used with Helm repos.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The HTTP/HTTPS proxy used to access the repo.
        """
        return pulumi.get(self, "proxy")

    @proxy.setter
    def proxy(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "proxy", value)

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @ssh_private_key.setter
    def ssh_private_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ssh_private_key", value)

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @tls_client_cert_data.setter
    def tls_client_cert_data(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_client_cert_data", value)

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @tls_client_cert_key.setter
    def tls_client_cert_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tls_client_cert_key", value)

    @property
    @pulumi.getter
    def type_(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        """
        return pulumi.get(self, "type_")

    @type_.setter
    def type_(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type_", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GitOpsRepositoryUpdateMaskArgsDict(TypedDict):
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The set of field mask paths.
        """
elif False:
    GitOpsRepositoryUpdateMaskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitOpsRepositoryUpdateMaskArgs:
    def __init__(__self__, *,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] paths: The set of field mask paths.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The set of field mask paths.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class GithubConnectorApiAuthenticationArgsDict(TypedDict):
        github_app: NotRequired[pulumi.Input['GithubConnectorApiAuthenticationGithubAppArgsDict']]
        """
        Configuration for using the github app for interacting with the github api.
        """
        token_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GithubConnectorApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorApiAuthenticationArgs:
    def __init__(__self__, *,
                 github_app: Optional[pulumi.Input['GithubConnectorApiAuthenticationGithubAppArgs']] = None,
                 token_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input['GithubConnectorApiAuthenticationGithubAppArgs'] github_app: Configuration for using the github app for interacting with the github api.
        :param pulumi.Input[builtins.str] token_ref: Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if github_app is not None:
            pulumi.set(__self__, "github_app", github_app)
        if token_ref is not None:
            pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="githubApp")
    def github_app(self) -> Optional[pulumi.Input['GithubConnectorApiAuthenticationGithubAppArgs']]:
        """
        Configuration for using the github app for interacting with the github api.
        """
        return pulumi.get(self, "github_app")

    @github_app.setter
    def github_app(self, value: Optional[pulumi.Input['GithubConnectorApiAuthenticationGithubAppArgs']]):
        pulumi.set(self, "github_app", value)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_ref", value)


if not MYPY:
    class GithubConnectorApiAuthenticationGithubAppArgsDict(TypedDict):
        private_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        application_id_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        installation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        installation_id_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GithubConnectorApiAuthenticationGithubAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorApiAuthenticationGithubAppArgs:
    def __init__(__self__, *,
                 private_key_ref: pulumi.Input[builtins.str],
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 application_id_ref: Optional[pulumi.Input[builtins.str]] = None,
                 installation_id: Optional[pulumi.Input[builtins.str]] = None,
                 installation_id_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] private_key_ref: Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] application_id: Enter the GitHub App ID from the GitHub App General tab.
        :param pulumi.Input[builtins.str] application_id_ref: Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] installation_id: Enter the Installation ID located in the URL of the installed GitHub App.
        :param pulumi.Input[builtins.str] installation_id_ref: Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_id_ref is not None:
            pulumi.set(__self__, "application_id_ref", application_id_ref)
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)
        if installation_id_ref is not None:
            pulumi.set(__self__, "installation_id_ref", installation_id_ref)

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @private_key_ref.setter
    def private_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "private_key_ref", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="applicationIdRef")
    def application_id_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "application_id_ref")

    @application_id_ref.setter
    def application_id_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id_ref", value)

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        return pulumi.get(self, "installation_id")

    @installation_id.setter
    def installation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "installation_id", value)

    @property
    @pulumi.getter(name="installationIdRef")
    def installation_id_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "installation_id_ref")

    @installation_id_ref.setter
    def installation_id_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "installation_id_ref", value)


if not MYPY:
    class GithubConnectorCredentialsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input['GithubConnectorCredentialsHttpArgsDict']]
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        ssh: NotRequired[pulumi.Input['GithubConnectorCredentialsSshArgsDict']]
        """
        Authenticate using SSH for the connection.
        """
elif False:
    GithubConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorCredentialsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['GithubConnectorCredentialsHttpArgs']] = None,
                 ssh: Optional[pulumi.Input['GithubConnectorCredentialsSshArgs']] = None):
        """
        :param pulumi.Input['GithubConnectorCredentialsHttpArgs'] http: Authenticate using Username and password over http(s) for the connection.
        :param pulumi.Input['GithubConnectorCredentialsSshArgs'] ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['GithubConnectorCredentialsHttpArgs']]:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['GithubConnectorCredentialsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['GithubConnectorCredentialsSshArgs']]:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['GithubConnectorCredentialsSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class GithubConnectorCredentialsHttpArgsDict(TypedDict):
        anonymouses: NotRequired[pulumi.Input[Sequence[pulumi.Input['GithubConnectorCredentialsHttpAnonymouseArgsDict']]]]
        """
        Configuration for using the http anonymous github for interacting with the github api.
        """
        github_app: NotRequired[pulumi.Input['GithubConnectorCredentialsHttpGithubAppArgsDict']]
        """
        Configuration for using the github app for interacting with the github api.
        """
        token_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GithubConnectorCredentialsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorCredentialsHttpArgs:
    def __init__(__self__, *,
                 anonymouses: Optional[pulumi.Input[Sequence[pulumi.Input['GithubConnectorCredentialsHttpAnonymouseArgs']]]] = None,
                 github_app: Optional[pulumi.Input['GithubConnectorCredentialsHttpGithubAppArgs']] = None,
                 token_ref: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GithubConnectorCredentialsHttpAnonymouseArgs']]] anonymouses: Configuration for using the http anonymous github for interacting with the github api.
        :param pulumi.Input['GithubConnectorCredentialsHttpGithubAppArgs'] github_app: Configuration for using the github app for interacting with the github api.
        :param pulumi.Input[builtins.str] token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if anonymouses is not None:
            pulumi.set(__self__, "anonymouses", anonymouses)
        if github_app is not None:
            pulumi.set(__self__, "github_app", github_app)
        if token_ref is not None:
            pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter
    def anonymouses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GithubConnectorCredentialsHttpAnonymouseArgs']]]]:
        """
        Configuration for using the http anonymous github for interacting with the github api.
        """
        return pulumi.get(self, "anonymouses")

    @anonymouses.setter
    def anonymouses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GithubConnectorCredentialsHttpAnonymouseArgs']]]]):
        pulumi.set(self, "anonymouses", value)

    @property
    @pulumi.getter(name="githubApp")
    def github_app(self) -> Optional[pulumi.Input['GithubConnectorCredentialsHttpGithubAppArgs']]:
        """
        Configuration for using the github app for interacting with the github api.
        """
        return pulumi.get(self, "github_app")

    @github_app.setter
    def github_app(self, value: Optional[pulumi.Input['GithubConnectorCredentialsHttpGithubAppArgs']]):
        pulumi.set(self, "github_app", value)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class GithubConnectorCredentialsHttpAnonymouseArgsDict(TypedDict):
        pass
elif False:
    GithubConnectorCredentialsHttpAnonymouseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorCredentialsHttpAnonymouseArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class GithubConnectorCredentialsHttpGithubAppArgsDict(TypedDict):
        private_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        application_id_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        installation_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        installation_id_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GithubConnectorCredentialsHttpGithubAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorCredentialsHttpGithubAppArgs:
    def __init__(__self__, *,
                 private_key_ref: pulumi.Input[builtins.str],
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 application_id_ref: Optional[pulumi.Input[builtins.str]] = None,
                 installation_id: Optional[pulumi.Input[builtins.str]] = None,
                 installation_id_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] private_key_ref: Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] application_id: Enter the GitHub App ID from the GitHub App General tab.
        :param pulumi.Input[builtins.str] application_id_ref: Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] installation_id: Enter the Installation ID located in the URL of the installed GitHub App.
        :param pulumi.Input[builtins.str] installation_id_ref: Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_id_ref is not None:
            pulumi.set(__self__, "application_id_ref", application_id_ref)
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)
        if installation_id_ref is not None:
            pulumi.set(__self__, "installation_id_ref", installation_id_ref)

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @private_key_ref.setter
    def private_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "private_key_ref", value)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="applicationIdRef")
    def application_id_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "application_id_ref")

    @application_id_ref.setter
    def application_id_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id_ref", value)

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        return pulumi.get(self, "installation_id")

    @installation_id.setter
    def installation_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "installation_id", value)

    @property
    @pulumi.getter(name="installationIdRef")
    def installation_id_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "installation_id_ref")

    @installation_id_ref.setter
    def installation_id_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "installation_id_ref", value)


if not MYPY:
    class GithubConnectorCredentialsSshArgsDict(TypedDict):
        ssh_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GithubConnectorCredentialsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GithubConnectorCredentialsSshArgs:
    def __init__(__self__, *,
                 ssh_key_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")

    @ssh_key_ref.setter
    def ssh_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssh_key_ref", value)


if not MYPY:
    class GitlabConnectorApiAuthenticationArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GitlabConnectorApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitlabConnectorApiAuthenticationArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] token_ref: Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)


if not MYPY:
    class GitlabConnectorCredentialsArgsDict(TypedDict):
        http: NotRequired[pulumi.Input['GitlabConnectorCredentialsHttpArgsDict']]
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        ssh: NotRequired[pulumi.Input['GitlabConnectorCredentialsSshArgsDict']]
        """
        Authenticate using SSH for the connection.
        """
elif False:
    GitlabConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitlabConnectorCredentialsArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['GitlabConnectorCredentialsHttpArgs']] = None,
                 ssh: Optional[pulumi.Input['GitlabConnectorCredentialsSshArgs']] = None):
        """
        :param pulumi.Input['GitlabConnectorCredentialsHttpArgs'] http: Authenticate using Username and password over http(s) for the connection.
        :param pulumi.Input['GitlabConnectorCredentialsSshArgs'] ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['GitlabConnectorCredentialsHttpArgs']]:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['GitlabConnectorCredentialsHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def ssh(self) -> Optional[pulumi.Input['GitlabConnectorCredentialsSshArgs']]:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")

    @ssh.setter
    def ssh(self, value: Optional[pulumi.Input['GitlabConnectorCredentialsSshArgs']]):
        pulumi.set(self, "ssh", value)


if not MYPY:
    class GitlabConnectorCredentialsHttpArgsDict(TypedDict):
        password_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        token_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GitlabConnectorCredentialsHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitlabConnectorCredentialsHttpArgs:
    def __init__(__self__, *,
                 password_ref: Optional[pulumi.Input[builtins.str]] = None,
                 token_ref: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if password_ref is not None:
            pulumi.set(__self__, "password_ref", password_ref)
        if token_ref is not None:
            pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "token_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class GitlabConnectorCredentialsSshArgsDict(TypedDict):
        ssh_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    GitlabConnectorCredentialsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitlabConnectorCredentialsSshArgs:
    def __init__(__self__, *,
                 ssh_key_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")

    @ssh_key_ref.setter
    def ssh_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssh_key_ref", value)


if not MYPY:
    class GitopsAppProjectProjectArgsDict(TypedDict):
        metadatas: pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataArgsDict']]]
        """
        K8s object metadata for the Argo project.
        """
        specs: pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecArgsDict']]]
        """
        Specification details for the Argo project.
        """
elif False:
    GitopsAppProjectProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectArgs:
    def __init__(__self__, *,
                 metadatas: pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataArgs']]],
                 specs: pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataArgs']]] metadatas: K8s object metadata for the Argo project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecArgs']]] specs: Specification details for the Argo project.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "specs", specs)

    @property
    @pulumi.getter
    def metadatas(self) -> pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataArgs']]]:
        """
        K8s object metadata for the Argo project.
        """
        return pulumi.get(self, "metadatas")

    @metadatas.setter
    def metadatas(self, value: pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataArgs']]]):
        pulumi.set(self, "metadatas", value)

    @property
    @pulumi.getter
    def specs(self) -> pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecArgs']]]:
        """
        Specification details for the Argo project.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecArgs']]]):
        pulumi.set(self, "specs", value)


if not MYPY:
    class GitopsAppProjectProjectMetadataArgsDict(TypedDict):
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Annotations associated with the GitOps project.
        """
        cluster_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the cluster associated with the GitOps project.
        """
        finalizers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Finalizers associated with the GitOps project.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Labels associated with the GitOps project.
        """
        managed_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataManagedFieldArgsDict']]]]
        """
        Managed fields associated with the GitOps project.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the GitOps project.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Namespace of the GitOps project. This must be the same as the namespace where the agent is installed
        """
        resource_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Version for the GitOps project
        """
elif False:
    GitopsAppProjectProjectMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectMetadataArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 cluster_name: Optional[pulumi.Input[builtins.str]] = None,
                 finalizers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 managed_fields: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataManagedFieldArgs']]]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 resource_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] annotations: Annotations associated with the GitOps project.
        :param pulumi.Input[builtins.str] cluster_name: Name of the cluster associated with the GitOps project.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] finalizers: Finalizers associated with the GitOps project.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: Labels associated with the GitOps project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataManagedFieldArgs']]] managed_fields: Managed fields associated with the GitOps project.
        :param pulumi.Input[builtins.str] name: Name of the GitOps project.
        :param pulumi.Input[builtins.str] namespace: Namespace of the GitOps project. This must be the same as the namespace where the agent is installed
        :param pulumi.Input[builtins.str] resource_version: Resource Version for the GitOps project
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if finalizers is not None:
            pulumi.set(__self__, "finalizers", finalizers)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if managed_fields is not None:
            pulumi.set(__self__, "managed_fields", managed_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Annotations associated with the GitOps project.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the cluster associated with the GitOps project.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def finalizers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Finalizers associated with the GitOps project.
        """
        return pulumi.get(self, "finalizers")

    @finalizers.setter
    def finalizers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "finalizers", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Labels associated with the GitOps project.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataManagedFieldArgs']]]]:
        """
        Managed fields associated with the GitOps project.
        """
        return pulumi.get(self, "managed_fields")

    @managed_fields.setter
    def managed_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectMetadataManagedFieldArgs']]]]):
        pulumi.set(self, "managed_fields", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the GitOps project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Namespace of the GitOps project. This must be the same as the namespace where the agent is installed
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Version for the GitOps project
        """
        return pulumi.get(self, "resource_version")

    @resource_version.setter
    def resource_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_version", value)


if not MYPY:
    class GitopsAppProjectProjectMetadataManagedFieldArgsDict(TypedDict):
        api_version: NotRequired[pulumi.Input[builtins.str]]
        """
        API version of the operation performed.
        """
        fields_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of the fields in the GitOps project.
        """
        fields_v1: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Raw fields associated with the GitOps project.
        """
        manager: NotRequired[pulumi.Input[builtins.str]]
        """
        Manager responsible for the operation.
        """
        operation: NotRequired[pulumi.Input[builtins.str]]
        """
        Operation type performed on the GitOps project.
        """
        subresource: NotRequired[pulumi.Input[builtins.str]]
        """
        Subresource associated with the GitOps project.
        """
        time: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Timestamp of the operation.
        """
elif False:
    GitopsAppProjectProjectMetadataManagedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectMetadataManagedFieldArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[builtins.str]] = None,
                 fields_type: Optional[pulumi.Input[builtins.str]] = None,
                 fields_v1: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 manager: Optional[pulumi.Input[builtins.str]] = None,
                 operation: Optional[pulumi.Input[builtins.str]] = None,
                 subresource: Optional[pulumi.Input[builtins.str]] = None,
                 time: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] api_version: API version of the operation performed.
        :param pulumi.Input[builtins.str] fields_type: Type of the fields in the GitOps project.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] fields_v1: Raw fields associated with the GitOps project.
        :param pulumi.Input[builtins.str] manager: Manager responsible for the operation.
        :param pulumi.Input[builtins.str] operation: Operation type performed on the GitOps project.
        :param pulumi.Input[builtins.str] subresource: Subresource associated with the GitOps project.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] time: Timestamp of the operation.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if fields_type is not None:
            pulumi.set(__self__, "fields_type", fields_type)
        if fields_v1 is not None:
            pulumi.set(__self__, "fields_v1", fields_v1)
        if manager is not None:
            pulumi.set(__self__, "manager", manager)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if subresource is not None:
            pulumi.set(__self__, "subresource", subresource)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        API version of the operation performed.
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api_version", value)

    @property
    @pulumi.getter(name="fieldsType")
    def fields_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of the fields in the GitOps project.
        """
        return pulumi.get(self, "fields_type")

    @fields_type.setter
    def fields_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fields_type", value)

    @property
    @pulumi.getter(name="fieldsV1")
    def fields_v1(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Raw fields associated with the GitOps project.
        """
        return pulumi.get(self, "fields_v1")

    @fields_v1.setter
    def fields_v1(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "fields_v1", value)

    @property
    @pulumi.getter
    def manager(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Manager responsible for the operation.
        """
        return pulumi.get(self, "manager")

    @manager.setter
    def manager(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "manager", value)

    @property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Operation type performed on the GitOps project.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "operation", value)

    @property
    @pulumi.getter
    def subresource(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Subresource associated with the GitOps project.
        """
        return pulumi.get(self, "subresource")

    @subresource.setter
    def subresource(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subresource", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Timestamp of the operation.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "time", value)


if not MYPY:
    class GitopsAppProjectProjectSpecArgsDict(TypedDict):
        cluster_resource_blacklists: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceBlacklistArgsDict']]]]
        """
        Cluster resource blacklist for the GitOps project.
        """
        cluster_resource_whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceWhitelistArgsDict']]]]
        """
        Cluster resource whitelist for the Argo project.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the Argo project.
        """
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecDestinationArgsDict']]]]
        """
        Allowed destinations for applications in this Argo project.
        """
        namespace_resource_blacklists: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgsDict']]]]
        """
        Namespace resource blacklist for the Argo project.
        """
        namespace_resource_whitelists: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgsDict']]]]
        """
        Namespace resource whitelist for the GitOps project.
        """
        orphaned_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceArgsDict']]]]
        """
        OrphanedResources specifies if agent should monitor orphaned resources of apps in this project
        """
        permit_only_project_scoped_clusters: NotRequired[pulumi.Input[builtins.bool]]
        """
        This option determines whether destinations can only reference clusters which are argo project-scoped
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleArgsDict']]]]
        """
        Roles associated with the Argo project.
        """
        signature_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSignatureKeyArgsDict']]]]
        """
        Signature keys for the GitOps project.
        """
        source_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Source namespaces defines the namespaces application resources are allowed to be created in.
        """
        source_repos: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Allowed Source repositories for the Argo project.
        """
        sync_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSyncWindowArgsDict']]]]
        """
        Synchronization windows for the GitOps project.
        """
elif False:
    GitopsAppProjectProjectSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecArgs:
    def __init__(__self__, *,
                 cluster_resource_blacklists: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceBlacklistArgs']]]] = None,
                 cluster_resource_whitelists: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceWhitelistArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecDestinationArgs']]]] = None,
                 namespace_resource_blacklists: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs']]]] = None,
                 namespace_resource_whitelists: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs']]]] = None,
                 orphaned_resources: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceArgs']]]] = None,
                 permit_only_project_scoped_clusters: Optional[pulumi.Input[builtins.bool]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleArgs']]]] = None,
                 signature_keys: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSignatureKeyArgs']]]] = None,
                 source_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 source_repos: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 sync_windows: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSyncWindowArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceBlacklistArgs']]] cluster_resource_blacklists: Cluster resource blacklist for the GitOps project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceWhitelistArgs']]] cluster_resource_whitelists: Cluster resource whitelist for the Argo project.
        :param pulumi.Input[builtins.str] description: Description of the Argo project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecDestinationArgs']]] destinations: Allowed destinations for applications in this Argo project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs']]] namespace_resource_blacklists: Namespace resource blacklist for the Argo project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs']]] namespace_resource_whitelists: Namespace resource whitelist for the GitOps project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceArgs']]] orphaned_resources: OrphanedResources specifies if agent should monitor orphaned resources of apps in this project
        :param pulumi.Input[builtins.bool] permit_only_project_scoped_clusters: This option determines whether destinations can only reference clusters which are argo project-scoped
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleArgs']]] roles: Roles associated with the Argo project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSignatureKeyArgs']]] signature_keys: Signature keys for the GitOps project.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_namespaces: Source namespaces defines the namespaces application resources are allowed to be created in.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] source_repos: Allowed Source repositories for the Argo project.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSyncWindowArgs']]] sync_windows: Synchronization windows for the GitOps project.
        """
        if cluster_resource_blacklists is not None:
            pulumi.set(__self__, "cluster_resource_blacklists", cluster_resource_blacklists)
        if cluster_resource_whitelists is not None:
            pulumi.set(__self__, "cluster_resource_whitelists", cluster_resource_whitelists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if namespace_resource_blacklists is not None:
            pulumi.set(__self__, "namespace_resource_blacklists", namespace_resource_blacklists)
        if namespace_resource_whitelists is not None:
            pulumi.set(__self__, "namespace_resource_whitelists", namespace_resource_whitelists)
        if orphaned_resources is not None:
            pulumi.set(__self__, "orphaned_resources", orphaned_resources)
        if permit_only_project_scoped_clusters is not None:
            pulumi.set(__self__, "permit_only_project_scoped_clusters", permit_only_project_scoped_clusters)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if signature_keys is not None:
            pulumi.set(__self__, "signature_keys", signature_keys)
        if source_namespaces is not None:
            pulumi.set(__self__, "source_namespaces", source_namespaces)
        if source_repos is not None:
            pulumi.set(__self__, "source_repos", source_repos)
        if sync_windows is not None:
            pulumi.set(__self__, "sync_windows", sync_windows)

    @property
    @pulumi.getter(name="clusterResourceBlacklists")
    def cluster_resource_blacklists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceBlacklistArgs']]]]:
        """
        Cluster resource blacklist for the GitOps project.
        """
        return pulumi.get(self, "cluster_resource_blacklists")

    @cluster_resource_blacklists.setter
    def cluster_resource_blacklists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceBlacklistArgs']]]]):
        pulumi.set(self, "cluster_resource_blacklists", value)

    @property
    @pulumi.getter(name="clusterResourceWhitelists")
    def cluster_resource_whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceWhitelistArgs']]]]:
        """
        Cluster resource whitelist for the Argo project.
        """
        return pulumi.get(self, "cluster_resource_whitelists")

    @cluster_resource_whitelists.setter
    def cluster_resource_whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecClusterResourceWhitelistArgs']]]]):
        pulumi.set(self, "cluster_resource_whitelists", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the Argo project.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecDestinationArgs']]]]:
        """
        Allowed destinations for applications in this Argo project.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @property
    @pulumi.getter(name="namespaceResourceBlacklists")
    def namespace_resource_blacklists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs']]]]:
        """
        Namespace resource blacklist for the Argo project.
        """
        return pulumi.get(self, "namespace_resource_blacklists")

    @namespace_resource_blacklists.setter
    def namespace_resource_blacklists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs']]]]):
        pulumi.set(self, "namespace_resource_blacklists", value)

    @property
    @pulumi.getter(name="namespaceResourceWhitelists")
    def namespace_resource_whitelists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs']]]]:
        """
        Namespace resource whitelist for the GitOps project.
        """
        return pulumi.get(self, "namespace_resource_whitelists")

    @namespace_resource_whitelists.setter
    def namespace_resource_whitelists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs']]]]):
        pulumi.set(self, "namespace_resource_whitelists", value)

    @property
    @pulumi.getter(name="orphanedResources")
    def orphaned_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceArgs']]]]:
        """
        OrphanedResources specifies if agent should monitor orphaned resources of apps in this project
        """
        return pulumi.get(self, "orphaned_resources")

    @orphaned_resources.setter
    def orphaned_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceArgs']]]]):
        pulumi.set(self, "orphaned_resources", value)

    @property
    @pulumi.getter(name="permitOnlyProjectScopedClusters")
    def permit_only_project_scoped_clusters(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        This option determines whether destinations can only reference clusters which are argo project-scoped
        """
        return pulumi.get(self, "permit_only_project_scoped_clusters")

    @permit_only_project_scoped_clusters.setter
    def permit_only_project_scoped_clusters(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "permit_only_project_scoped_clusters", value)

    @property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleArgs']]]]:
        """
        Roles associated with the Argo project.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleArgs']]]]):
        pulumi.set(self, "roles", value)

    @property
    @pulumi.getter(name="signatureKeys")
    def signature_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSignatureKeyArgs']]]]:
        """
        Signature keys for the GitOps project.
        """
        return pulumi.get(self, "signature_keys")

    @signature_keys.setter
    def signature_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSignatureKeyArgs']]]]):
        pulumi.set(self, "signature_keys", value)

    @property
    @pulumi.getter(name="sourceNamespaces")
    def source_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Source namespaces defines the namespaces application resources are allowed to be created in.
        """
        return pulumi.get(self, "source_namespaces")

    @source_namespaces.setter
    def source_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "source_namespaces", value)

    @property
    @pulumi.getter(name="sourceRepos")
    def source_repos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Allowed Source repositories for the Argo project.
        """
        return pulumi.get(self, "source_repos")

    @source_repos.setter
    def source_repos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "source_repos", value)

    @property
    @pulumi.getter(name="syncWindows")
    def sync_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSyncWindowArgs']]]]:
        """
        Synchronization windows for the GitOps project.
        """
        return pulumi.get(self, "sync_windows")

    @sync_windows.setter
    def sync_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecSyncWindowArgs']]]]):
        pulumi.set(self, "sync_windows", value)


if not MYPY:
    class GitopsAppProjectProjectSpecClusterResourceBlacklistArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        """
        Group of the cluster resource blacklist.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of the cluster resource blacklist.
        """
elif False:
    GitopsAppProjectProjectSpecClusterResourceBlacklistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecClusterResourceBlacklistArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group: Group of the cluster resource blacklist.
        :param pulumi.Input[builtins.str] kind: Kind of the cluster resource blacklist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Group of the cluster resource blacklist.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of the cluster resource blacklist.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GitopsAppProjectProjectSpecClusterResourceWhitelistArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        """
        Group of the cluster resource whitelist.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of the cluster resource whitelist.
        """
elif False:
    GitopsAppProjectProjectSpecClusterResourceWhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecClusterResourceWhitelistArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group: Group of the cluster resource whitelist.
        :param pulumi.Input[builtins.str] kind: Kind of the cluster resource whitelist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Group of the cluster resource whitelist.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of the cluster resource whitelist.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GitopsAppProjectProjectSpecDestinationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the destination cluster.
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        Permitted Namespaces for deployment in the destination cluster.
        """
        server: NotRequired[pulumi.Input[builtins.str]]
        """
        Server URL of the destination cluster.
        """
elif False:
    GitopsAppProjectProjectSpecDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecDestinationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 server: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name of the destination cluster.
        :param pulumi.Input[builtins.str] namespace: Permitted Namespaces for deployment in the destination cluster.
        :param pulumi.Input[builtins.str] server: Server URL of the destination cluster.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the destination cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Permitted Namespaces for deployment in the destination cluster.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def server(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Server URL of the destination cluster.
        """
        return pulumi.get(self, "server")

    @server.setter
    def server(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server", value)


if not MYPY:
    class GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        """
        Group of the namespace resource blacklist.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of the namespace resource blacklist.
        """
elif False:
    GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group: Group of the namespace resource blacklist.
        :param pulumi.Input[builtins.str] kind: Kind of the namespace resource blacklist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Group of the namespace resource blacklist.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of the namespace resource blacklist.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        """
        Group of the namespace resource whitelist.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of the namespace resource whitelist.
        """
elif False:
    GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group: Group of the namespace resource whitelist.
        :param pulumi.Input[builtins.str] kind: Kind of the namespace resource whitelist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Group of the namespace resource whitelist.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of the namespace resource whitelist.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)


if not MYPY:
    class GitopsAppProjectProjectSpecOrphanedResourceArgsDict(TypedDict):
        ignores: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgsDict']]]]
        """
        List of ignored orphaned resources.
        """
        warn: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether to warn about orphaned resources.
        """
elif False:
    GitopsAppProjectProjectSpecOrphanedResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecOrphanedResourceArgs:
    def __init__(__self__, *,
                 ignores: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs']]]] = None,
                 warn: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs']]] ignores: List of ignored orphaned resources.
        :param pulumi.Input[builtins.bool] warn: Whether to warn about orphaned resources.
        """
        if ignores is not None:
            pulumi.set(__self__, "ignores", ignores)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)

    @property
    @pulumi.getter
    def ignores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs']]]]:
        """
        List of ignored orphaned resources.
        """
        return pulumi.get(self, "ignores")

    @ignores.setter
    def ignores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs']]]]):
        pulumi.set(self, "ignores", value)

    @property
    @pulumi.getter
    def warn(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether to warn about orphaned resources.
        """
        return pulumi.get(self, "warn")

    @warn.setter
    def warn(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "warn", value)


if not MYPY:
    class GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgsDict(TypedDict):
        group: NotRequired[pulumi.Input[builtins.str]]
        """
        Group of the ignored orphaned resource.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of the ignored orphaned resource.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the ignored orphaned resource.
        """
elif False:
    GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs:
    def __init__(__self__, *,
                 group: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group: Group of the ignored orphaned resource.
        :param pulumi.Input[builtins.str] kind: Kind of the ignored orphaned resource.
        :param pulumi.Input[builtins.str] name: Name of the ignored orphaned resource.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Group of the ignored orphaned resource.
        """
        return pulumi.get(self, "group")

    @group.setter
    def group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of the ignored orphaned resource.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the ignored orphaned resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GitopsAppProjectProjectSpecRoleArgsDict(TypedDict):
        description: pulumi.Input[builtins.str]
        """
        Description of the role.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the role.
        """
        groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Groups associated with the role.
        """
        jwt_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleJwtTokenArgsDict']]]]
        """
        JWT tokens associated with the role.
        """
        policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Policies associated with the role. These are argo RBAC policies and may not necessarily reflect in harness.
        """
elif False:
    GitopsAppProjectProjectSpecRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecRoleArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 groups: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 jwt_tokens: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleJwtTokenArgs']]]] = None,
                 policies: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] description: Description of the role.
        :param pulumi.Input[builtins.str] name: Name of the role.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] groups: Groups associated with the role.
        :param pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleJwtTokenArgs']]] jwt_tokens: JWT tokens associated with the role.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] policies: Policies associated with the role. These are argo RBAC policies and may not necessarily reflect in harness.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if jwt_tokens is not None:
            pulumi.set(__self__, "jwt_tokens", jwt_tokens)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[builtins.str]:
        """
        Description of the role.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the role.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Groups associated with the role.
        """
        return pulumi.get(self, "groups")

    @groups.setter
    def groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "groups", value)

    @property
    @pulumi.getter(name="jwtTokens")
    def jwt_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleJwtTokenArgs']]]]:
        """
        JWT tokens associated with the role.
        """
        return pulumi.get(self, "jwt_tokens")

    @jwt_tokens.setter
    def jwt_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GitopsAppProjectProjectSpecRoleJwtTokenArgs']]]]):
        pulumi.set(self, "jwt_tokens", value)

    @property
    @pulumi.getter
    def policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Policies associated with the role. These are argo RBAC policies and may not necessarily reflect in harness.
        """
        return pulumi.get(self, "policies")

    @policies.setter
    def policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "policies", value)


if not MYPY:
    class GitopsAppProjectProjectSpecRoleJwtTokenArgsDict(TypedDict):
        exp: NotRequired[pulumi.Input[builtins.str]]
        """
        Expiration time of the JWT token.
        """
        iat: NotRequired[pulumi.Input[builtins.str]]
        """
        Issued At time of the JWT token.
        """
        id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the JWT token.
        """
elif False:
    GitopsAppProjectProjectSpecRoleJwtTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecRoleJwtTokenArgs:
    def __init__(__self__, *,
                 exp: Optional[pulumi.Input[builtins.str]] = None,
                 iat: Optional[pulumi.Input[builtins.str]] = None,
                 id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] exp: Expiration time of the JWT token.
        :param pulumi.Input[builtins.str] iat: Issued At time of the JWT token.
        :param pulumi.Input[builtins.str] id: ID of the JWT token.
        """
        if exp is not None:
            pulumi.set(__self__, "exp", exp)
        if iat is not None:
            pulumi.set(__self__, "iat", iat)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def exp(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Expiration time of the JWT token.
        """
        return pulumi.get(self, "exp")

    @exp.setter
    def exp(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "exp", value)

    @property
    @pulumi.getter
    def iat(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Issued At time of the JWT token.
        """
        return pulumi.get(self, "iat")

    @iat.setter
    def iat(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "iat", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the JWT token.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GitopsAppProjectProjectSpecSignatureKeyArgsDict(TypedDict):
        key_id: NotRequired[pulumi.Input[builtins.str]]
        """
        ID of the signature key.
        """
elif False:
    GitopsAppProjectProjectSpecSignatureKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecSignatureKeyArgs:
    def __init__(__self__, *,
                 key_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key_id: ID of the signature key.
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        ID of the signature key.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class GitopsAppProjectProjectSpecSyncWindowArgsDict(TypedDict):
        applications: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Applications associated with synchronization window.
        """
        clusters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Clusters associated with synchronization window.
        """
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Duration of synchronization window.
        """
        kind: NotRequired[pulumi.Input[builtins.str]]
        """
        Kind of synchronization window.
        """
        manual_sync: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether manual synchronization is enabled.
        """
        namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Namespaces associated with synchronization window.
        """
        schedule: NotRequired[pulumi.Input[builtins.str]]
        """
        Schedule of synchronization window.
        """
        time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Time zone of synchronization window.
        """
elif False:
    GitopsAppProjectProjectSpecSyncWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitopsAppProjectProjectSpecSyncWindowArgs:
    def __init__(__self__, *,
                 applications: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 clusters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 duration: Optional[pulumi.Input[builtins.str]] = None,
                 kind: Optional[pulumi.Input[builtins.str]] = None,
                 manual_sync: Optional[pulumi.Input[builtins.bool]] = None,
                 namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 schedule: Optional[pulumi.Input[builtins.str]] = None,
                 time_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] applications: Applications associated with synchronization window.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] clusters: Clusters associated with synchronization window.
        :param pulumi.Input[builtins.str] duration: Duration of synchronization window.
        :param pulumi.Input[builtins.str] kind: Kind of synchronization window.
        :param pulumi.Input[builtins.bool] manual_sync: Whether manual synchronization is enabled.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] namespaces: Namespaces associated with synchronization window.
        :param pulumi.Input[builtins.str] schedule: Schedule of synchronization window.
        :param pulumi.Input[builtins.str] time_zone: Time zone of synchronization window.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if manual_sync is not None:
            pulumi.set(__self__, "manual_sync", manual_sync)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def applications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Applications associated with synchronization window.
        """
        return pulumi.get(self, "applications")

    @applications.setter
    def applications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "applications", value)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Clusters associated with synchronization window.
        """
        return pulumi.get(self, "clusters")

    @clusters.setter
    def clusters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "clusters", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Duration of synchronization window.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Kind of synchronization window.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="manualSync")
    def manual_sync(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether manual synchronization is enabled.
        """
        return pulumi.get(self, "manual_sync")

    @manual_sync.setter
    def manual_sync(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "manual_sync", value)

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Namespaces associated with synchronization window.
        """
        return pulumi.get(self, "namespaces")

    @namespaces.setter
    def namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "namespaces", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Schedule of synchronization window.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schedule", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Time zone of synchronization window.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class HarRegistryConfigArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type of registry (VIRTUAL or UPSTREAM)
        """
        auth_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of authentication for UPSTREAM registry type (UserPassword, Anonymous)
        """
        auths: NotRequired[pulumi.Input[Sequence[pulumi.Input['HarRegistryConfigAuthArgsDict']]]]
        """
        Authentication configuration for UPSTREAM registry type
        """
        source: NotRequired[pulumi.Input[builtins.str]]
        """
        Source of the upstream (only for UPSTREAM type)
        """
        upstream_proxies: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of upstream proxies for VIRTUAL registry type
        """
        url: NotRequired[pulumi.Input[builtins.str]]
        """
        URL of the upstream (required if type=UPSTREAM & package_type=HELM)
        """
elif False:
    HarRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HarRegistryConfigArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 auth_type: Optional[pulumi.Input[builtins.str]] = None,
                 auths: Optional[pulumi.Input[Sequence[pulumi.Input['HarRegistryConfigAuthArgs']]]] = None,
                 source: Optional[pulumi.Input[builtins.str]] = None,
                 upstream_proxies: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: Type of registry (VIRTUAL or UPSTREAM)
        :param pulumi.Input[builtins.str] auth_type: Type of authentication for UPSTREAM registry type (UserPassword, Anonymous)
        :param pulumi.Input[Sequence[pulumi.Input['HarRegistryConfigAuthArgs']]] auths: Authentication configuration for UPSTREAM registry type
        :param pulumi.Input[builtins.str] source: Source of the upstream (only for UPSTREAM type)
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] upstream_proxies: List of upstream proxies for VIRTUAL registry type
        :param pulumi.Input[builtins.str] url: URL of the upstream (required if type=UPSTREAM & package_type=HELM)
        """
        pulumi.set(__self__, "type", type)
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if upstream_proxies is not None:
            pulumi.set(__self__, "upstream_proxies", upstream_proxies)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of registry (VIRTUAL or UPSTREAM)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of authentication for UPSTREAM registry type (UserPassword, Anonymous)
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def auths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HarRegistryConfigAuthArgs']]]]:
        """
        Authentication configuration for UPSTREAM registry type
        """
        return pulumi.get(self, "auths")

    @auths.setter
    def auths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HarRegistryConfigAuthArgs']]]]):
        pulumi.set(self, "auths", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Source of the upstream (only for UPSTREAM type)
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="upstreamProxies")
    def upstream_proxies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of upstream proxies for VIRTUAL registry type
        """
        return pulumi.get(self, "upstream_proxies")

    @upstream_proxies.setter
    def upstream_proxies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "upstream_proxies", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        URL of the upstream (required if type=UPSTREAM & package_type=HELM)
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class HarRegistryConfigAuthArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        Type of authentication (UserPassword, Anonymous)
        """
        secret_identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret identifier for UserPassword auth type
        """
        secret_space_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret space path for UserPassword auth type
        """
        user_name: NotRequired[pulumi.Input[builtins.str]]
        """
        User name for UserPassword auth type
        """
elif False:
    HarRegistryConfigAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HarRegistryConfigAuthArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 secret_identifier: Optional[pulumi.Input[builtins.str]] = None,
                 secret_space_path: Optional[pulumi.Input[builtins.str]] = None,
                 user_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: Type of authentication (UserPassword, Anonymous)
        :param pulumi.Input[builtins.str] secret_identifier: Secret identifier for UserPassword auth type
        :param pulumi.Input[builtins.str] secret_space_path: Secret space path for UserPassword auth type
        :param pulumi.Input[builtins.str] user_name: User name for UserPassword auth type
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if secret_identifier is not None:
            pulumi.set(__self__, "secret_identifier", secret_identifier)
        if secret_space_path is not None:
            pulumi.set(__self__, "secret_space_path", secret_space_path)
        if user_name is not None:
            pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of authentication (UserPassword, Anonymous)
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret identifier for UserPassword auth type
        """
        return pulumi.get(self, "secret_identifier")

    @secret_identifier.setter
    def secret_identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_identifier", value)

    @property
    @pulumi.getter(name="secretSpacePath")
    def secret_space_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret space path for UserPassword auth type
        """
        return pulumi.get(self, "secret_space_path")

    @secret_space_path.setter
    def secret_space_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_space_path", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User name for UserPassword auth type
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class HelmConnectorCredentialsArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    HelmConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HelmConnectorCredentialsArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class InfraVariableSetConnectorArgsDict(TypedDict):
        connector_ref: pulumi.Input[builtins.str]
        """
        Unique identifier of the connector.
        """
        type: pulumi.Input[builtins.str]
        """
        Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
elif False:
    InfraVariableSetConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfraVariableSetConnectorArgs:
    def __init__(__self__, *,
                 connector_ref: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] connector_ref: Unique identifier of the connector.
        :param pulumi.Input[builtins.str] type: Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> pulumi.Input[builtins.str]:
        """
        Unique identifier of the connector.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class InfraVariableSetEnvironmentVariableArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key is the identifier for the variable. Must be unique within the variable set.
        """
        value: pulumi.Input[builtins.str]
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        value_type: pulumi.Input[builtins.str]
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
elif False:
    InfraVariableSetEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfraVariableSetEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: Key is the identifier for the variable. Must be unique within the variable set.
        :param pulumi.Input[builtins.str] value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param pulumi.Input[builtins.str] value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key is the identifier for the variable. Must be unique within the variable set.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class InfraVariableSetTerraformVariableArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key is the identifier for the variable. Must be unique within the variable set.
        """
        value: pulumi.Input[builtins.str]
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        value_type: pulumi.Input[builtins.str]
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
elif False:
    InfraVariableSetTerraformVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfraVariableSetTerraformVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: Key is the identifier for the variable. Must be unique within the variable set.
        :param pulumi.Input[builtins.str] value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param pulumi.Input[builtins.str] value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key is the identifier for the variable. Must be unique within the variable set.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class InfraVariableSetTerraformVariableFileArgsDict(TypedDict):
        repository: pulumi.Input[builtins.str]
        """
        Repository is the name of the repository to fetch the code from.
        """
        repository_connector: pulumi.Input[builtins.str]
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        repository_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        repository_commit: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        repository_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository path is the path in which the variables reside.
        """
        repository_sha: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
elif False:
    InfraVariableSetTerraformVariableFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfraVariableSetTerraformVariableFileArgs:
    def __init__(__self__, *,
                 repository: pulumi.Input[builtins.str],
                 repository_connector: pulumi.Input[builtins.str],
                 repository_branch: Optional[pulumi.Input[builtins.str]] = None,
                 repository_commit: Optional[pulumi.Input[builtins.str]] = None,
                 repository_path: Optional[pulumi.Input[builtins.str]] = None,
                 repository_sha: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] repository: Repository is the name of the repository to fetch the code from.
        :param pulumi.Input[builtins.str] repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param pulumi.Input[builtins.str] repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param pulumi.Input[builtins.str] repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param pulumi.Input[builtins.str] repository_path: Repository path is the path in which the variables reside.
        :param pulumi.Input[builtins.str] repository_sha: Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_branch is not None:
            pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit is not None:
            pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_path is not None:
            pulumi.set(__self__, "repository_path", repository_path)
        if repository_sha is not None:
            pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[builtins.str]:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> pulumi.Input[builtins.str]:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @repository_connector.setter
    def repository_connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repository_connector", value)

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @repository_branch.setter
    def repository_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_branch", value)

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @repository_commit.setter
    def repository_commit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_commit", value)

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @repository_path.setter
    def repository_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_path", value)

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")

    @repository_sha.setter
    def repository_sha(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_sha", value)


if not MYPY:
    class InfrastructureGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        message for the commit in Git Repo.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        import_from_git: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to set if importing from Git
        """
        is_force_import: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to set if force importing from Git
        """
        is_harnesscode_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the gitProvider is HarnessCode
        """
        is_new_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        If a new branch creation is requested.
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Infrastructures.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating Infrastructures.
        """
        load_from_cache: NotRequired[pulumi.Input[builtins.str]]
        """
        If the Entity is to be fetched from cache
        """
        load_from_fallback_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        Whether the file has to be get from fallback_branch.
        """
        parent_entity_connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        parent_entity_repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository where parent entity lies.
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        store type of the entity.
        """
elif False:
    InfrastructureGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 import_from_git: Optional[pulumi.Input[builtins.bool]] = None,
                 is_force_import: Optional[pulumi.Input[builtins.bool]] = None,
                 is_harnesscode_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 is_new_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_cache: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_fallback_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 parent_entity_connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 parent_entity_repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: message for the commit in Git Repo.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] import_from_git: Flag to set if importing from Git
        :param pulumi.Input[builtins.bool] is_force_import: Flag to set if force importing from Git
        :param pulumi.Input[builtins.bool] is_harnesscode_repo: If the gitProvider is HarnessCode
        :param pulumi.Input[builtins.bool] is_new_branch: If a new branch creation is requested.
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Infrastructures.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating Infrastructures.
        :param pulumi.Input[builtins.str] load_from_cache: If the Entity is to be fetched from cache
        :param pulumi.Input[builtins.bool] load_from_fallback_branch: Whether the file has to be get from fallback_branch.
        :param pulumi.Input[builtins.str] parent_entity_connector_ref: Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] parent_entity_repo_name: Name of the repository where parent entity lies.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: store type of the entity.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if import_from_git is not None:
            pulumi.set(__self__, "import_from_git", import_from_git)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if is_harnesscode_repo is not None:
            pulumi.set(__self__, "is_harnesscode_repo", is_harnesscode_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if parent_entity_connector_ref is not None:
            pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        if parent_entity_repo_name is not None:
            pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        message for the commit in Git Repo.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="importFromGit")
    def import_from_git(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to set if importing from Git
        """
        return pulumi.get(self, "import_from_git")

    @import_from_git.setter
    def import_from_git(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "import_from_git", value)

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to set if force importing from Git
        """
        return pulumi.get(self, "is_force_import")

    @is_force_import.setter
    def is_force_import(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_force_import", value)

    @property
    @pulumi.getter(name="isHarnesscodeRepo")
    def is_harnesscode_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the gitProvider is HarnessCode
        """
        return pulumi.get(self, "is_harnesscode_repo")

    @is_harnesscode_repo.setter
    def is_harnesscode_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harnesscode_repo", value)

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If a new branch creation is requested.
        """
        return pulumi.get(self, "is_new_branch")

    @is_new_branch.setter
    def is_new_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_new_branch", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Infrastructures.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating Infrastructures.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        If the Entity is to be fetched from cache
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Whether the file has to be get from fallback_branch.
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @parent_entity_connector_ref.setter
    def parent_entity_connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parent_entity_connector_ref", value)

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository where parent entity lies.
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @parent_entity_repo_name.setter
    def parent_entity_repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parent_entity_repo_name", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        store type of the entity.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class InputSetGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message used for the merge commit.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_harness_code_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the repo is harness code.
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        parent_entity_connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        parent_entity_repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository name for Parent Entity (Pipeline).
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    InputSetGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InputSetGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch_name: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_harness_code_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 parent_entity_connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 parent_entity_repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch_name: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: Commit message used for the merge commit.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] is_harness_code_repo: If the repo is harness code.
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] parent_entity_connector_ref: Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] parent_entity_repo_name: Repository name for Parent Entity (Pipeline).
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if parent_entity_connector_ref is not None:
            pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        if parent_entity_repo_name is not None:
            pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the repo is harness code.
        """
        return pulumi.get(self, "is_harness_code_repo")

    @is_harness_code_repo.setter
    def is_harness_code_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harness_code_repo", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @parent_entity_connector_ref.setter
    def parent_entity_connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parent_entity_connector_ref", value)

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository name for Parent Entity (Pipeline).
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @parent_entity_repo_name.setter
    def parent_entity_repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "parent_entity_repo_name", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class InputSetGitImportInfoArgsDict(TypedDict):
        branch_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_force_import: NotRequired[pulumi.Input[builtins.bool]]
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
elif False:
    InputSetGitImportInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InputSetGitImportInfoArgs:
    def __init__(__self__, *,
                 branch_name: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_force_import: Optional[pulumi.Input[builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] branch_name: Name of the branch.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_force_import")

    @is_force_import.setter
    def is_force_import(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_force_import", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class InputSetInputSetImportRequestArgsDict(TypedDict):
        input_set_description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the input set.
        """
        input_set_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the input set.
        """
elif False:
    InputSetInputSetImportRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InputSetInputSetImportRequestArgs:
    def __init__(__self__, *,
                 input_set_description: Optional[pulumi.Input[builtins.str]] = None,
                 input_set_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] input_set_description: Description of the input set.
        :param pulumi.Input[builtins.str] input_set_name: Name of the input set.
        """
        if input_set_description is not None:
            pulumi.set(__self__, "input_set_description", input_set_description)
        if input_set_name is not None:
            pulumi.set(__self__, "input_set_name", input_set_name)

    @property
    @pulumi.getter(name="inputSetDescription")
    def input_set_description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the input set.
        """
        return pulumi.get(self, "input_set_description")

    @input_set_description.setter
    def input_set_description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "input_set_description", value)

    @property
    @pulumi.getter(name="inputSetName")
    def input_set_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the input set.
        """
        return pulumi.get(self, "input_set_name")

    @input_set_name.setter
    def input_set_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "input_set_name", value)


if not MYPY:
    class JenkinsConnectorAuthArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
        """
        jenkins_bearer_token: NotRequired[pulumi.Input['JenkinsConnectorAuthJenkinsBearerTokenArgsDict']]
        """
        Authenticate to App Dynamics using bearer token.
        """
        jenkins_user_name_password: NotRequired[pulumi.Input['JenkinsConnectorAuthJenkinsUserNamePasswordArgsDict']]
        """
        Authenticate to App Dynamics using user name and password.
        """
elif False:
    JenkinsConnectorAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JenkinsConnectorAuthArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 jenkins_bearer_token: Optional[pulumi.Input['JenkinsConnectorAuthJenkinsBearerTokenArgs']] = None,
                 jenkins_user_name_password: Optional[pulumi.Input['JenkinsConnectorAuthJenkinsUserNamePasswordArgs']] = None):
        """
        :param pulumi.Input[builtins.str] type: Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
        :param pulumi.Input['JenkinsConnectorAuthJenkinsBearerTokenArgs'] jenkins_bearer_token: Authenticate to App Dynamics using bearer token.
        :param pulumi.Input['JenkinsConnectorAuthJenkinsUserNamePasswordArgs'] jenkins_user_name_password: Authenticate to App Dynamics using user name and password.
        """
        pulumi.set(__self__, "type", type)
        if jenkins_bearer_token is not None:
            pulumi.set(__self__, "jenkins_bearer_token", jenkins_bearer_token)
        if jenkins_user_name_password is not None:
            pulumi.set(__self__, "jenkins_user_name_password", jenkins_user_name_password)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="jenkinsBearerToken")
    def jenkins_bearer_token(self) -> Optional[pulumi.Input['JenkinsConnectorAuthJenkinsBearerTokenArgs']]:
        """
        Authenticate to App Dynamics using bearer token.
        """
        return pulumi.get(self, "jenkins_bearer_token")

    @jenkins_bearer_token.setter
    def jenkins_bearer_token(self, value: Optional[pulumi.Input['JenkinsConnectorAuthJenkinsBearerTokenArgs']]):
        pulumi.set(self, "jenkins_bearer_token", value)

    @property
    @pulumi.getter(name="jenkinsUserNamePassword")
    def jenkins_user_name_password(self) -> Optional[pulumi.Input['JenkinsConnectorAuthJenkinsUserNamePasswordArgs']]:
        """
        Authenticate to App Dynamics using user name and password.
        """
        return pulumi.get(self, "jenkins_user_name_password")

    @jenkins_user_name_password.setter
    def jenkins_user_name_password(self, value: Optional[pulumi.Input['JenkinsConnectorAuthJenkinsUserNamePasswordArgs']]):
        pulumi.set(self, "jenkins_user_name_password", value)


if not MYPY:
    class JenkinsConnectorAuthJenkinsBearerTokenArgsDict(TypedDict):
        token_ref: pulumi.Input[builtins.str]
        """
        Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    JenkinsConnectorAuthJenkinsBearerTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JenkinsConnectorAuthJenkinsBearerTokenArgs:
    def __init__(__self__, *,
                 token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] token_ref: Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @token_ref.setter
    def token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_ref", value)


if not MYPY:
    class JenkinsConnectorAuthJenkinsUserNamePasswordArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.To reference a secret at the project scope, use directly without any prefix.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Username reference to use for authentication.
        """
elif False:
    JenkinsConnectorAuthJenkinsUserNamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JenkinsConnectorAuthJenkinsUserNamePasswordArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.To reference a secret at the project scope, use directly without any prefix.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Username reference to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.To reference a secret at the project scope, use directly without any prefix.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username reference to use for authentication.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class JiraConnectorAuthArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        Authentication types for Jira connector
        """
        personal_access_token: NotRequired[pulumi.Input['JiraConnectorAuthPersonalAccessTokenArgsDict']]
        """
        Authenticate using personal access token.
        """
        username_password: NotRequired[pulumi.Input['JiraConnectorAuthUsernamePasswordArgsDict']]
        """
        Authenticate using username password.
        """
elif False:
    JiraConnectorAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraConnectorAuthArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 personal_access_token: Optional[pulumi.Input['JiraConnectorAuthPersonalAccessTokenArgs']] = None,
                 username_password: Optional[pulumi.Input['JiraConnectorAuthUsernamePasswordArgs']] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: Authentication types for Jira connector
        :param pulumi.Input['JiraConnectorAuthPersonalAccessTokenArgs'] personal_access_token: Authenticate using personal access token.
        :param pulumi.Input['JiraConnectorAuthUsernamePasswordArgs'] username_password: Authenticate using username password.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        Authentication types for Jira connector
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional[pulumi.Input['JiraConnectorAuthPersonalAccessTokenArgs']]:
        """
        Authenticate using personal access token.
        """
        return pulumi.get(self, "personal_access_token")

    @personal_access_token.setter
    def personal_access_token(self, value: Optional[pulumi.Input['JiraConnectorAuthPersonalAccessTokenArgs']]):
        pulumi.set(self, "personal_access_token", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['JiraConnectorAuthUsernamePasswordArgs']]:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['JiraConnectorAuthUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)


if not MYPY:
    class JiraConnectorAuthPersonalAccessTokenArgsDict(TypedDict):
        pat_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    JiraConnectorAuthPersonalAccessTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraConnectorAuthPersonalAccessTokenArgs:
    def __init__(__self__, *,
                 pat_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] pat_ref: Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "pat_ref", pat_ref)

    @property
    @pulumi.getter(name="patRef")
    def pat_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "pat_ref")

    @pat_ref.setter
    def pat_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "pat_ref", value)


if not MYPY:
    class JiraConnectorAuthUsernamePasswordArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    JiraConnectorAuthUsernamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraConnectorAuthUsernamePasswordArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class KubernetesConnectorClientKeyCertArgsDict(TypedDict):
        client_cert_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        client_key_algorithm: pulumi.Input[builtins.str]
        """
        The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        """
        client_key_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        master_url: pulumi.Input[builtins.str]
        """
        The URL of the Kubernetes cluster.
        """
        ca_cert_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        client_key_passphrase_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    KubernetesConnectorClientKeyCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesConnectorClientKeyCertArgs:
    def __init__(__self__, *,
                 client_cert_ref: pulumi.Input[builtins.str],
                 client_key_algorithm: pulumi.Input[builtins.str],
                 client_key_ref: pulumi.Input[builtins.str],
                 master_url: pulumi.Input[builtins.str],
                 ca_cert_ref: Optional[pulumi.Input[builtins.str]] = None,
                 client_key_passphrase_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_cert_ref: Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] client_key_algorithm: The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        :param pulumi.Input[builtins.str] client_key_ref: Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] master_url: The URL of the Kubernetes cluster.
        :param pulumi.Input[builtins.str] ca_cert_ref: Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] client_key_passphrase_ref: Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_cert_ref", client_cert_ref)
        pulumi.set(__self__, "client_key_algorithm", client_key_algorithm)
        pulumi.set(__self__, "client_key_ref", client_key_ref)
        pulumi.set(__self__, "master_url", master_url)
        if ca_cert_ref is not None:
            pulumi.set(__self__, "ca_cert_ref", ca_cert_ref)
        if client_key_passphrase_ref is not None:
            pulumi.set(__self__, "client_key_passphrase_ref", client_key_passphrase_ref)

    @property
    @pulumi.getter(name="clientCertRef")
    def client_cert_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_cert_ref")

    @client_cert_ref.setter
    def client_cert_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_cert_ref", value)

    @property
    @pulumi.getter(name="clientKeyAlgorithm")
    def client_key_algorithm(self) -> pulumi.Input[builtins.str]:
        """
        The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        """
        return pulumi.get(self, "client_key_algorithm")

    @client_key_algorithm.setter
    def client_key_algorithm(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_key_algorithm", value)

    @property
    @pulumi.getter(name="clientKeyRef")
    def client_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_key_ref")

    @client_key_ref.setter
    def client_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_key_ref", value)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @master_url.setter
    def master_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "master_url", value)

    @property
    @pulumi.getter(name="caCertRef")
    def ca_cert_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ca_cert_ref")

    @ca_cert_ref.setter
    def ca_cert_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ca_cert_ref", value)

    @property
    @pulumi.getter(name="clientKeyPassphraseRef")
    def client_key_passphrase_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_key_passphrase_ref")

    @client_key_passphrase_ref.setter
    def client_key_passphrase_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_key_passphrase_ref", value)


if not MYPY:
    class KubernetesConnectorInheritFromDelegateArgsDict(TypedDict):
        delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        Selectors to use for the delegate.
        """
elif False:
    KubernetesConnectorInheritFromDelegateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesConnectorInheritFromDelegateArgs:
    def __init__(__self__, *,
                 delegate_selectors: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: Selectors to use for the delegate.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        Selectors to use for the delegate.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "delegate_selectors", value)


if not MYPY:
    class KubernetesConnectorOpenidConnectArgsDict(TypedDict):
        client_id_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        issuer_url: pulumi.Input[builtins.str]
        """
        The URL of the OpenID Connect issuer.
        """
        master_url: pulumi.Input[builtins.str]
        """
        The URL of the Kubernetes cluster.
        """
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Scopes to request for the connector.
        """
        secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username for the connector.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    KubernetesConnectorOpenidConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesConnectorOpenidConnectArgs:
    def __init__(__self__, *,
                 client_id_ref: pulumi.Input[builtins.str],
                 issuer_url: pulumi.Input[builtins.str],
                 master_url: pulumi.Input[builtins.str],
                 password_ref: pulumi.Input[builtins.str],
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id_ref: Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] issuer_url: The URL of the OpenID Connect issuer.
        :param pulumi.Input[builtins.str] master_url: The URL of the Kubernetes cluster.
        :param pulumi.Input[builtins.str] password_ref: Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scopes: Scopes to request for the connector.
        :param pulumi.Input[builtins.str] secret_ref: Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username for the connector.
        :param pulumi.Input[builtins.str] username_ref: Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "password_ref", password_ref)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @client_id_ref.setter
    def client_id_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id_ref", value)

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the OpenID Connect issuer.
        """
        return pulumi.get(self, "issuer_url")

    @issuer_url.setter
    def issuer_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "issuer_url", value)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @master_url.setter
    def master_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "master_url", value)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Scopes to request for the connector.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username for the connector.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class KubernetesConnectorServiceAccountArgsDict(TypedDict):
        master_url: pulumi.Input[builtins.str]
        """
        The URL of the Kubernetes cluster.
        """
        service_account_token_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        ca_cert_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    KubernetesConnectorServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesConnectorServiceAccountArgs:
    def __init__(__self__, *,
                 master_url: pulumi.Input[builtins.str],
                 service_account_token_ref: pulumi.Input[builtins.str],
                 ca_cert_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] master_url: The URL of the Kubernetes cluster.
        :param pulumi.Input[builtins.str] service_account_token_ref: Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] ca_cert_ref: Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "service_account_token_ref", service_account_token_ref)
        if ca_cert_ref is not None:
            pulumi.set(__self__, "ca_cert_ref", ca_cert_ref)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @master_url.setter
    def master_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "master_url", value)

    @property
    @pulumi.getter(name="serviceAccountTokenRef")
    def service_account_token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "service_account_token_ref")

    @service_account_token_ref.setter
    def service_account_token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_token_ref", value)

    @property
    @pulumi.getter(name="caCertRef")
    def ca_cert_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ca_cert_ref")

    @ca_cert_ref.setter
    def ca_cert_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ca_cert_ref", value)


if not MYPY:
    class KubernetesConnectorUsernamePasswordArgsDict(TypedDict):
        master_url: pulumi.Input[builtins.str]
        """
        The URL of the Kubernetes cluster.
        """
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username for the connector.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    KubernetesConnectorUsernamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesConnectorUsernamePasswordArgs:
    def __init__(__self__, *,
                 master_url: pulumi.Input[builtins.str],
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] master_url: The URL of the Kubernetes cluster.
        :param pulumi.Input[builtins.str] password_ref: Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username for the connector.
        :param pulumi.Input[builtins.str] username_ref: Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> pulumi.Input[builtins.str]:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @master_url.setter
    def master_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "master_url", value)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username for the connector.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class ManualFreezeCurrentOrUpcomingWindowArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[builtins.int]]
        """
        End time of the freeze
        """
        start_time: NotRequired[pulumi.Input[builtins.int]]
        """
        Start time of the freeze
        """
elif False:
    ManualFreezeCurrentOrUpcomingWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManualFreezeCurrentOrUpcomingWindowArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[builtins.int]] = None,
                 start_time: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] end_time: End time of the freeze
        :param pulumi.Input[builtins.int] start_time: Start time of the freeze
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        End time of the freeze
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Start time of the freeze
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ManualFreezeFreezeWindowArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Duration of the freeze
        """
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        End time of the freeze
        """
        recurrences: NotRequired[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceArgsDict']]]]
        """
        Recurrence of the freeze window
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Start time of the freeze
        """
        time_zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Timezone
        """
elif False:
    ManualFreezeFreezeWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManualFreezeFreezeWindowArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[builtins.str]] = None,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 recurrences: Optional[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceArgs']]]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None,
                 time_zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] duration: Duration of the freeze
        :param pulumi.Input[builtins.str] end_time: End time of the freeze
        :param pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceArgs']]] recurrences: Recurrence of the freeze window
        :param pulumi.Input[builtins.str] start_time: Start time of the freeze
        :param pulumi.Input[builtins.str] time_zone: Timezone
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Duration of the freeze
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        End time of the freeze
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceArgs']]]]:
        """
        Recurrence of the freeze window
        """
        return pulumi.get(self, "recurrences")

    @recurrences.setter
    def recurrences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceArgs']]]]):
        pulumi.set(self, "recurrences", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Start time of the freeze
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Timezone
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class ManualFreezeFreezeWindowRecurrenceArgsDict(TypedDict):
        recurrence_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgsDict']]]]
        """
        Used to filter resources on their attributes
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
elif False:
    ManualFreezeFreezeWindowRecurrenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManualFreezeFreezeWindowRecurrenceArgs:
    def __init__(__self__, *,
                 recurrence_specs: Optional[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs']]]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs']]] recurrence_specs: Used to filter resources on their attributes
        :param pulumi.Input[builtins.str] type: Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
        if recurrence_specs is not None:
            pulumi.set(__self__, "recurrence_specs", recurrence_specs)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="recurrenceSpecs")
    def recurrence_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs']]]]:
        """
        Used to filter resources on their attributes
        """
        return pulumi.get(self, "recurrence_specs")

    @recurrence_specs.setter
    def recurrence_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs']]]]):
        pulumi.set(self, "recurrence_specs", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgsDict(TypedDict):
        until: NotRequired[pulumi.Input[builtins.str]]
        """
        Recurrence until timestamp
        """
        value: NotRequired[pulumi.Input[builtins.int]]
        """
        Value of n, for n months recurrence
        """
elif False:
    ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs:
    def __init__(__self__, *,
                 until: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] until: Recurrence until timestamp
        :param pulumi.Input[builtins.int] value: Value of n, for n months recurrence
        """
        if until is not None:
            pulumi.set(__self__, "until", until)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def until(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Recurrence until timestamp
        """
        return pulumi.get(self, "until")

    @until.setter
    def until(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "until", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Value of n, for n months recurrence
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class MonitoredServiceRequestArgsDict(TypedDict):
        environment_ref: pulumi.Input[builtins.str]
        """
        Environment in which the service is deployed.
        """
        name: pulumi.Input[builtins.str]
        """
        Name for the monitored service.
        """
        service_ref: pulumi.Input[builtins.str]
        """
        Service reference for the monitored service.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the monitored service.
        """
        change_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestChangeSourceArgsDict']]]]
        """
        Set of change sources for the monitored service.
        """
        dependencies: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestDependencyArgsDict']]]]
        """
        Dependencies of the monitored service.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description for the monitored service.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable the monitored service.
        """
        environment_ref_lists: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Environment reference list for the monitored service.
        """
        health_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestHealthSourceArgsDict']]]]
        """
        Set of health sources for the monitored service.
        """
        notification_rule_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestNotificationRuleRefArgsDict']]]]
        """
        Notification rule references for the monitored service.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags for the monitored service. comma-separated key value string pairs.
        """
        template_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Template reference for the monitored service.
        """
        version_label: NotRequired[pulumi.Input[builtins.str]]
        """
        Template version label for the monitored service.
        """
elif False:
    MonitoredServiceRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredServiceRequestArgs:
    def __init__(__self__, *,
                 environment_ref: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 service_ref: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 change_sources: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestChangeSourceArgs']]]] = None,
                 dependencies: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestDependencyArgs']]]] = None,
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 environment_ref_lists: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 health_sources: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestHealthSourceArgs']]]] = None,
                 notification_rule_refs: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestNotificationRuleRefArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 template_ref: Optional[pulumi.Input[builtins.str]] = None,
                 version_label: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] environment_ref: Environment in which the service is deployed.
        :param pulumi.Input[builtins.str] name: Name for the monitored service.
        :param pulumi.Input[builtins.str] service_ref: Service reference for the monitored service.
        :param pulumi.Input[builtins.str] type: Type of the monitored service.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestChangeSourceArgs']]] change_sources: Set of change sources for the monitored service.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestDependencyArgs']]] dependencies: Dependencies of the monitored service.
        :param pulumi.Input[builtins.str] description: Description for the monitored service.
        :param pulumi.Input[builtins.bool] enabled: Enable or disable the monitored service.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] environment_ref_lists: Environment reference list for the monitored service.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestHealthSourceArgs']]] health_sources: Set of health sources for the monitored service.
        :param pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestNotificationRuleRefArgs']]] notification_rule_refs: Notification rule references for the monitored service.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags for the monitored service. comma-separated key value string pairs.
        :param pulumi.Input[builtins.str] template_ref: Template reference for the monitored service.
        :param pulumi.Input[builtins.str] version_label: Template version label for the monitored service.
        """
        pulumi.set(__self__, "environment_ref", environment_ref)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_ref", service_ref)
        pulumi.set(__self__, "type", type)
        if change_sources is not None:
            pulumi.set(__self__, "change_sources", change_sources)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            warnings.warn("""enabled field is deprecated""", DeprecationWarning)
            pulumi.log.warn("""enabled is deprecated: enabled field is deprecated""")
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if environment_ref_lists is not None:
            pulumi.set(__self__, "environment_ref_lists", environment_ref_lists)
        if health_sources is not None:
            pulumi.set(__self__, "health_sources", health_sources)
        if notification_rule_refs is not None:
            pulumi.set(__self__, "notification_rule_refs", notification_rule_refs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template_ref is not None:
            pulumi.set(__self__, "template_ref", template_ref)
        if version_label is not None:
            pulumi.set(__self__, "version_label", version_label)

    @property
    @pulumi.getter(name="environmentRef")
    def environment_ref(self) -> pulumi.Input[builtins.str]:
        """
        Environment in which the service is deployed.
        """
        return pulumi.get(self, "environment_ref")

    @environment_ref.setter
    def environment_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "environment_ref", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name for the monitored service.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceRef")
    def service_ref(self) -> pulumi.Input[builtins.str]:
        """
        Service reference for the monitored service.
        """
        return pulumi.get(self, "service_ref")

    @service_ref.setter
    def service_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_ref", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the monitored service.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="changeSources")
    def change_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestChangeSourceArgs']]]]:
        """
        Set of change sources for the monitored service.
        """
        return pulumi.get(self, "change_sources")

    @change_sources.setter
    def change_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestChangeSourceArgs']]]]):
        pulumi.set(self, "change_sources", value)

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestDependencyArgs']]]]:
        """
        Dependencies of the monitored service.
        """
        return pulumi.get(self, "dependencies")

    @dependencies.setter
    def dependencies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestDependencyArgs']]]]):
        pulumi.set(self, "dependencies", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description for the monitored service.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""enabled field is deprecated""")
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable the monitored service.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="environmentRefLists")
    def environment_ref_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Environment reference list for the monitored service.
        """
        return pulumi.get(self, "environment_ref_lists")

    @environment_ref_lists.setter
    def environment_ref_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "environment_ref_lists", value)

    @property
    @pulumi.getter(name="healthSources")
    def health_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestHealthSourceArgs']]]]:
        """
        Set of health sources for the monitored service.
        """
        return pulumi.get(self, "health_sources")

    @health_sources.setter
    def health_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestHealthSourceArgs']]]]):
        pulumi.set(self, "health_sources", value)

    @property
    @pulumi.getter(name="notificationRuleRefs")
    def notification_rule_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestNotificationRuleRefArgs']]]]:
        """
        Notification rule references for the monitored service.
        """
        return pulumi.get(self, "notification_rule_refs")

    @notification_rule_refs.setter
    def notification_rule_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitoredServiceRequestNotificationRuleRefArgs']]]]):
        pulumi.set(self, "notification_rule_refs", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags for the monitored service. comma-separated key value string pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="templateRef")
    def template_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Template reference for the monitored service.
        """
        return pulumi.get(self, "template_ref")

    @template_ref.setter
    def template_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_ref", value)

    @property
    @pulumi.getter(name="versionLabel")
    def version_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Template version label for the monitored service.
        """
        return pulumi.get(self, "version_label")

    @version_label.setter
    def version_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version_label", value)


if not MYPY:
    class MonitoredServiceRequestChangeSourceArgsDict(TypedDict):
        category: pulumi.Input[builtins.str]
        """
        Category of the change source.
        """
        identifier: pulumi.Input[builtins.str]
        """
        Identifier of the change source.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the change source.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the change source.
        """
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable or disable the change source.
        """
        spec: NotRequired[pulumi.Input[builtins.str]]
        """
        Specification of the change source. Depends on the type of the change source.
        """
elif False:
    MonitoredServiceRequestChangeSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredServiceRequestChangeSourceArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[builtins.str],
                 identifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 spec: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] category: Category of the change source.
        :param pulumi.Input[builtins.str] identifier: Identifier of the change source.
        :param pulumi.Input[builtins.str] name: Name of the change source.
        :param pulumi.Input[builtins.str] type: Type of the change source.
        :param pulumi.Input[builtins.bool] enabled: Enable or disable the change source.
        :param pulumi.Input[builtins.str] spec: Specification of the change source. Depends on the type of the change source.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def category(self) -> pulumi.Input[builtins.str]:
        """
        Category of the change source.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[builtins.str]:
        """
        Identifier of the change source.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the change source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the change source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable or disable the change source.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specification of the change source. Depends on the type of the change source.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class MonitoredServiceRequestDependencyArgsDict(TypedDict):
        monitored_service_identifier: pulumi.Input[builtins.str]
        """
        Monitored service identifier of the dependency.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the service dependency.
        """
        dependency_metadata: NotRequired[pulumi.Input[builtins.str]]
        """
        Dependency metadata for the monitored service.
        """
elif False:
    MonitoredServiceRequestDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredServiceRequestDependencyArgs:
    def __init__(__self__, *,
                 monitored_service_identifier: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 dependency_metadata: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] monitored_service_identifier: Monitored service identifier of the dependency.
        :param pulumi.Input[builtins.str] type: Type of the service dependency.
        :param pulumi.Input[builtins.str] dependency_metadata: Dependency metadata for the monitored service.
        """
        pulumi.set(__self__, "monitored_service_identifier", monitored_service_identifier)
        pulumi.set(__self__, "type", type)
        if dependency_metadata is not None:
            pulumi.set(__self__, "dependency_metadata", dependency_metadata)

    @property
    @pulumi.getter(name="monitoredServiceIdentifier")
    def monitored_service_identifier(self) -> pulumi.Input[builtins.str]:
        """
        Monitored service identifier of the dependency.
        """
        return pulumi.get(self, "monitored_service_identifier")

    @monitored_service_identifier.setter
    def monitored_service_identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "monitored_service_identifier", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the service dependency.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="dependencyMetadata")
    def dependency_metadata(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Dependency metadata for the monitored service.
        """
        return pulumi.get(self, "dependency_metadata")

    @dependency_metadata.setter
    def dependency_metadata(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dependency_metadata", value)


if not MYPY:
    class MonitoredServiceRequestHealthSourceArgsDict(TypedDict):
        identifier: pulumi.Input[builtins.str]
        """
        Identifier of the health source.
        """
        name: pulumi.Input[builtins.str]
        """
        Name of the health source.
        """
        spec: pulumi.Input[builtins.str]
        """
        Specification of the health source. Depends on the type of the health source.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the health source.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of the health source.
        """
elif False:
    MonitoredServiceRequestHealthSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredServiceRequestHealthSourceArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[builtins.str],
                 name: pulumi.Input[builtins.str],
                 spec: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] identifier: Identifier of the health source.
        :param pulumi.Input[builtins.str] name: Name of the health source.
        :param pulumi.Input[builtins.str] spec: Specification of the health source. Depends on the type of the health source.
        :param pulumi.Input[builtins.str] type: Type of the health source.
        :param pulumi.Input[builtins.str] version: Version of the health source.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[builtins.str]:
        """
        Identifier of the health source.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the health source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input[builtins.str]:
        """
        Specification of the health source. Depends on the type of the health source.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the health source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of the health source.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class MonitoredServiceRequestNotificationRuleRefArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Enable or disable notification rule reference for the monitored service.
        """
        notification_rule_ref: pulumi.Input[builtins.str]
        """
        Notification rule reference for the monitored service.
        """
elif False:
    MonitoredServiceRequestNotificationRuleRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitoredServiceRequestNotificationRuleRefArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 notification_rule_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable notification rule reference for the monitored service.
        :param pulumi.Input[builtins.str] notification_rule_ref: Notification rule reference for the monitored service.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "notification_rule_ref", notification_rule_ref)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Enable or disable notification rule reference for the monitored service.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="notificationRuleRef")
    def notification_rule_ref(self) -> pulumi.Input[builtins.str]:
        """
        Notification rule reference for the monitored service.
        """
        return pulumi.get(self, "notification_rule_ref")

    @notification_rule_ref.setter
    def notification_rule_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "notification_rule_ref", value)


if not MYPY:
    class NexusConnectorCredentialsArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    NexusConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NexusConnectorCredentialsArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class NotificationRuleRequestArgsDict(TypedDict):
        conditions: pulumi.Input[Sequence[pulumi.Input['NotificationRuleRequestConditionArgsDict']]]
        """
        Notification Rule conditions specification.
        """
        name: pulumi.Input[builtins.str]
        """
        Name for the Notification Rule.
        """
        notification_method: pulumi.Input['NotificationRuleRequestNotificationMethodArgsDict']
        """
        Notification Method specifications.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the Notification Rule.
        """
elif False:
    NotificationRuleRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationRuleRequestArgs:
    def __init__(__self__, *,
                 conditions: pulumi.Input[Sequence[pulumi.Input['NotificationRuleRequestConditionArgs']]],
                 name: pulumi.Input[builtins.str],
                 notification_method: pulumi.Input['NotificationRuleRequestNotificationMethodArgs'],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['NotificationRuleRequestConditionArgs']]] conditions: Notification Rule conditions specification.
        :param pulumi.Input[builtins.str] name: Name for the Notification Rule.
        :param pulumi.Input['NotificationRuleRequestNotificationMethodArgs'] notification_method: Notification Method specifications.
        :param pulumi.Input[builtins.str] type: Type of the Notification Rule.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_method", notification_method)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> pulumi.Input[Sequence[pulumi.Input['NotificationRuleRequestConditionArgs']]]:
        """
        Notification Rule conditions specification.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: pulumi.Input[Sequence[pulumi.Input['NotificationRuleRequestConditionArgs']]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name for the Notification Rule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="notificationMethod")
    def notification_method(self) -> pulumi.Input['NotificationRuleRequestNotificationMethodArgs']:
        """
        Notification Method specifications.
        """
        return pulumi.get(self, "notification_method")

    @notification_method.setter
    def notification_method(self, value: pulumi.Input['NotificationRuleRequestNotificationMethodArgs']):
        pulumi.set(self, "notification_method", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Notification Rule.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class NotificationRuleRequestConditionArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type of the condition.
        """
        spec: NotRequired[pulumi.Input[builtins.str]]
        """
        Specification of the notification condition. Depends on the type of the notification condition.
        """
elif False:
    NotificationRuleRequestConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationRuleRequestConditionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 spec: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: Type of the condition.
        :param pulumi.Input[builtins.str] spec: Specification of the notification condition. Depends on the type of the notification condition.
        """
        pulumi.set(__self__, "type", type)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the condition.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specification of the notification condition. Depends on the type of the notification condition.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class NotificationRuleRequestNotificationMethodArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type of the Notification Method.
        """
        spec: NotRequired[pulumi.Input[builtins.str]]
        """
        Specification of the notification method. Depends on the type of the notification method.
        """
elif False:
    NotificationRuleRequestNotificationMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NotificationRuleRequestNotificationMethodArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 spec: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: Type of the Notification Method.
        :param pulumi.Input[builtins.str] spec: Specification of the notification method. Depends on the type of the notification method.
        """
        pulumi.set(__self__, "type", type)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the Notification Method.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specification of the notification method. Depends on the type of the notification method.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class OciHelmConnectorCredentialsArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    OciHelmConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OciHelmConnectorCredentialsArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class OverridesGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message used for the merge commit.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_harness_code_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the repo is in harness code
        """
        is_new_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the branch being created is new
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating override.
        """
        load_from_cache: NotRequired[pulumi.Input[builtins.bool]]
        """
        Load service yaml from catch
        """
        load_from_fallback_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        Load service yaml from fallback branch
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    OverridesGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OverridesGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_harness_code_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 is_new_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_cache: Optional[pulumi.Input[builtins.bool]] = None,
                 load_from_fallback_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: Commit message used for the merge commit.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] is_harness_code_repo: If the repo is in harness code
        :param pulumi.Input[builtins.bool] is_new_branch: If the branch being created is new
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating override.
        :param pulumi.Input[builtins.bool] load_from_cache: Load service yaml from catch
        :param pulumi.Input[builtins.bool] load_from_fallback_branch: Load service yaml from fallback branch
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the repo is in harness code
        """
        return pulumi.get(self, "is_harness_code_repo")

    @is_harness_code_repo.setter
    def is_harness_code_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harness_code_repo", value)

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the branch being created is new
        """
        return pulumi.get(self, "is_new_branch")

    @is_new_branch.setter
    def is_new_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_new_branch", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Load service yaml from catch
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class PipelineFiltersFilterPropertiesArgsDict(TypedDict):
        filter_type: pulumi.Input[builtins.str]
        """
        Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        description of the pipline filter.
        """
        module_properties: NotRequired[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesArgsDict']]
        """
        module properties of the pipline filter.
        """
        name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the pipeline filter.
        """
        pipeline_identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Pipeline identifiers to filter on.
        """
        pipeline_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the pipeline execution filter.
        """
        pipeline_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]
        """
        Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
elif False:
    PipelineFiltersFilterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersFilterPropertiesArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 module_properties: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesArgs']] = None,
                 name: Optional[pulumi.Input[builtins.str]] = None,
                 pipeline_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 pipeline_name: Optional[pulumi.Input[builtins.str]] = None,
                 pipeline_tags: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] filter_type: Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        :param pulumi.Input[builtins.str] description: description of the pipline filter.
        :param pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesArgs'] module_properties: module properties of the pipline filter.
        :param pulumi.Input[builtins.str] name: Name of the pipeline filter.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] pipeline_identifiers: Pipeline identifiers to filter on.
        :param pulumi.Input[builtins.str] pipeline_name: Name of the pipeline execution filter.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]] pipeline_tags: Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if module_properties is not None:
            pulumi.set(__self__, "module_properties", module_properties)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline_identifiers is not None:
            pulumi.set(__self__, "pipeline_identifiers", pipeline_identifiers)
        if pipeline_name is not None:
            pulumi.set(__self__, "pipeline_name", pipeline_name)
        if pipeline_tags is not None:
            pulumi.set(__self__, "pipeline_tags", pipeline_tags)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[builtins.str]:
        """
        Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        description of the pipline filter.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="moduleProperties")
    def module_properties(self) -> Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesArgs']]:
        """
        module properties of the pipline filter.
        """
        return pulumi.get(self, "module_properties")

    @module_properties.setter
    def module_properties(self, value: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesArgs']]):
        pulumi.set(self, "module_properties", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the pipeline filter.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="pipelineIdentifiers")
    def pipeline_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Pipeline identifiers to filter on.
        """
        return pulumi.get(self, "pipeline_identifiers")

    @pipeline_identifiers.setter
    def pipeline_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "pipeline_identifiers", value)

    @property
    @pulumi.getter(name="pipelineName")
    def pipeline_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the pipeline execution filter.
        """
        return pulumi.get(self, "pipeline_name")

    @pipeline_name.setter
    def pipeline_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pipeline_name", value)

    @property
    @pulumi.getter(name="pipelineTags")
    def pipeline_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]:
        """
        Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        """
        return pulumi.get(self, "pipeline_tags")

    @pipeline_tags.setter
    def pipeline_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]]]):
        pulumi.set(self, "pipeline_tags", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PipelineFiltersFilterPropertiesModulePropertiesArgsDict(TypedDict):
        cd: NotRequired[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCdArgsDict']]
        """
        CD related properties to be filtered on.
        """
        ci: NotRequired[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiArgsDict']]
        """
        CI related properties to be filtered on.
        """
elif False:
    PipelineFiltersFilterPropertiesModulePropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersFilterPropertiesModulePropertiesArgs:
    def __init__(__self__, *,
                 cd: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCdArgs']] = None,
                 ci: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiArgs']] = None):
        """
        :param pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCdArgs'] cd: CD related properties to be filtered on.
        :param pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiArgs'] ci: CI related properties to be filtered on.
        """
        if cd is not None:
            pulumi.set(__self__, "cd", cd)
        if ci is not None:
            pulumi.set(__self__, "ci", ci)

    @property
    @pulumi.getter
    def cd(self) -> Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCdArgs']]:
        """
        CD related properties to be filtered on.
        """
        return pulumi.get(self, "cd")

    @cd.setter
    def cd(self, value: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCdArgs']]):
        pulumi.set(self, "cd", value)

    @property
    @pulumi.getter
    def ci(self) -> Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiArgs']]:
        """
        CI related properties to be filtered on.
        """
        return pulumi.get(self, "ci")

    @ci.setter
    def ci(self, value: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiArgs']]):
        pulumi.set(self, "ci", value)


if not MYPY:
    class PipelineFiltersFilterPropertiesModulePropertiesCdArgsDict(TypedDict):
        artifact_display_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Artifact display names of the CD pipeline.
        """
        deployment_types: NotRequired[pulumi.Input[builtins.str]]
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        environment_identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Environment identifier of the CD pipeline.
        """
        environment_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Environment names of the CD pipeline.
        """
        service_definition_types: NotRequired[pulumi.Input[builtins.str]]
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        service_identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Service identifiers of the CD pipeline.
        """
        service_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Service names of the CD pipeline.
        """
elif False:
    PipelineFiltersFilterPropertiesModulePropertiesCdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersFilterPropertiesModulePropertiesCdArgs:
    def __init__(__self__, *,
                 artifact_display_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 deployment_types: Optional[pulumi.Input[builtins.str]] = None,
                 environment_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 environment_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 service_definition_types: Optional[pulumi.Input[builtins.str]] = None,
                 service_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 service_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] artifact_display_names: Artifact display names of the CD pipeline.
        :param pulumi.Input[builtins.str] deployment_types: Deployment type of the CD pipeline, eg. Kubernetes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] environment_identifiers: Environment identifier of the CD pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] environment_names: Environment names of the CD pipeline.
        :param pulumi.Input[builtins.str] service_definition_types: Deployment type of the CD pipeline, eg. Kubernetes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] service_identifiers: Service identifiers of the CD pipeline.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] service_names: Service names of the CD pipeline.
        """
        if artifact_display_names is not None:
            pulumi.set(__self__, "artifact_display_names", artifact_display_names)
        if deployment_types is not None:
            pulumi.set(__self__, "deployment_types", deployment_types)
        if environment_identifiers is not None:
            pulumi.set(__self__, "environment_identifiers", environment_identifiers)
        if environment_names is not None:
            pulumi.set(__self__, "environment_names", environment_names)
        if service_definition_types is not None:
            pulumi.set(__self__, "service_definition_types", service_definition_types)
        if service_identifiers is not None:
            pulumi.set(__self__, "service_identifiers", service_identifiers)
        if service_names is not None:
            pulumi.set(__self__, "service_names", service_names)

    @property
    @pulumi.getter(name="artifactDisplayNames")
    def artifact_display_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Artifact display names of the CD pipeline.
        """
        return pulumi.get(self, "artifact_display_names")

    @artifact_display_names.setter
    def artifact_display_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "artifact_display_names", value)

    @property
    @pulumi.getter(name="deploymentTypes")
    def deployment_types(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        return pulumi.get(self, "deployment_types")

    @deployment_types.setter
    def deployment_types(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "deployment_types", value)

    @property
    @pulumi.getter(name="environmentIdentifiers")
    def environment_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Environment identifier of the CD pipeline.
        """
        return pulumi.get(self, "environment_identifiers")

    @environment_identifiers.setter
    def environment_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "environment_identifiers", value)

    @property
    @pulumi.getter(name="environmentNames")
    def environment_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Environment names of the CD pipeline.
        """
        return pulumi.get(self, "environment_names")

    @environment_names.setter
    def environment_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "environment_names", value)

    @property
    @pulumi.getter(name="serviceDefinitionTypes")
    def service_definition_types(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        return pulumi.get(self, "service_definition_types")

    @service_definition_types.setter
    def service_definition_types(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_definition_types", value)

    @property
    @pulumi.getter(name="serviceIdentifiers")
    def service_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Service identifiers of the CD pipeline.
        """
        return pulumi.get(self, "service_identifiers")

    @service_identifiers.setter
    def service_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "service_identifiers", value)

    @property
    @pulumi.getter(name="serviceNames")
    def service_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Service names of the CD pipeline.
        """
        return pulumi.get(self, "service_names")

    @service_names.setter
    def service_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "service_names", value)


if not MYPY:
    class PipelineFiltersFilterPropertiesModulePropertiesCiArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Branch which was used while building.
        """
        build_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Build type of the pipeline. Possible values: branch.
        """
        ci_execution_info: NotRequired[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgsDict']]
        """
        CI execution info for the pipeline.
        """
        repo_names: NotRequired[pulumi.Input[builtins.str]]
        """
        name of the repository used in the pipeline.
        """
        tag: NotRequired[pulumi.Input[builtins.str]]
        """
        Tags to associate with the CI pipeline resource.
        """
elif False:
    PipelineFiltersFilterPropertiesModulePropertiesCiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersFilterPropertiesModulePropertiesCiArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[builtins.str]] = None,
                 build_type: Optional[pulumi.Input[builtins.str]] = None,
                 ci_execution_info: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs']] = None,
                 repo_names: Optional[pulumi.Input[builtins.str]] = None,
                 tag: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] branch: Branch which was used while building.
        :param pulumi.Input[builtins.str] build_type: Build type of the pipeline. Possible values: branch.
        :param pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs'] ci_execution_info: CI execution info for the pipeline.
        :param pulumi.Input[builtins.str] repo_names: name of the repository used in the pipeline.
        :param pulumi.Input[builtins.str] tag: Tags to associate with the CI pipeline resource.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if build_type is not None:
            pulumi.set(__self__, "build_type", build_type)
        if ci_execution_info is not None:
            pulumi.set(__self__, "ci_execution_info", ci_execution_info)
        if repo_names is not None:
            pulumi.set(__self__, "repo_names", repo_names)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Branch which was used while building.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Build type of the pipeline. Possible values: branch.
        """
        return pulumi.get(self, "build_type")

    @build_type.setter
    def build_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "build_type", value)

    @property
    @pulumi.getter(name="ciExecutionInfo")
    def ci_execution_info(self) -> Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs']]:
        """
        CI execution info for the pipeline.
        """
        return pulumi.get(self, "ci_execution_info")

    @ci_execution_info.setter
    def ci_execution_info(self, value: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs']]):
        pulumi.set(self, "ci_execution_info", value)

    @property
    @pulumi.getter(name="repoNames")
    def repo_names(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        name of the repository used in the pipeline.
        """
        return pulumi.get(self, "repo_names")

    @repo_names.setter
    def repo_names(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_names", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Tags to associate with the CI pipeline resource.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgsDict(TypedDict):
        event: NotRequired[pulumi.Input[builtins.str]]
        """
        Event for the ci execution, Possible values: pullRequest.
        """
        pull_request: NotRequired[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgsDict']]
        """
        The pull request details of the CI pipeline.
        """
elif False:
    PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs:
    def __init__(__self__, *,
                 event: Optional[pulumi.Input[builtins.str]] = None,
                 pull_request: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs']] = None):
        """
        :param pulumi.Input[builtins.str] event: Event for the ci execution, Possible values: pullRequest.
        :param pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs'] pull_request: The pull request details of the CI pipeline.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if pull_request is not None:
            pulumi.set(__self__, "pull_request", pull_request)

    @property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Event for the ci execution, Possible values: pullRequest.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "event", value)

    @property
    @pulumi.getter(name="pullRequest")
    def pull_request(self) -> Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs']]:
        """
        The pull request details of the CI pipeline.
        """
        return pulumi.get(self, "pull_request")

    @pull_request.setter
    def pull_request(self, value: Optional[pulumi.Input['PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs']]):
        pulumi.set(self, "pull_request", value)


if not MYPY:
    class PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgsDict(TypedDict):
        source_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Source branch of the pull request.
        """
        target_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Target branch of the pull request.
        """
elif False:
    PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs:
    def __init__(__self__, *,
                 source_branch: Optional[pulumi.Input[builtins.str]] = None,
                 target_branch: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] source_branch: Source branch of the pull request.
        :param pulumi.Input[builtins.str] target_branch: Target branch of the pull request.
        """
        if source_branch is not None:
            pulumi.set(__self__, "source_branch", source_branch)
        if target_branch is not None:
            pulumi.set(__self__, "target_branch", target_branch)

    @property
    @pulumi.getter(name="sourceBranch")
    def source_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Source branch of the pull request.
        """
        return pulumi.get(self, "source_branch")

    @source_branch.setter
    def source_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "source_branch", value)

    @property
    @pulumi.getter(name="targetBranch")
    def target_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Target branch of the pull request.
        """
        return pulumi.get(self, "target_branch")

    @target_branch.setter
    def target_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_branch", value)


if not MYPY:
    class PipelineGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message used for the merge commit.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_harness_code_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the repo is harness code.
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    PipelineGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch_name: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_harness_code_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch_name: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: Commit message used for the merge commit.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] is_harness_code_repo: If the repo is harness code.
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the repo is harness code.
        """
        return pulumi.get(self, "is_harness_code_repo")

    @is_harness_code_repo.setter
    def is_harness_code_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harness_code_repo", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class PipelineGitImportInfoArgsDict(TypedDict):
        branch_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
elif False:
    PipelineGitImportInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelineGitImportInfoArgs:
    def __init__(__self__, *,
                 branch_name: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] branch_name: Name of the branch.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class PipelinePipelineImportRequestArgsDict(TypedDict):
        pipeline_description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the pipeline.
        """
        pipeline_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the pipeline.
        """
elif False:
    PipelinePipelineImportRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PipelinePipelineImportRequestArgs:
    def __init__(__self__, *,
                 pipeline_description: Optional[pulumi.Input[builtins.str]] = None,
                 pipeline_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] pipeline_description: Description of the pipeline.
        :param pulumi.Input[builtins.str] pipeline_name: Name of the pipeline.
        """
        if pipeline_description is not None:
            pulumi.set(__self__, "pipeline_description", pipeline_description)
        if pipeline_name is not None:
            pulumi.set(__self__, "pipeline_name", pipeline_name)

    @property
    @pulumi.getter(name="pipelineDescription")
    def pipeline_description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the pipeline.
        """
        return pulumi.get(self, "pipeline_description")

    @pipeline_description.setter
    def pipeline_description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pipeline_description", value)

    @property
    @pulumi.getter(name="pipelineName")
    def pipeline_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the pipeline.
        """
        return pulumi.get(self, "pipeline_name")

    @pipeline_name.setter
    def pipeline_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pipeline_name", value)


if not MYPY:
    class PolicySetPolicyArgsDict(TypedDict):
        identifier: pulumi.Input[builtins.str]
        """
        Account Identifier of the account
        """
        severity: pulumi.Input[builtins.str]
        """
        Policy failure response - 'warning' for continuation, 'error' for exit
        """
elif False:
    PolicySetPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicySetPolicyArgs:
    def __init__(__self__, *,
                 identifier: pulumi.Input[builtins.str],
                 severity: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] identifier: Account Identifier of the account
        :param pulumi.Input[builtins.str] severity: Policy failure response - 'warning' for continuation, 'error' for exit
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def identifier(self) -> pulumi.Input[builtins.str]:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def severity(self) -> pulumi.Input[builtins.str]:
        """
        Policy failure response - 'warning' for continuation, 'error' for exit
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class PrometheusConnectorHeaderArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key.
        """
        encrypted_value_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        value: NotRequired[pulumi.Input[builtins.str]]
        """
        Value.
        """
        value_encrypted: NotRequired[pulumi.Input[builtins.bool]]
        """
        Encrypted value.
        """
elif False:
    PrometheusConnectorHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrometheusConnectorHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 encrypted_value_ref: Optional[pulumi.Input[builtins.str]] = None,
                 value: Optional[pulumi.Input[builtins.str]] = None,
                 value_encrypted: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] key: Key.
        :param pulumi.Input[builtins.str] encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] value: Value.
        :param pulumi.Input[builtins.bool] value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_value_ref is not None:
            pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_encrypted is not None:
            pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @encrypted_value_ref.setter
    def encrypted_value_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encrypted_value_ref", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")

    @value_encrypted.setter
    def value_encrypted(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "value_encrypted", value)


if not MYPY:
    class ProviderSpecArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        The type of the provider entity.
        """
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Id of the OAuth app to connect
        """
        client_secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Client Secret Ref of the OAuth app to connect
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Delegate selectors to fetch the access token
        """
        domain: NotRequired[pulumi.Input[builtins.str]]
        """
        Host domain of the provider.
        """
        secret_manager_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Secret Manager Ref to store the access/refresh tokens
        """
elif False:
    ProviderSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderSpecArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 client_secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 domain: Optional[pulumi.Input[builtins.str]] = None,
                 secret_manager_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: The type of the provider entity.
        :param pulumi.Input[builtins.str] client_id: Client Id of the OAuth app to connect
        :param pulumi.Input[builtins.str] client_secret_ref: Client Secret Ref of the OAuth app to connect
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: Delegate selectors to fetch the access token
        :param pulumi.Input[builtins.str] domain: Host domain of the provider.
        :param pulumi.Input[builtins.str] secret_manager_ref: Secret Manager Ref to store the access/refresh tokens
        """
        pulumi.set(__self__, "type", type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_ref is not None:
            pulumi.set(__self__, "client_secret_ref", client_secret_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if secret_manager_ref is not None:
            pulumi.set(__self__, "secret_manager_ref", secret_manager_ref)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the provider entity.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Id of the OAuth app to connect
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Client Secret Ref of the OAuth app to connect
        """
        return pulumi.get(self, "client_secret_ref")

    @client_secret_ref.setter
    def client_secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_ref", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Delegate selectors to fetch the access token
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Host domain of the provider.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="secretManagerRef")
    def secret_manager_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Secret Manager Ref to store the access/refresh tokens
        """
        return pulumi.get(self, "secret_manager_ref")

    @secret_manager_ref.setter
    def secret_manager_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secret_manager_ref", value)


if not MYPY:
    class RepoRuleBranchBypassArgsDict(TypedDict):
        repo_owners: NotRequired[pulumi.Input[builtins.bool]]
        """
        Allow users with repository edit permission to bypass.
        """
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of user ids with who can bypass.
        """
elif False:
    RepoRuleBranchBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepoRuleBranchBypassArgs:
    def __init__(__self__, *,
                 repo_owners: Optional[pulumi.Input[builtins.bool]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] repo_owners: Allow users with repository edit permission to bypass.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_ids: List of user ids with who can bypass.
        """
        if repo_owners is not None:
            pulumi.set(__self__, "repo_owners", repo_owners)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="repoOwners")
    def repo_owners(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Allow users with repository edit permission to bypass.
        """
        return pulumi.get(self, "repo_owners")

    @repo_owners.setter
    def repo_owners(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "repo_owners", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of user ids with who can bypass.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class RepoRuleBranchPatternArgsDict(TypedDict):
        default_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        Should rule apply to default branch of the repository.
        """
        excludes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Globstar branch patterns on which rules will NOT be applied.
        """
        includes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Globstar branch patterns on which rules will be applied.
        """
elif False:
    RepoRuleBranchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepoRuleBranchPatternArgs:
    def __init__(__self__, *,
                 default_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 excludes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 includes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.bool] default_branch: Should rule apply to default branch of the repository.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] excludes: Globstar branch patterns on which rules will NOT be applied.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] includes: Globstar branch patterns on which rules will be applied.
        """
        if default_branch is not None:
            pulumi.set(__self__, "default_branch", default_branch)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Should rule apply to default branch of the repository.
        """
        return pulumi.get(self, "default_branch")

    @default_branch.setter
    def default_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "default_branch", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Globstar branch patterns on which rules will NOT be applied.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Globstar branch patterns on which rules will be applied.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class RepoRuleBranchPolicyArgsDict(TypedDict):
        allow_merge_strategies: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        """
        block_branch_creation: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only allow users with bypass permission to create matching branches.
        """
        block_branch_deletion: NotRequired[pulumi.Input[builtins.bool]]
        """
        Only allow users with bypass permission to delete matching branches.
        """
        delete_branch_on_merge: NotRequired[pulumi.Input[builtins.bool]]
        """
        Automatically delete the source branch of a pull request after it is merged.
        """
        require_code_owners: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require approval on pull requests from one reviewer for each codeowner rule.
        """
        require_latest_commit_approval: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require re-approval when there are new changes in the pull request.
        """
        require_minimum_approval_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Require approval on pull requests from a minimum number of reviewers.
        """
        require_no_change_request: NotRequired[pulumi.Input[builtins.bool]]
        """
        Require all request for changes have been resolved.
        """
        require_pull_request: NotRequired[pulumi.Input[builtins.bool]]
        """
        Do not allow any changes to matching branches without a pull request.
        """
        require_resolve_all_comments: NotRequired[pulumi.Input[builtins.bool]]
        """
        All comments on a pull request must be resolved before it can be merged.
        """
        require_status_checks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Selected status checks must pass before a pull request can be merged.
        """
elif False:
    RepoRuleBranchPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepoRuleBranchPolicyArgs:
    def __init__(__self__, *,
                 allow_merge_strategies: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 block_branch_creation: Optional[pulumi.Input[builtins.bool]] = None,
                 block_branch_deletion: Optional[pulumi.Input[builtins.bool]] = None,
                 delete_branch_on_merge: Optional[pulumi.Input[builtins.bool]] = None,
                 require_code_owners: Optional[pulumi.Input[builtins.bool]] = None,
                 require_latest_commit_approval: Optional[pulumi.Input[builtins.bool]] = None,
                 require_minimum_approval_count: Optional[pulumi.Input[builtins.int]] = None,
                 require_no_change_request: Optional[pulumi.Input[builtins.bool]] = None,
                 require_pull_request: Optional[pulumi.Input[builtins.bool]] = None,
                 require_resolve_all_comments: Optional[pulumi.Input[builtins.bool]] = None,
                 require_status_checks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allow_merge_strategies: Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        :param pulumi.Input[builtins.bool] block_branch_creation: Only allow users with bypass permission to create matching branches.
        :param pulumi.Input[builtins.bool] block_branch_deletion: Only allow users with bypass permission to delete matching branches.
        :param pulumi.Input[builtins.bool] delete_branch_on_merge: Automatically delete the source branch of a pull request after it is merged.
        :param pulumi.Input[builtins.bool] require_code_owners: Require approval on pull requests from one reviewer for each codeowner rule.
        :param pulumi.Input[builtins.bool] require_latest_commit_approval: Require re-approval when there are new changes in the pull request.
        :param pulumi.Input[builtins.int] require_minimum_approval_count: Require approval on pull requests from a minimum number of reviewers.
        :param pulumi.Input[builtins.bool] require_no_change_request: Require all request for changes have been resolved.
        :param pulumi.Input[builtins.bool] require_pull_request: Do not allow any changes to matching branches without a pull request.
        :param pulumi.Input[builtins.bool] require_resolve_all_comments: All comments on a pull request must be resolved before it can be merged.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] require_status_checks: Selected status checks must pass before a pull request can be merged.
        """
        if allow_merge_strategies is not None:
            pulumi.set(__self__, "allow_merge_strategies", allow_merge_strategies)
        if block_branch_creation is not None:
            pulumi.set(__self__, "block_branch_creation", block_branch_creation)
        if block_branch_deletion is not None:
            pulumi.set(__self__, "block_branch_deletion", block_branch_deletion)
        if delete_branch_on_merge is not None:
            pulumi.set(__self__, "delete_branch_on_merge", delete_branch_on_merge)
        if require_code_owners is not None:
            pulumi.set(__self__, "require_code_owners", require_code_owners)
        if require_latest_commit_approval is not None:
            pulumi.set(__self__, "require_latest_commit_approval", require_latest_commit_approval)
        if require_minimum_approval_count is not None:
            pulumi.set(__self__, "require_minimum_approval_count", require_minimum_approval_count)
        if require_no_change_request is not None:
            pulumi.set(__self__, "require_no_change_request", require_no_change_request)
        if require_pull_request is not None:
            pulumi.set(__self__, "require_pull_request", require_pull_request)
        if require_resolve_all_comments is not None:
            pulumi.set(__self__, "require_resolve_all_comments", require_resolve_all_comments)
        if require_status_checks is not None:
            pulumi.set(__self__, "require_status_checks", require_status_checks)

    @property
    @pulumi.getter(name="allowMergeStrategies")
    def allow_merge_strategies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        """
        return pulumi.get(self, "allow_merge_strategies")

    @allow_merge_strategies.setter
    def allow_merge_strategies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "allow_merge_strategies", value)

    @property
    @pulumi.getter(name="blockBranchCreation")
    def block_branch_creation(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only allow users with bypass permission to create matching branches.
        """
        return pulumi.get(self, "block_branch_creation")

    @block_branch_creation.setter
    def block_branch_creation(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_branch_creation", value)

    @property
    @pulumi.getter(name="blockBranchDeletion")
    def block_branch_deletion(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Only allow users with bypass permission to delete matching branches.
        """
        return pulumi.get(self, "block_branch_deletion")

    @block_branch_deletion.setter
    def block_branch_deletion(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "block_branch_deletion", value)

    @property
    @pulumi.getter(name="deleteBranchOnMerge")
    def delete_branch_on_merge(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Automatically delete the source branch of a pull request after it is merged.
        """
        return pulumi.get(self, "delete_branch_on_merge")

    @delete_branch_on_merge.setter
    def delete_branch_on_merge(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "delete_branch_on_merge", value)

    @property
    @pulumi.getter(name="requireCodeOwners")
    def require_code_owners(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require approval on pull requests from one reviewer for each codeowner rule.
        """
        return pulumi.get(self, "require_code_owners")

    @require_code_owners.setter
    def require_code_owners(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_code_owners", value)

    @property
    @pulumi.getter(name="requireLatestCommitApproval")
    def require_latest_commit_approval(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require re-approval when there are new changes in the pull request.
        """
        return pulumi.get(self, "require_latest_commit_approval")

    @require_latest_commit_approval.setter
    def require_latest_commit_approval(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_latest_commit_approval", value)

    @property
    @pulumi.getter(name="requireMinimumApprovalCount")
    def require_minimum_approval_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Require approval on pull requests from a minimum number of reviewers.
        """
        return pulumi.get(self, "require_minimum_approval_count")

    @require_minimum_approval_count.setter
    def require_minimum_approval_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "require_minimum_approval_count", value)

    @property
    @pulumi.getter(name="requireNoChangeRequest")
    def require_no_change_request(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Require all request for changes have been resolved.
        """
        return pulumi.get(self, "require_no_change_request")

    @require_no_change_request.setter
    def require_no_change_request(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_no_change_request", value)

    @property
    @pulumi.getter(name="requirePullRequest")
    def require_pull_request(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Do not allow any changes to matching branches without a pull request.
        """
        return pulumi.get(self, "require_pull_request")

    @require_pull_request.setter
    def require_pull_request(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_pull_request", value)

    @property
    @pulumi.getter(name="requireResolveAllComments")
    def require_resolve_all_comments(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        All comments on a pull request must be resolved before it can be merged.
        """
        return pulumi.get(self, "require_resolve_all_comments")

    @require_resolve_all_comments.setter
    def require_resolve_all_comments(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "require_resolve_all_comments", value)

    @property
    @pulumi.getter(name="requireStatusChecks")
    def require_status_checks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Selected status checks must pass before a pull request can be merged.
        """
        return pulumi.get(self, "require_status_checks")

    @require_status_checks.setter
    def require_status_checks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "require_status_checks", value)


if not MYPY:
    class RepoSourceArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[builtins.str]]
        """
        The host URL for the import source.
        """
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        The password for authentication when importing.
        """
        repo: NotRequired[pulumi.Input[builtins.str]]
        """
        The full identifier of the repository on the SCM provider's platform.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        The username for authentication when importing.
        """
elif False:
    RepoSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RepoSourceArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[builtins.str]] = None,
                 password: Optional[pulumi.Input[builtins.str]] = None,
                 repo: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] host: The host URL for the import source.
        :param pulumi.Input[builtins.str] password: The password for authentication when importing.
        :param pulumi.Input[builtins.str] repo: The full identifier of the repository on the SCM provider's platform.
        :param pulumi.Input[builtins.str] type: The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        :param pulumi.Input[builtins.str] username: The username for authentication when importing.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The host URL for the import source.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The password for authentication when importing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The full identifier of the repository on the SCM provider's platform.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The username for authentication when importing.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ResourceGroupIncludedScopeArgsDict(TypedDict):
        filter: pulumi.Input[builtins.str]
        """
        Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
        """
        account_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Account Identifier of the account
        """
        org_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Organization Identifier
        """
        project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Project Identifier
        """
elif False:
    ResourceGroupIncludedScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupIncludedScopeArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[builtins.str],
                 account_id: Optional[pulumi.Input[builtins.str]] = None,
                 org_id: Optional[pulumi.Input[builtins.str]] = None,
                 project_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] filter: Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
        :param pulumi.Input[builtins.str] account_id: Account Identifier of the account
        :param pulumi.Input[builtins.str] org_id: Organization Identifier
        :param pulumi.Input[builtins.str] project_id: Project Identifier
        """
        pulumi.set(__self__, "filter", filter)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[builtins.str]:
        """
        Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "account_id", value)

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Organization Identifier
        """
        return pulumi.get(self, "org_id")

    @org_id.setter
    def org_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "org_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Project Identifier
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class ResourceGroupResourceFilterArgsDict(TypedDict):
        include_all_resources: NotRequired[pulumi.Input[builtins.bool]]
        """
        Include all resource or not
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceArgsDict']]]]
        """
        Resources for a resource group
        """
elif False:
    ResourceGroupResourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupResourceFilterArgs:
    def __init__(__self__, *,
                 include_all_resources: Optional[pulumi.Input[builtins.bool]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceArgs']]]] = None):
        """
        :param pulumi.Input[builtins.bool] include_all_resources: Include all resource or not
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceArgs']]] resources: Resources for a resource group
        """
        if include_all_resources is not None:
            pulumi.set(__self__, "include_all_resources", include_all_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="includeAllResources")
    def include_all_resources(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Include all resource or not
        """
        return pulumi.get(self, "include_all_resources")

    @include_all_resources.setter
    def include_all_resources(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_all_resources", value)

    @property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceArgs']]]]:
        """
        Resources for a resource group
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceArgs']]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class ResourceGroupResourceFilterResourceArgsDict(TypedDict):
        resource_type: pulumi.Input[builtins.str]
        """
        Type of the resource
        """
        attribute_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceAttributeFilterArgsDict']]]]
        """
        Used to filter resources on their attributes
        """
        identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        List of the identifiers
        """
elif False:
    ResourceGroupResourceFilterResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupResourceFilterResourceArgs:
    def __init__(__self__, *,
                 resource_type: pulumi.Input[builtins.str],
                 attribute_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceAttributeFilterArgs']]]] = None,
                 identifiers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] resource_type: Type of the resource
        :param pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceAttributeFilterArgs']]] attribute_filters: Used to filter resources on their attributes
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] identifiers: List of the identifiers
        """
        pulumi.set(__self__, "resource_type", resource_type)
        if attribute_filters is not None:
            pulumi.set(__self__, "attribute_filters", attribute_filters)
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the resource
        """
        return pulumi.get(self, "resource_type")

    @resource_type.setter
    def resource_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_type", value)

    @property
    @pulumi.getter(name="attributeFilters")
    def attribute_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceAttributeFilterArgs']]]]:
        """
        Used to filter resources on their attributes
        """
        return pulumi.get(self, "attribute_filters")

    @attribute_filters.setter
    def attribute_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResourceGroupResourceFilterResourceAttributeFilterArgs']]]]):
        pulumi.set(self, "attribute_filters", value)

    @property
    @pulumi.getter
    def identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        List of the identifiers
        """
        return pulumi.get(self, "identifiers")

    @identifiers.setter
    def identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "identifiers", value)


if not MYPY:
    class ResourceGroupResourceFilterResourceAttributeFilterArgsDict(TypedDict):
        attribute_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the attribute. Valid values are `category`, `type`, `labels`, `tag` or `tags`.
        """
        attribute_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD*COST,CLOUD*PROVIDER,CODE*REPO,MONITORING,SECRET*MANAGER,TICKETING], for `type` are [Production,PreProduction], for `labels`, it can be using the syntax 'label:value', for `tag` or `tags` it can be any string.
        """
elif False:
    ResourceGroupResourceFilterResourceAttributeFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResourceGroupResourceFilterResourceAttributeFilterArgs:
    def __init__(__self__, *,
                 attribute_name: Optional[pulumi.Input[builtins.str]] = None,
                 attribute_values: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] attribute_name: Name of the attribute. Valid values are `category`, `type`, `labels`, `tag` or `tags`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] attribute_values: Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD*COST,CLOUD*PROVIDER,CODE*REPO,MONITORING,SECRET*MANAGER,TICKETING], for `type` are [Production,PreProduction], for `labels`, it can be using the syntax 'label:value', for `tag` or `tags` it can be any string.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_values is not None:
            pulumi.set(__self__, "attribute_values", attribute_values)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the attribute. Valid values are `category`, `type`, `labels`, `tag` or `tags`.
        """
        return pulumi.get(self, "attribute_name")

    @attribute_name.setter
    def attribute_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "attribute_name", value)

    @property
    @pulumi.getter(name="attributeValues")
    def attribute_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD*COST,CLOUD*PROVIDER,CODE*REPO,MONITORING,SECRET*MANAGER,TICKETING], for `type` are [Production,PreProduction], for `labels`, it can be using the syntax 'label:value', for `tag` or `tags` it can be any string.
        """
        return pulumi.get(self, "attribute_values")

    @attribute_values.setter
    def attribute_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attribute_values", value)


if not MYPY:
    class RoleAssignmentsPrincipalArgsDict(TypedDict):
        type: pulumi.Input[builtins.str]
        """
        Type.
        """
        identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier.
        """
        scope_level: NotRequired[pulumi.Input[builtins.str]]
        """
        Scope level.
        """
elif False:
    RoleAssignmentsPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleAssignmentsPrincipalArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[builtins.str],
                 identifier: Optional[pulumi.Input[builtins.str]] = None,
                 scope_level: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] type: Type.
        :param pulumi.Input[builtins.str] identifier: Identifier.
        :param pulumi.Input[builtins.str] scope_level: Scope level.
        """
        pulumi.set(__self__, "type", type)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if scope_level is not None:
            pulumi.set(__self__, "scope_level", scope_level)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier.
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter(name="scopeLevel")
    def scope_level(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scope level.
        """
        return pulumi.get(self, "scope_level")

    @scope_level.setter
    def scope_level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope_level", value)


if not MYPY:
    class SecretSshkeyKerberosArgsDict(TypedDict):
        principal: pulumi.Input[builtins.str]
        """
        Username to use for authentication.
        """
        realm: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication.
        """
        tgt_generation_method: NotRequired[pulumi.Input[builtins.str]]
        """
        Method to generate tgt
        """
        tgt_key_tab_file_path_spec: NotRequired[pulumi.Input['SecretSshkeyKerberosTgtKeyTabFilePathSpecArgsDict']]
        """
        Authenticate to App Dynamics using username and password.
        """
        tgt_password_spec: NotRequired[pulumi.Input['SecretSshkeyKerberosTgtPasswordSpecArgsDict']]
        """
        Authenticate to App Dynamics using username and password.
        """
elif False:
    SecretSshkeyKerberosArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeyKerberosArgs:
    def __init__(__self__, *,
                 principal: pulumi.Input[builtins.str],
                 realm: pulumi.Input[builtins.str],
                 tgt_generation_method: Optional[pulumi.Input[builtins.str]] = None,
                 tgt_key_tab_file_path_spec: Optional[pulumi.Input['SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs']] = None,
                 tgt_password_spec: Optional[pulumi.Input['SecretSshkeyKerberosTgtPasswordSpecArgs']] = None):
        """
        :param pulumi.Input[builtins.str] principal: Username to use for authentication.
        :param pulumi.Input[builtins.str] realm: Reference to a secret containing the password to use for authentication.
        :param pulumi.Input[builtins.str] tgt_generation_method: Method to generate tgt
        :param pulumi.Input['SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs'] tgt_key_tab_file_path_spec: Authenticate to App Dynamics using username and password.
        :param pulumi.Input['SecretSshkeyKerberosTgtPasswordSpecArgs'] tgt_password_spec: Authenticate to App Dynamics using username and password.
        """
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "realm", realm)
        if tgt_generation_method is not None:
            pulumi.set(__self__, "tgt_generation_method", tgt_generation_method)
        if tgt_key_tab_file_path_spec is not None:
            pulumi.set(__self__, "tgt_key_tab_file_path_spec", tgt_key_tab_file_path_spec)
        if tgt_password_spec is not None:
            pulumi.set(__self__, "tgt_password_spec", tgt_password_spec)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def realm(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication.
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "realm", value)

    @property
    @pulumi.getter(name="tgtGenerationMethod")
    def tgt_generation_method(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Method to generate tgt
        """
        return pulumi.get(self, "tgt_generation_method")

    @tgt_generation_method.setter
    def tgt_generation_method(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tgt_generation_method", value)

    @property
    @pulumi.getter(name="tgtKeyTabFilePathSpec")
    def tgt_key_tab_file_path_spec(self) -> Optional[pulumi.Input['SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs']]:
        """
        Authenticate to App Dynamics using username and password.
        """
        return pulumi.get(self, "tgt_key_tab_file_path_spec")

    @tgt_key_tab_file_path_spec.setter
    def tgt_key_tab_file_path_spec(self, value: Optional[pulumi.Input['SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs']]):
        pulumi.set(self, "tgt_key_tab_file_path_spec", value)

    @property
    @pulumi.getter(name="tgtPasswordSpec")
    def tgt_password_spec(self) -> Optional[pulumi.Input['SecretSshkeyKerberosTgtPasswordSpecArgs']]:
        """
        Authenticate to App Dynamics using username and password.
        """
        return pulumi.get(self, "tgt_password_spec")

    @tgt_password_spec.setter
    def tgt_password_spec(self, value: Optional[pulumi.Input['SecretSshkeyKerberosTgtPasswordSpecArgs']]):
        pulumi.set(self, "tgt_password_spec", value)


if not MYPY:
    class SecretSshkeyKerberosTgtKeyTabFilePathSpecArgsDict(TypedDict):
        key_path: NotRequired[pulumi.Input[builtins.str]]
        """
        key path
        """
elif False:
    SecretSshkeyKerberosTgtKeyTabFilePathSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs:
    def __init__(__self__, *,
                 key_path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key_path: key path
        """
        if key_path is not None:
            pulumi.set(__self__, "key_path", key_path)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        key path
        """
        return pulumi.get(self, "key_path")

    @key_path.setter
    def key_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_path", value)


if not MYPY:
    class SecretSshkeyKerberosTgtPasswordSpecArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[builtins.str]]
        """
        password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
elif False:
    SecretSshkeyKerberosTgtPasswordSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeyKerberosTgtPasswordSpecArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password: password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "password", value)


if not MYPY:
    class SecretSshkeySshArgsDict(TypedDict):
        credential_type: pulumi.Input[builtins.str]
        """
        This specifies SSH credential type as Password, KeyPath or KeyReference
        """
        ssh_password_credential: NotRequired[pulumi.Input['SecretSshkeySshSshPasswordCredentialArgsDict']]
        """
        SSH credential of type keyReference
        """
        sshkey_path_credential: NotRequired[pulumi.Input['SecretSshkeySshSshkeyPathCredentialArgsDict']]
        """
        SSH credential of type keyPath
        """
        sshkey_reference_credential: NotRequired[pulumi.Input['SecretSshkeySshSshkeyReferenceCredentialArgsDict']]
        """
        SSH credential of type keyReference
        """
elif False:
    SecretSshkeySshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeySshArgs:
    def __init__(__self__, *,
                 credential_type: pulumi.Input[builtins.str],
                 ssh_password_credential: Optional[pulumi.Input['SecretSshkeySshSshPasswordCredentialArgs']] = None,
                 sshkey_path_credential: Optional[pulumi.Input['SecretSshkeySshSshkeyPathCredentialArgs']] = None,
                 sshkey_reference_credential: Optional[pulumi.Input['SecretSshkeySshSshkeyReferenceCredentialArgs']] = None):
        """
        :param pulumi.Input[builtins.str] credential_type: This specifies SSH credential type as Password, KeyPath or KeyReference
        :param pulumi.Input['SecretSshkeySshSshPasswordCredentialArgs'] ssh_password_credential: SSH credential of type keyReference
        :param pulumi.Input['SecretSshkeySshSshkeyPathCredentialArgs'] sshkey_path_credential: SSH credential of type keyPath
        :param pulumi.Input['SecretSshkeySshSshkeyReferenceCredentialArgs'] sshkey_reference_credential: SSH credential of type keyReference
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if ssh_password_credential is not None:
            pulumi.set(__self__, "ssh_password_credential", ssh_password_credential)
        if sshkey_path_credential is not None:
            pulumi.set(__self__, "sshkey_path_credential", sshkey_path_credential)
        if sshkey_reference_credential is not None:
            pulumi.set(__self__, "sshkey_reference_credential", sshkey_reference_credential)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> pulumi.Input[builtins.str]:
        """
        This specifies SSH credential type as Password, KeyPath or KeyReference
        """
        return pulumi.get(self, "credential_type")

    @credential_type.setter
    def credential_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "credential_type", value)

    @property
    @pulumi.getter(name="sshPasswordCredential")
    def ssh_password_credential(self) -> Optional[pulumi.Input['SecretSshkeySshSshPasswordCredentialArgs']]:
        """
        SSH credential of type keyReference
        """
        return pulumi.get(self, "ssh_password_credential")

    @ssh_password_credential.setter
    def ssh_password_credential(self, value: Optional[pulumi.Input['SecretSshkeySshSshPasswordCredentialArgs']]):
        pulumi.set(self, "ssh_password_credential", value)

    @property
    @pulumi.getter(name="sshkeyPathCredential")
    def sshkey_path_credential(self) -> Optional[pulumi.Input['SecretSshkeySshSshkeyPathCredentialArgs']]:
        """
        SSH credential of type keyPath
        """
        return pulumi.get(self, "sshkey_path_credential")

    @sshkey_path_credential.setter
    def sshkey_path_credential(self, value: Optional[pulumi.Input['SecretSshkeySshSshkeyPathCredentialArgs']]):
        pulumi.set(self, "sshkey_path_credential", value)

    @property
    @pulumi.getter(name="sshkeyReferenceCredential")
    def sshkey_reference_credential(self) -> Optional[pulumi.Input['SecretSshkeySshSshkeyReferenceCredentialArgs']]:
        """
        SSH credential of type keyReference
        """
        return pulumi.get(self, "sshkey_reference_credential")

    @sshkey_reference_credential.setter
    def sshkey_reference_credential(self, value: Optional[pulumi.Input['SecretSshkeySshSshkeyReferenceCredentialArgs']]):
        pulumi.set(self, "sshkey_reference_credential", value)


if not MYPY:
    class SecretSshkeySshSshPasswordCredentialArgsDict(TypedDict):
        password: pulumi.Input[builtins.str]
        """
        SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        user_name: pulumi.Input[builtins.str]
        """
        SSH Username.
        """
elif False:
    SecretSshkeySshSshPasswordCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeySshSshPasswordCredentialArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[builtins.str],
                 user_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password: SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        :param pulumi.Input[builtins.str] user_name: SSH Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[builtins.str]:
        """
        SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[builtins.str]:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_name", value)


if not MYPY:
    class SecretSshkeySshSshkeyPathCredentialArgsDict(TypedDict):
        key_path: pulumi.Input[builtins.str]
        """
        Path of the key file.
        """
        user_name: pulumi.Input[builtins.str]
        """
        SSH Username.
        """
        encrypted_passphrase: NotRequired[pulumi.Input[builtins.str]]
        """
        Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
elif False:
    SecretSshkeySshSshkeyPathCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeySshSshkeyPathCredentialArgs:
    def __init__(__self__, *,
                 key_path: pulumi.Input[builtins.str],
                 user_name: pulumi.Input[builtins.str],
                 encrypted_passphrase: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key_path: Path of the key file.
        :param pulumi.Input[builtins.str] user_name: SSH Username.
        :param pulumi.Input[builtins.str] encrypted_passphrase: Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        pulumi.set(__self__, "key_path", key_path)
        pulumi.set(__self__, "user_name", user_name)
        if encrypted_passphrase is not None:
            pulumi.set(__self__, "encrypted_passphrase", encrypted_passphrase)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> pulumi.Input[builtins.str]:
        """
        Path of the key file.
        """
        return pulumi.get(self, "key_path")

    @key_path.setter
    def key_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key_path", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[builtins.str]:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter(name="encryptedPassphrase")
    def encrypted_passphrase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "encrypted_passphrase")

    @encrypted_passphrase.setter
    def encrypted_passphrase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encrypted_passphrase", value)


if not MYPY:
    class SecretSshkeySshSshkeyReferenceCredentialArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        user_name: pulumi.Input[builtins.str]
        """
        SSH Username.
        """
        encrypted_passphrase: NotRequired[pulumi.Input[builtins.str]]
        """
        Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
elif False:
    SecretSshkeySshSshkeyReferenceCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretSshkeySshSshkeyReferenceCredentialArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 user_name: pulumi.Input[builtins.str],
                 encrypted_passphrase: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] key: SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
        :param pulumi.Input[builtins.str] user_name: SSH Username.
        :param pulumi.Input[builtins.str] encrypted_passphrase: Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "user_name", user_name)
        if encrypted_passphrase is not None:
            pulumi.set(__self__, "encrypted_passphrase", encrypted_passphrase)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> pulumi.Input[builtins.str]:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter(name="encryptedPassphrase")
    def encrypted_passphrase(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "encrypted_passphrase")

    @encrypted_passphrase.setter
    def encrypted_passphrase(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encrypted_passphrase", value)


if not MYPY:
    class SecretTextAdditionalMetadataArgsDict(TypedDict):
        values: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecretTextAdditionalMetadataValueArgsDict']]]]
elif False:
    SecretTextAdditionalMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretTextAdditionalMetadataArgs:
    def __init__(__self__, *,
                 values: Optional[pulumi.Input[Sequence[pulumi.Input['SecretTextAdditionalMetadataValueArgs']]]] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecretTextAdditionalMetadataValueArgs']]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecretTextAdditionalMetadataValueArgs']]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class SecretTextAdditionalMetadataValueArgsDict(TypedDict):
        version: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SecretTextAdditionalMetadataValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretTextAdditionalMetadataValueArgs:
    def __init__(__self__, *,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class ServiceGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message used for the merge commit.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_harness_code_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the repo is harness code
        """
        is_new_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the branch being created is new
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        load_from_cache: NotRequired[pulumi.Input[builtins.bool]]
        """
        Load service yaml from catch
        """
        load_from_fallback_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        Load service yaml from fallback branch
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    ServiceGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_harness_code_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 is_new_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_cache: Optional[pulumi.Input[builtins.bool]] = None,
                 load_from_fallback_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: Commit message used for the merge commit.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] is_harness_code_repo: If the repo is harness code
        :param pulumi.Input[builtins.bool] is_new_branch: If the branch being created is new
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.bool] load_from_cache: Load service yaml from catch
        :param pulumi.Input[builtins.bool] load_from_fallback_branch: Load service yaml from fallback branch
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the repo is harness code
        """
        return pulumi.get(self, "is_harness_code_repo")

    @is_harness_code_repo.setter
    def is_harness_code_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harness_code_repo", value)

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the branch being created is new
        """
        return pulumi.get(self, "is_new_branch")

    @is_new_branch.setter
    def is_new_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_new_branch", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Load service yaml from catch
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class ServiceNowConnectorAuthArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        Authentication types for Jira connector
        """
        adfs: NotRequired[pulumi.Input['ServiceNowConnectorAuthAdfsArgsDict']]
        """
        Authenticate using adfs client credentials with certificate.
        """
        refresh_token: NotRequired[pulumi.Input['ServiceNowConnectorAuthRefreshTokenArgsDict']]
        """
        Authenticate using refresh token grant type.
        """
        username_password: NotRequired[pulumi.Input['ServiceNowConnectorAuthUsernamePasswordArgsDict']]
        """
        Authenticate using username password.
        """
elif False:
    ServiceNowConnectorAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNowConnectorAuthArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 adfs: Optional[pulumi.Input['ServiceNowConnectorAuthAdfsArgs']] = None,
                 refresh_token: Optional[pulumi.Input['ServiceNowConnectorAuthRefreshTokenArgs']] = None,
                 username_password: Optional[pulumi.Input['ServiceNowConnectorAuthUsernamePasswordArgs']] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: Authentication types for Jira connector
        :param pulumi.Input['ServiceNowConnectorAuthAdfsArgs'] adfs: Authenticate using adfs client credentials with certificate.
        :param pulumi.Input['ServiceNowConnectorAuthRefreshTokenArgs'] refresh_token: Authenticate using refresh token grant type.
        :param pulumi.Input['ServiceNowConnectorAuthUsernamePasswordArgs'] username_password: Authenticate using username password.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if adfs is not None:
            pulumi.set(__self__, "adfs", adfs)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        Authentication types for Jira connector
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter
    def adfs(self) -> Optional[pulumi.Input['ServiceNowConnectorAuthAdfsArgs']]:
        """
        Authenticate using adfs client credentials with certificate.
        """
        return pulumi.get(self, "adfs")

    @adfs.setter
    def adfs(self, value: Optional[pulumi.Input['ServiceNowConnectorAuthAdfsArgs']]):
        pulumi.set(self, "adfs", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input['ServiceNowConnectorAuthRefreshTokenArgs']]:
        """
        Authenticate using refresh token grant type.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input['ServiceNowConnectorAuthRefreshTokenArgs']]):
        pulumi.set(self, "refresh_token", value)

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional[pulumi.Input['ServiceNowConnectorAuthUsernamePasswordArgs']]:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_password")

    @username_password.setter
    def username_password(self, value: Optional[pulumi.Input['ServiceNowConnectorAuthUsernamePasswordArgs']]):
        pulumi.set(self, "username_password", value)


if not MYPY:
    class ServiceNowConnectorAuthAdfsArgsDict(TypedDict):
        adfs_url: pulumi.Input[builtins.str]
        """
        asdf URL.
        """
        certificate_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        client_id_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        private_key_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        resource_id_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ServiceNowConnectorAuthAdfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNowConnectorAuthAdfsArgs:
    def __init__(__self__, *,
                 adfs_url: pulumi.Input[builtins.str],
                 certificate_ref: pulumi.Input[builtins.str],
                 client_id_ref: pulumi.Input[builtins.str],
                 private_key_ref: pulumi.Input[builtins.str],
                 resource_id_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] adfs_url: asdf URL.
        :param pulumi.Input[builtins.str] certificate_ref: Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] client_id_ref: Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] private_key_ref: Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] resource_id_ref: Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "adfs_url", adfs_url)
        pulumi.set(__self__, "certificate_ref", certificate_ref)
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        pulumi.set(__self__, "resource_id_ref", resource_id_ref)

    @property
    @pulumi.getter(name="adfsUrl")
    def adfs_url(self) -> pulumi.Input[builtins.str]:
        """
        asdf URL.
        """
        return pulumi.get(self, "adfs_url")

    @adfs_url.setter
    def adfs_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "adfs_url", value)

    @property
    @pulumi.getter(name="certificateRef")
    def certificate_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "certificate_ref")

    @certificate_ref.setter
    def certificate_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "certificate_ref", value)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @client_id_ref.setter
    def client_id_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id_ref", value)

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @private_key_ref.setter
    def private_key_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "private_key_ref", value)

    @property
    @pulumi.getter(name="resourceIdRef")
    def resource_id_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "resource_id_ref")

    @resource_id_ref.setter
    def resource_id_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_id_ref", value)


if not MYPY:
    class ServiceNowConnectorAuthRefreshTokenArgsDict(TypedDict):
        client_id_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        refresh_token_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        token_url: pulumi.Input[builtins.str]
        """
        Token url to use for authentication.
        """
        client_secret_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        scope: NotRequired[pulumi.Input[builtins.str]]
        """
        Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ServiceNowConnectorAuthRefreshTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNowConnectorAuthRefreshTokenArgs:
    def __init__(__self__, *,
                 client_id_ref: pulumi.Input[builtins.str],
                 refresh_token_ref: pulumi.Input[builtins.str],
                 token_url: pulumi.Input[builtins.str],
                 client_secret_ref: Optional[pulumi.Input[builtins.str]] = None,
                 scope: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id_ref: Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] refresh_token_ref: Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] token_url: Token url to use for authentication.
        :param pulumi.Input[builtins.str] client_secret_ref: Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] scope: Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "refresh_token_ref", refresh_token_ref)
        pulumi.set(__self__, "token_url", token_url)
        if client_secret_ref is not None:
            pulumi.set(__self__, "client_secret_ref", client_secret_ref)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @client_id_ref.setter
    def client_id_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "client_id_ref", value)

    @property
    @pulumi.getter(name="refreshTokenRef")
    def refresh_token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "refresh_token_ref")

    @refresh_token_ref.setter
    def refresh_token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "refresh_token_ref", value)

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> pulumi.Input[builtins.str]:
        """
        Token url to use for authentication.
        """
        return pulumi.get(self, "token_url")

    @token_url.setter
    def token_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "token_url", value)

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")

    @client_secret_ref.setter
    def client_secret_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_secret_ref", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class ServiceNowConnectorAuthUsernamePasswordArgsDict(TypedDict):
        password_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    ServiceNowConnectorAuthUsernamePasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceNowConnectorAuthUsernamePasswordArgs:
    def __init__(__self__, *,
                 password_ref: pulumi.Input[builtins.str],
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class ServiceOverridesV2GitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message used for the merge commit.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_harness_code_repo: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the repo is in harness code
        """
        is_new_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        If the branch being created is new
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating override.
        """
        load_from_cache: NotRequired[pulumi.Input[builtins.bool]]
        """
        Load service yaml from catch
        """
        load_from_fallback_branch: NotRequired[pulumi.Input[builtins.bool]]
        """
        Load service yaml from fallback branch
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    ServiceOverridesV2GitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceOverridesV2GitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_harness_code_repo: Optional[pulumi.Input[builtins.bool]] = None,
                 is_new_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 load_from_cache: Optional[pulumi.Input[builtins.bool]] = None,
                 load_from_fallback_branch: Optional[pulumi.Input[builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: Commit message used for the merge commit.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.bool] is_harness_code_repo: If the repo is in harness code
        :param pulumi.Input[builtins.bool] is_new_branch: If the branch being created is new
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating override.
        :param pulumi.Input[builtins.bool] load_from_cache: Load service yaml from catch
        :param pulumi.Input[builtins.bool] load_from_fallback_branch: Load service yaml from fallback branch
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the repo is in harness code
        """
        return pulumi.get(self, "is_harness_code_repo")

    @is_harness_code_repo.setter
    def is_harness_code_repo(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_harness_code_repo", value)

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If the branch being created is new
        """
        return pulumi.get(self, "is_new_branch")

    @is_new_branch.setter
    def is_new_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_new_branch", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Load service yaml from catch
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class SloRequestArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name for the SLO.
        """
        slo_target: pulumi.Input['SloRequestSloTargetArgsDict']
        """
        SLO Target specification.
        """
        spec: pulumi.Input[builtins.str]
        """
        Specification of the SLO.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the SLO.
        """
        user_journey_refs: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        User journey reference list for the SLO.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description for the SLO.
        """
        notification_rule_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input['SloRequestNotificationRuleRefArgsDict']]]]
        """
        Notification rule references for the SLO.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags for the SLO. comma-separated key value string pairs.
        """
elif False:
    SloRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 slo_target: pulumi.Input['SloRequestSloTargetArgs'],
                 spec: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 user_journey_refs: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 description: Optional[pulumi.Input[builtins.str]] = None,
                 notification_rule_refs: Optional[pulumi.Input[Sequence[pulumi.Input['SloRequestNotificationRuleRefArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] name: Name for the SLO.
        :param pulumi.Input['SloRequestSloTargetArgs'] slo_target: SLO Target specification.
        :param pulumi.Input[builtins.str] spec: Specification of the SLO.
        :param pulumi.Input[builtins.str] type: Type of the SLO.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] user_journey_refs: User journey reference list for the SLO.
        :param pulumi.Input[builtins.str] description: Description for the SLO.
        :param pulumi.Input[Sequence[pulumi.Input['SloRequestNotificationRuleRefArgs']]] notification_rule_refs: Notification rule references for the SLO.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags for the SLO. comma-separated key value string pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slo_target", slo_target)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_journey_refs", user_journey_refs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if notification_rule_refs is not None:
            pulumi.set(__self__, "notification_rule_refs", notification_rule_refs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name for the SLO.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sloTarget")
    def slo_target(self) -> pulumi.Input['SloRequestSloTargetArgs']:
        """
        SLO Target specification.
        """
        return pulumi.get(self, "slo_target")

    @slo_target.setter
    def slo_target(self, value: pulumi.Input['SloRequestSloTargetArgs']):
        pulumi.set(self, "slo_target", value)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input[builtins.str]:
        """
        Specification of the SLO.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the SLO.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="userJourneyRefs")
    def user_journey_refs(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        User journey reference list for the SLO.
        """
        return pulumi.get(self, "user_journey_refs")

    @user_journey_refs.setter
    def user_journey_refs(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "user_journey_refs", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description for the SLO.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="notificationRuleRefs")
    def notification_rule_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SloRequestNotificationRuleRefArgs']]]]:
        """
        Notification rule references for the SLO.
        """
        return pulumi.get(self, "notification_rule_refs")

    @notification_rule_refs.setter
    def notification_rule_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SloRequestNotificationRuleRefArgs']]]]):
        pulumi.set(self, "notification_rule_refs", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags for the SLO. comma-separated key value string pairs.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SloRequestNotificationRuleRefArgsDict(TypedDict):
        enabled: pulumi.Input[builtins.bool]
        """
        Enable or disable notification rule reference for the SLO.
        """
        notification_rule_ref: pulumi.Input[builtins.str]
        """
        Notification rule reference for the SLO.
        """
elif False:
    SloRequestNotificationRuleRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestNotificationRuleRefArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[builtins.bool],
                 notification_rule_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.bool] enabled: Enable or disable notification rule reference for the SLO.
        :param pulumi.Input[builtins.str] notification_rule_ref: Notification rule reference for the SLO.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "notification_rule_ref", notification_rule_ref)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[builtins.bool]:
        """
        Enable or disable notification rule reference for the SLO.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="notificationRuleRef")
    def notification_rule_ref(self) -> pulumi.Input[builtins.str]:
        """
        Notification rule reference for the SLO.
        """
        return pulumi.get(self, "notification_rule_ref")

    @notification_rule_ref.setter
    def notification_rule_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "notification_rule_ref", value)


if not MYPY:
    class SloRequestSloTargetArgsDict(TypedDict):
        slo_target_percentage: pulumi.Input[builtins.float]
        """
        Target percentage for the SLO.
        """
        spec: pulumi.Input[builtins.str]
        """
        Specification of the SLO Target.
        """
        type: pulumi.Input[builtins.str]
        """
        Type of the SLO target.
        """
elif False:
    SloRequestSloTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloRequestSloTargetArgs:
    def __init__(__self__, *,
                 slo_target_percentage: pulumi.Input[builtins.float],
                 spec: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.float] slo_target_percentage: Target percentage for the SLO.
        :param pulumi.Input[builtins.str] spec: Specification of the SLO Target.
        :param pulumi.Input[builtins.str] type: Type of the SLO target.
        """
        pulumi.set(__self__, "slo_target_percentage", slo_target_percentage)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sloTargetPercentage")
    def slo_target_percentage(self) -> pulumi.Input[builtins.float]:
        """
        Target percentage for the SLO.
        """
        return pulumi.get(self, "slo_target_percentage")

    @slo_target_percentage.setter
    def slo_target_percentage(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "slo_target_percentage", value)

    @property
    @pulumi.getter
    def spec(self) -> pulumi.Input[builtins.str]:
        """
        Specification of the SLO Target.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "spec", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type of the SLO target.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SpotConnectorPermanentTokenArgsDict(TypedDict):
        api_token_ref: pulumi.Input[builtins.str]
        """
        Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        delegate_selectors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Connect only using delegates with these tags.
        """
        execute_on_delegate: NotRequired[pulumi.Input[builtins.bool]]
        """
        Execute on delegate or not.
        """
        spot_account_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Spot account id.
        """
        spot_account_id_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    SpotConnectorPermanentTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpotConnectorPermanentTokenArgs:
    def __init__(__self__, *,
                 api_token_ref: pulumi.Input[builtins.str],
                 delegate_selectors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 execute_on_delegate: Optional[pulumi.Input[builtins.bool]] = None,
                 spot_account_id: Optional[pulumi.Input[builtins.str]] = None,
                 spot_account_id_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api_token_ref: Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] delegate_selectors: Connect only using delegates with these tags.
        :param pulumi.Input[builtins.bool] execute_on_delegate: Execute on delegate or not.
        :param pulumi.Input[builtins.str] spot_account_id: Spot account id.
        :param pulumi.Input[builtins.str] spot_account_id_ref: Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "api_token_ref", api_token_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if execute_on_delegate is not None:
            pulumi.set(__self__, "execute_on_delegate", execute_on_delegate)
        if spot_account_id is not None:
            pulumi.set(__self__, "spot_account_id", spot_account_id)
        if spot_account_id_ref is not None:
            pulumi.set(__self__, "spot_account_id_ref", spot_account_id_ref)

    @property
    @pulumi.getter(name="apiTokenRef")
    def api_token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "api_token_ref")

    @api_token_ref.setter
    def api_token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_token_ref", value)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Connect only using delegates with these tags.
        """
        return pulumi.get(self, "delegate_selectors")

    @delegate_selectors.setter
    def delegate_selectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "delegate_selectors", value)

    @property
    @pulumi.getter(name="executeOnDelegate")
    def execute_on_delegate(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Execute on delegate or not.
        """
        return pulumi.get(self, "execute_on_delegate")

    @execute_on_delegate.setter
    def execute_on_delegate(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "execute_on_delegate", value)

    @property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Spot account id.
        """
        return pulumi.get(self, "spot_account_id")

    @spot_account_id.setter
    def spot_account_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spot_account_id", value)

    @property
    @pulumi.getter(name="spotAccountIdRef")
    def spot_account_id_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "spot_account_id_ref")

    @spot_account_id_ref.setter
    def spot_account_id_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spot_account_id_ref", value)


if not MYPY:
    class TasConnectorCredentialsArgsDict(TypedDict):
        tas_manual_details: pulumi.Input['TasConnectorCredentialsTasManualDetailsArgsDict']
        """
        Authenticate to Tas using manual details.
        """
        type: pulumi.Input[builtins.str]
        """
        Type can be ManualConfig.
        """
elif False:
    TasConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TasConnectorCredentialsArgs:
    def __init__(__self__, *,
                 tas_manual_details: pulumi.Input['TasConnectorCredentialsTasManualDetailsArgs'],
                 type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input['TasConnectorCredentialsTasManualDetailsArgs'] tas_manual_details: Authenticate to Tas using manual details.
        :param pulumi.Input[builtins.str] type: Type can be ManualConfig.
        """
        pulumi.set(__self__, "tas_manual_details", tas_manual_details)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="tasManualDetails")
    def tas_manual_details(self) -> pulumi.Input['TasConnectorCredentialsTasManualDetailsArgs']:
        """
        Authenticate to Tas using manual details.
        """
        return pulumi.get(self, "tas_manual_details")

    @tas_manual_details.setter
    def tas_manual_details(self, value: pulumi.Input['TasConnectorCredentialsTasManualDetailsArgs']):
        pulumi.set(self, "tas_manual_details", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        Type can be ManualConfig.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TasConnectorCredentialsTasManualDetailsArgsDict(TypedDict):
        endpoint_url: pulumi.Input[builtins.str]
        """
        URL of the Tas server.
        """
        password_ref: pulumi.Input[builtins.str]
        """
        Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        reference_token: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference of the secret for the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        username: NotRequired[pulumi.Input[builtins.str]]
        """
        Username to use for authentication.
        """
        username_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    TasConnectorCredentialsTasManualDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TasConnectorCredentialsTasManualDetailsArgs:
    def __init__(__self__, *,
                 endpoint_url: pulumi.Input[builtins.str],
                 password_ref: pulumi.Input[builtins.str],
                 reference_token: Optional[pulumi.Input[builtins.str]] = None,
                 username: Optional[pulumi.Input[builtins.str]] = None,
                 username_ref: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] endpoint_url: URL of the Tas server.
        :param pulumi.Input[builtins.str] password_ref: Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] reference_token: Reference of the secret for the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}
        :param pulumi.Input[builtins.str] username: Username to use for authentication.
        :param pulumi.Input[builtins.str] username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "endpoint_url", endpoint_url)
        pulumi.set(__self__, "password_ref", password_ref)
        if reference_token is not None:
            pulumi.set(__self__, "reference_token", reference_token)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> pulumi.Input[builtins.str]:
        """
        URL of the Tas server.
        """
        return pulumi.get(self, "endpoint_url")

    @endpoint_url.setter
    def endpoint_url(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "endpoint_url", value)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter(name="referenceToken")
    def reference_token(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference of the secret for the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "reference_token")

    @reference_token.setter
    def reference_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "reference_token", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")

    @username_ref.setter
    def username_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "username_ref", value)


if not MYPY:
    class TemplateFiltersFilterPropertiesArgsDict(TypedDict):
        filter_type: pulumi.Input[builtins.str]
        """
        Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
elif False:
    TemplateFiltersFilterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateFiltersFilterPropertiesArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[builtins.str],
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] filter_type: Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[builtins.str]:
        """
        Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class TemplateGitDetailsArgsDict(TypedDict):
        base_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        commit_message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message used for the merge commit.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        last_commit_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
        store_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    TemplateGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: Optional[pulumi.Input[builtins.str]] = None,
                 branch_name: Optional[pulumi.Input[builtins.str]] = None,
                 commit_message: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 last_commit_id: Optional[pulumi.Input[builtins.str]] = None,
                 last_object_id: Optional[pulumi.Input[builtins.str]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None,
                 store_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param pulumi.Input[builtins.str] branch_name: Name of the branch.
        :param pulumi.Input[builtins.str] commit_message: Commit message used for the merge commit.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.str] last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        :param pulumi.Input[builtins.str] store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class TemplateGitImportDetailsArgsDict(TypedDict):
        branch_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the branch.
        """
        connector_ref: NotRequired[pulumi.Input[builtins.str]]
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        File path of the Entity in the repository.
        """
        is_force_import: NotRequired[pulumi.Input[builtins.bool]]
        repo_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the repository.
        """
elif False:
    TemplateGitImportDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateGitImportDetailsArgs:
    def __init__(__self__, *,
                 branch_name: Optional[pulumi.Input[builtins.str]] = None,
                 connector_ref: Optional[pulumi.Input[builtins.str]] = None,
                 file_path: Optional[pulumi.Input[builtins.str]] = None,
                 is_force_import: Optional[pulumi.Input[builtins.bool]] = None,
                 repo_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] branch_name: Name of the branch.
        :param pulumi.Input[builtins.str] connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param pulumi.Input[builtins.str] file_path: File path of the Entity in the repository.
        :param pulumi.Input[builtins.str] repo_name: Name of the repository.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "is_force_import")

    @is_force_import.setter
    def is_force_import(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "is_force_import", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class TemplateTemplateImportRequestArgsDict(TypedDict):
        template_description: NotRequired[pulumi.Input[builtins.str]]
        """
        Description of the template.
        """
        template_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Name of the template.
        """
        template_version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of the template.
        """
elif False:
    TemplateTemplateImportRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TemplateTemplateImportRequestArgs:
    def __init__(__self__, *,
                 template_description: Optional[pulumi.Input[builtins.str]] = None,
                 template_name: Optional[pulumi.Input[builtins.str]] = None,
                 template_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] template_description: Description of the template.
        :param pulumi.Input[builtins.str] template_name: Name of the template.
        :param pulumi.Input[builtins.str] template_version: Version of the template.
        """
        if template_description is not None:
            pulumi.set(__self__, "template_description", template_description)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)
        if template_version is not None:
            pulumi.set(__self__, "template_version", template_version)

    @property
    @pulumi.getter(name="templateDescription")
    def template_description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Description of the template.
        """
        return pulumi.get(self, "template_description")

    @template_description.setter
    def template_description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_description", value)

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Name of the template.
        """
        return pulumi.get(self, "template_name")

    @template_name.setter
    def template_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_name", value)

    @property
    @pulumi.getter(name="templateVersion")
    def template_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of the template.
        """
        return pulumi.get(self, "template_version")

    @template_version.setter
    def template_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "template_version", value)


if not MYPY:
    class TerraformCloudConnectorCredentialsArgsDict(TypedDict):
        api_token: pulumi.Input['TerraformCloudConnectorCredentialsApiTokenArgsDict']
        """
        API token credentials to use for authentication.
        """
elif False:
    TerraformCloudConnectorCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TerraformCloudConnectorCredentialsArgs:
    def __init__(__self__, *,
                 api_token: pulumi.Input['TerraformCloudConnectorCredentialsApiTokenArgs']):
        """
        :param pulumi.Input['TerraformCloudConnectorCredentialsApiTokenArgs'] api_token: API token credentials to use for authentication.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> pulumi.Input['TerraformCloudConnectorCredentialsApiTokenArgs']:
        """
        API token credentials to use for authentication.
        """
        return pulumi.get(self, "api_token")

    @api_token.setter
    def api_token(self, value: pulumi.Input['TerraformCloudConnectorCredentialsApiTokenArgs']):
        pulumi.set(self, "api_token", value)


if not MYPY:
    class TerraformCloudConnectorCredentialsApiTokenArgsDict(TypedDict):
        api_token_ref: pulumi.Input[builtins.str]
        """
        Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
elif False:
    TerraformCloudConnectorCredentialsApiTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TerraformCloudConnectorCredentialsApiTokenArgs:
    def __init__(__self__, *,
                 api_token_ref: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] api_token_ref: Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "api_token_ref", api_token_ref)

    @property
    @pulumi.getter(name="apiTokenRef")
    def api_token_ref(self) -> pulumi.Input[builtins.str]:
        """
        Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "api_token_ref")

    @api_token_ref.setter
    def api_token_ref(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "api_token_ref", value)


if not MYPY:
    class UserRoleBindingArgsDict(TypedDict):
        managed_role: NotRequired[pulumi.Input[builtins.bool]]
        """
        Managed Role of the user.
        """
        resource_group_identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Group Identifier of the user.
        """
        resource_group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Resource Group Name of the user.
        """
        role_identifier: NotRequired[pulumi.Input[builtins.str]]
        """
        Role Identifier of the user.
        """
        role_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Role Name Identifier of the user.
        """
elif False:
    UserRoleBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserRoleBindingArgs:
    def __init__(__self__, *,
                 managed_role: Optional[pulumi.Input[builtins.bool]] = None,
                 resource_group_identifier: Optional[pulumi.Input[builtins.str]] = None,
                 resource_group_name: Optional[pulumi.Input[builtins.str]] = None,
                 role_identifier: Optional[pulumi.Input[builtins.str]] = None,
                 role_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] managed_role: Managed Role of the user.
        :param pulumi.Input[builtins.str] resource_group_identifier: Resource Group Identifier of the user.
        :param pulumi.Input[builtins.str] resource_group_name: Resource Group Name of the user.
        :param pulumi.Input[builtins.str] role_identifier: Role Identifier of the user.
        :param pulumi.Input[builtins.str] role_name: Role Name Identifier of the user.
        """
        if managed_role is not None:
            pulumi.set(__self__, "managed_role", managed_role)
        if resource_group_identifier is not None:
            pulumi.set(__self__, "resource_group_identifier", resource_group_identifier)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if role_identifier is not None:
            pulumi.set(__self__, "role_identifier", role_identifier)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="managedRole")
    def managed_role(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Managed Role of the user.
        """
        return pulumi.get(self, "managed_role")

    @managed_role.setter
    def managed_role(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "managed_role", value)

    @property
    @pulumi.getter(name="resourceGroupIdentifier")
    def resource_group_identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Group Identifier of the user.
        """
        return pulumi.get(self, "resource_group_identifier")

    @resource_group_identifier.setter
    def resource_group_identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_group_identifier", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Resource Group Name of the user.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="roleIdentifier")
    def role_identifier(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role Identifier of the user.
        """
        return pulumi.get(self, "role_identifier")

    @role_identifier.setter
    def role_identifier(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_identifier", value)

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Role Name Identifier of the user.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "role_name", value)


if not MYPY:
    class UsergroupNotificationConfigArgsDict(TypedDict):
        group_email: NotRequired[pulumi.Input[builtins.str]]
        """
        Group email.
        """
        microsoft_teams_webhook_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Url of Microsoft teams webhook.
        """
        pager_duty_key: NotRequired[pulumi.Input[builtins.str]]
        """
        Pager duty key.
        """
        send_email_to_all_users: NotRequired[pulumi.Input[builtins.bool]]
        """
        Send email to all the group members.
        """
        slack_webhook_url: NotRequired[pulumi.Input[builtins.str]]
        """
        Url of slack webhook.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
elif False:
    UsergroupNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UsergroupNotificationConfigArgs:
    def __init__(__self__, *,
                 group_email: Optional[pulumi.Input[builtins.str]] = None,
                 microsoft_teams_webhook_url: Optional[pulumi.Input[builtins.str]] = None,
                 pager_duty_key: Optional[pulumi.Input[builtins.str]] = None,
                 send_email_to_all_users: Optional[pulumi.Input[builtins.bool]] = None,
                 slack_webhook_url: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group_email: Group email.
        :param pulumi.Input[builtins.str] microsoft_teams_webhook_url: Url of Microsoft teams webhook.
        :param pulumi.Input[builtins.str] pager_duty_key: Pager duty key.
        :param pulumi.Input[builtins.bool] send_email_to_all_users: Send email to all the group members.
        :param pulumi.Input[builtins.str] slack_webhook_url: Url of slack webhook.
        :param pulumi.Input[builtins.str] type: Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        if group_email is not None:
            pulumi.set(__self__, "group_email", group_email)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if pager_duty_key is not None:
            pulumi.set(__self__, "pager_duty_key", pager_duty_key)
        if send_email_to_all_users is not None:
            pulumi.set(__self__, "send_email_to_all_users", send_email_to_all_users)
        if slack_webhook_url is not None:
            pulumi.set(__self__, "slack_webhook_url", slack_webhook_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupEmail")
    def group_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Group email.
        """
        return pulumi.get(self, "group_email")

    @group_email.setter
    def group_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_email", value)

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Url of Microsoft teams webhook.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @microsoft_teams_webhook_url.setter
    def microsoft_teams_webhook_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microsoft_teams_webhook_url", value)

    @property
    @pulumi.getter(name="pagerDutyKey")
    def pager_duty_key(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Pager duty key.
        """
        return pulumi.get(self, "pager_duty_key")

    @pager_duty_key.setter
    def pager_duty_key(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pager_duty_key", value)

    @property
    @pulumi.getter(name="sendEmailToAllUsers")
    def send_email_to_all_users(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Send email to all the group members.
        """
        return pulumi.get(self, "send_email_to_all_users")

    @send_email_to_all_users.setter
    def send_email_to_all_users(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "send_email_to_all_users", value)

    @property
    @pulumi.getter(name="slackWebhookUrl")
    def slack_webhook_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Url of slack webhook.
        """
        return pulumi.get(self, "slack_webhook_url")

    @slack_webhook_url.setter
    def slack_webhook_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "slack_webhook_url", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VariablesSpecArgsDict(TypedDict):
        fixed_value: pulumi.Input[builtins.str]
        """
        FixedValue of the variable
        """
        value_type: pulumi.Input[builtins.str]
        """
        Type of Value of the Variable. For now only FIXED is supported
        """
elif False:
    VariablesSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VariablesSpecArgs:
    def __init__(__self__, *,
                 fixed_value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] fixed_value: FixedValue of the variable
        :param pulumi.Input[builtins.str] value_type: Type of Value of the Variable. For now only FIXED is supported
        """
        pulumi.set(__self__, "fixed_value", fixed_value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> pulumi.Input[builtins.str]:
        """
        FixedValue of the variable
        """
        return pulumi.get(self, "fixed_value")

    @fixed_value.setter
    def fixed_value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "fixed_value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of Value of the Variable. For now only FIXED is supported
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class WorkspaceEnvironmentVariableArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key is the identifier for the variable. Must be unique within the workspace.
        """
        value: pulumi.Input[builtins.str]
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        value_type: pulumi.Input[builtins.str]
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
elif False:
    WorkspaceEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: Key is the identifier for the variable. Must be unique within the workspace.
        :param pulumi.Input[builtins.str] value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param pulumi.Input[builtins.str] value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key is the identifier for the variable. Must be unique within the workspace.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class WorkspaceTerraformVariableArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        Key is the identifier for the variable. Must be unique within the workspace.
        """
        value: pulumi.Input[builtins.str]
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        value_type: pulumi.Input[builtins.str]
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
elif False:
    WorkspaceTerraformVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceTerraformVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 value_type: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: Key is the identifier for the variable. Must be unique within the workspace.
        :param pulumi.Input[builtins.str] value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param pulumi.Input[builtins.str] value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        Key is the identifier for the variable. Must be unique within the workspace.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> pulumi.Input[builtins.str]:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class WorkspaceTerraformVariableFileArgsDict(TypedDict):
        repository: pulumi.Input[builtins.str]
        """
        Repository is the name of the repository to fetch the code from.
        """
        repository_connector: pulumi.Input[builtins.str]
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        repository_branch: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        repository_commit: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        repository_path: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository path is the path in which the variables reside.
        """
        repository_sha: NotRequired[pulumi.Input[builtins.str]]
        """
        Repository commit is SHA to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
elif False:
    WorkspaceTerraformVariableFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkspaceTerraformVariableFileArgs:
    def __init__(__self__, *,
                 repository: pulumi.Input[builtins.str],
                 repository_connector: pulumi.Input[builtins.str],
                 repository_branch: Optional[pulumi.Input[builtins.str]] = None,
                 repository_commit: Optional[pulumi.Input[builtins.str]] = None,
                 repository_path: Optional[pulumi.Input[builtins.str]] = None,
                 repository_sha: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] repository: Repository is the name of the repository to fetch the code from.
        :param pulumi.Input[builtins.str] repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param pulumi.Input[builtins.str] repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param pulumi.Input[builtins.str] repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param pulumi.Input[builtins.str] repository_path: Repository path is the path in which the variables reside.
        :param pulumi.Input[builtins.str] repository_sha: Repository commit is SHA to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_branch is not None:
            pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit is not None:
            pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_path is not None:
            pulumi.set(__self__, "repository_path", repository_path)
        if repository_sha is not None:
            pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[builtins.str]:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> pulumi.Input[builtins.str]:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @repository_connector.setter
    def repository_connector(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "repository_connector", value)

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @repository_branch.setter
    def repository_branch(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_branch", value)

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @repository_commit.setter
    def repository_commit(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_commit", value)

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @repository_path.setter
    def repository_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_path", value)

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Repository commit is SHA to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")

    @repository_sha.setter
    def repository_sha(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "repository_sha", value)


if not MYPY:
    class GetConnectorRancherBearerTokenArgsDict(TypedDict):
        password_ref: builtins.str
        """
        Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        rancher_url: builtins.str
        """
        The URL of the Rancher cluster.
        """
elif False:
    GetConnectorRancherBearerTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetConnectorRancherBearerTokenArgs:
    def __init__(__self__, *,
                 password_ref: builtins.str,
                 rancher_url: builtins.str):
        """
        :param builtins.str password_ref: Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param builtins.str rancher_url: The URL of the Rancher cluster.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "rancher_url", rancher_url)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> builtins.str:
        """
        Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @password_ref.setter
    def password_ref(self, value: builtins.str):
        pulumi.set(self, "password_ref", value)

    @property
    @pulumi.getter(name="rancherUrl")
    def rancher_url(self) -> builtins.str:
        """
        The URL of the Rancher cluster.
        """
        return pulumi.get(self, "rancher_url")

    @rancher_url.setter
    def rancher_url(self, value: builtins.str):
        pulumi.set(self, "rancher_url", value)


if not MYPY:
    class GetDbSchemaChangelogScriptArgsDict(TypedDict):
        command: builtins.str
        """
        Script to clone changeSets
        """
        image: builtins.str
        """
        The fully-qualified name (FQN) of the image
        """
        location: builtins.str
        """
        Path to changeLog file
        """
        shell: builtins.str
        """
        Type of the shell. For example Sh or Bash
        """
elif False:
    GetDbSchemaChangelogScriptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSchemaChangelogScriptArgs:
    def __init__(__self__, *,
                 command: builtins.str,
                 image: builtins.str,
                 location: builtins.str,
                 shell: builtins.str):
        """
        :param builtins.str command: Script to clone changeSets
        :param builtins.str image: The fully-qualified name (FQN) of the image
        :param builtins.str location: Path to changeLog file
        :param builtins.str shell: Type of the shell. For example Sh or Bash
        """
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "shell", shell)

    @property
    @pulumi.getter
    def command(self) -> builtins.str:
        """
        Script to clone changeSets
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: builtins.str):
        pulumi.set(self, "command", value)

    @property
    @pulumi.getter
    def image(self) -> builtins.str:
        """
        The fully-qualified name (FQN) of the image
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: builtins.str):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        Path to changeLog file
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: builtins.str):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def shell(self) -> builtins.str:
        """
        Type of the shell. For example Sh or Bash
        """
        return pulumi.get(self, "shell")

    @shell.setter
    def shell(self, value: builtins.str):
        pulumi.set(self, "shell", value)


if not MYPY:
    class GetDbSchemaSchemaSourceArgsDict(TypedDict):
        archive_path: builtins.str
        """
        If connector type is artifactory, path to the archive file which contains the changeLog
        """
        connector: builtins.str
        """
        Connector to repository at which to find details about the database schema
        """
        location: builtins.str
        """
        The path within the specified repository at which to find details about the database schema
        """
        repo: builtins.str
        """
        If connector url is of account, which repository to connect to using the connector
        """
elif False:
    GetDbSchemaSchemaSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDbSchemaSchemaSourceArgs:
    def __init__(__self__, *,
                 archive_path: builtins.str,
                 connector: builtins.str,
                 location: builtins.str,
                 repo: builtins.str):
        """
        :param builtins.str archive_path: If connector type is artifactory, path to the archive file which contains the changeLog
        :param builtins.str connector: Connector to repository at which to find details about the database schema
        :param builtins.str location: The path within the specified repository at which to find details about the database schema
        :param builtins.str repo: If connector url is of account, which repository to connect to using the connector
        """
        pulumi.set(__self__, "archive_path", archive_path)
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter(name="archivePath")
    def archive_path(self) -> builtins.str:
        """
        If connector type is artifactory, path to the archive file which contains the changeLog
        """
        return pulumi.get(self, "archive_path")

    @archive_path.setter
    def archive_path(self, value: builtins.str):
        pulumi.set(self, "archive_path", value)

    @property
    @pulumi.getter
    def connector(self) -> builtins.str:
        """
        Connector to repository at which to find details about the database schema
        """
        return pulumi.get(self, "connector")

    @connector.setter
    def connector(self, value: builtins.str):
        pulumi.set(self, "connector", value)

    @property
    @pulumi.getter
    def location(self) -> builtins.str:
        """
        The path within the specified repository at which to find details about the database schema
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: builtins.str):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def repo(self) -> builtins.str:
        """
        If connector url is of account, which repository to connect to using the connector
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: builtins.str):
        pulumi.set(self, "repo", value)


if not MYPY:
    class GetEnvironmentClustersMappingClusterArgsDict(TypedDict):
        agent_identifier: NotRequired[builtins.str]
        """
        agent identifier of the cluster (include scope prefix)
        """
        identifier: NotRequired[builtins.str]
        """
        identifier of the cluster
        """
        name: NotRequired[builtins.str]
        """
        name of the cluster
        """
        scope: NotRequired[builtins.str]
        """
        scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
elif False:
    GetEnvironmentClustersMappingClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEnvironmentClustersMappingClusterArgs:
    def __init__(__self__, *,
                 agent_identifier: Optional[builtins.str] = None,
                 identifier: Optional[builtins.str] = None,
                 name: Optional[builtins.str] = None,
                 scope: Optional[builtins.str] = None):
        """
        :param builtins.str agent_identifier: agent identifier of the cluster (include scope prefix)
        :param builtins.str identifier: identifier of the cluster
        :param builtins.str name: name of the cluster
        :param builtins.str scope: scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        if agent_identifier is not None:
            pulumi.set(__self__, "agent_identifier", agent_identifier)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> Optional[builtins.str]:
        """
        agent identifier of the cluster (include scope prefix)
        """
        return pulumi.get(self, "agent_identifier")

    @agent_identifier.setter
    def agent_identifier(self, value: Optional[builtins.str]):
        pulumi.set(self, "agent_identifier", value)

    @property
    @pulumi.getter
    def identifier(self) -> Optional[builtins.str]:
        """
        identifier of the cluster
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: Optional[builtins.str]):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[builtins.str]:
        """
        name of the cluster
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[builtins.str]:
        """
        scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[builtins.str]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class GetEnvironmentGitDetailsArgsDict(TypedDict):
        branch: builtins.str
        """
        Name of the branch.
        """
        load_from_fallback_branch: builtins.bool
        """
        Load environment yaml from fallback branch
        """
        repo_name: builtins.str
        """
        Repo name of remote environment
        """
elif False:
    GetEnvironmentGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEnvironmentGitDetailsArgs:
    def __init__(__self__, *,
                 branch: builtins.str,
                 load_from_fallback_branch: builtins.bool,
                 repo_name: builtins.str):
        """
        :param builtins.str branch: Name of the branch.
        :param builtins.bool load_from_fallback_branch: Load environment yaml from fallback branch
        :param builtins.str repo_name: Repo name of remote environment
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: builtins.str):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> builtins.bool:
        """
        Load environment yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: builtins.bool):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Repo name of remote environment
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class GetGitopsAgentDeployYamlArgocdSettingsArgsDict(TypedDict):
        enable_helm_path_traversal: NotRequired[builtins.bool]
        """
        Controls the Environment variable HELM*SECRETS*VALUES*ALLOW*PATH_TRAVERSAL to allow or deny dot-dot-slash values file paths. Disabled by default for security reasons. This config is pushed as an env variable to the repo-server.
        """
elif False:
    GetGitopsAgentDeployYamlArgocdSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGitopsAgentDeployYamlArgocdSettingsArgs:
    def __init__(__self__, *,
                 enable_helm_path_traversal: Optional[builtins.bool] = None):
        """
        :param builtins.bool enable_helm_path_traversal: Controls the Environment variable HELM*SECRETS*VALUES*ALLOW*PATH_TRAVERSAL to allow or deny dot-dot-slash values file paths. Disabled by default for security reasons. This config is pushed as an env variable to the repo-server.
        """
        if enable_helm_path_traversal is not None:
            pulumi.set(__self__, "enable_helm_path_traversal", enable_helm_path_traversal)

    @property
    @pulumi.getter(name="enableHelmPathTraversal")
    def enable_helm_path_traversal(self) -> Optional[builtins.bool]:
        """
        Controls the Environment variable HELM*SECRETS*VALUES*ALLOW*PATH_TRAVERSAL to allow or deny dot-dot-slash values file paths. Disabled by default for security reasons. This config is pushed as an env variable to the repo-server.
        """
        return pulumi.get(self, "enable_helm_path_traversal")

    @enable_helm_path_traversal.setter
    def enable_helm_path_traversal(self, value: Optional[builtins.bool]):
        pulumi.set(self, "enable_helm_path_traversal", value)


if not MYPY:
    class GetGitopsAgentDeployYamlProxyArgsDict(TypedDict):
        http: NotRequired[builtins.str]
        """
        HTTP proxy settings for the GitOps agent.
        """
        https: NotRequired[builtins.str]
        """
        HTTPS proxy settings for the GitOps agent.
        """
        password: NotRequired[builtins.str]
        """
        Password for the proxy.
        """
        username: NotRequired[builtins.str]
        """
        Username for the proxy.
        """
elif False:
    GetGitopsAgentDeployYamlProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGitopsAgentDeployYamlProxyArgs:
    def __init__(__self__, *,
                 http: Optional[builtins.str] = None,
                 https: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        :param builtins.str http: HTTP proxy settings for the GitOps agent.
        :param builtins.str https: HTTPS proxy settings for the GitOps agent.
        :param builtins.str password: Password for the proxy.
        :param builtins.str username: Username for the proxy.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def http(self) -> Optional[builtins.str]:
        """
        HTTP proxy settings for the GitOps agent.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[builtins.str]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[builtins.str]:
        """
        HTTPS proxy settings for the GitOps agent.
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[builtins.str]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Password for the proxy.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Username for the proxy.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetGitopsAgentOperatorYamlProxyArgsDict(TypedDict):
        http: NotRequired[builtins.str]
        """
        HTTP proxy settings for the GitOps agent.
        """
        https: NotRequired[builtins.str]
        """
        HTTPS proxy settings for the GitOps agent.
        """
        password: NotRequired[builtins.str]
        """
        Password for the proxy.
        """
        username: NotRequired[builtins.str]
        """
        Username for the proxy.
        """
elif False:
    GetGitopsAgentOperatorYamlProxyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGitopsAgentOperatorYamlProxyArgs:
    def __init__(__self__, *,
                 http: Optional[builtins.str] = None,
                 https: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        :param builtins.str http: HTTP proxy settings for the GitOps agent.
        :param builtins.str https: HTTPS proxy settings for the GitOps agent.
        :param builtins.str password: Password for the proxy.
        :param builtins.str username: Username for the proxy.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def http(self) -> Optional[builtins.str]:
        """
        HTTP proxy settings for the GitOps agent.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[builtins.str]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def https(self) -> Optional[builtins.str]:
        """
        HTTPS proxy settings for the GitOps agent.
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[builtins.str]):
        pulumi.set(self, "https", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        Password for the proxy.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        Username for the proxy.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetGitopsGnupgRequestArgsDict(TypedDict):
        publickeys: NotRequired[Sequence['GetGitopsGnupgRequestPublickeyArgsDict']]
        """
        Public key details.
        """
        upsert: NotRequired[builtins.bool]
        """
        Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
elif False:
    GetGitopsGnupgRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGitopsGnupgRequestArgs:
    def __init__(__self__, *,
                 publickeys: Optional[Sequence['GetGitopsGnupgRequestPublickeyArgs']] = None,
                 upsert: Optional[builtins.bool] = None):
        """
        :param Sequence['GetGitopsGnupgRequestPublickeyArgs'] publickeys: Public key details.
        :param builtins.bool upsert: Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        if publickeys is not None:
            pulumi.set(__self__, "publickeys", publickeys)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def publickeys(self) -> Optional[Sequence['GetGitopsGnupgRequestPublickeyArgs']]:
        """
        Public key details.
        """
        return pulumi.get(self, "publickeys")

    @publickeys.setter
    def publickeys(self, value: Optional[Sequence['GetGitopsGnupgRequestPublickeyArgs']]):
        pulumi.set(self, "publickeys", value)

    @property
    @pulumi.getter
    def upsert(self) -> Optional[builtins.bool]:
        """
        Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        return pulumi.get(self, "upsert")

    @upsert.setter
    def upsert(self, value: Optional[builtins.bool]):
        pulumi.set(self, "upsert", value)


if not MYPY:
    class GetGitopsGnupgRequestPublickeyArgsDict(TypedDict):
        fingerprint: NotRequired[builtins.str]
        """
        Fingerprint is the fingerprint of the key
        """
        key_data: NotRequired[builtins.str]
        """
        KeyData holds the raw key data, in base64 encoded format.
        """
        key_id: NotRequired[builtins.str]
        """
        KeyID specifies the key ID, in hexadecimal string format.
        """
        owner: NotRequired[builtins.str]
        """
        Owner holds the owner identification, e.g. a name and e-mail address
        """
        sub_type: NotRequired[builtins.str]
        """
        SubType holds the key's sub type
        """
        trust: NotRequired[builtins.str]
        """
        Trust holds the level of trust assigned to this key
        """
elif False:
    GetGitopsGnupgRequestPublickeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGitopsGnupgRequestPublickeyArgs:
    def __init__(__self__, *,
                 fingerprint: Optional[builtins.str] = None,
                 key_data: Optional[builtins.str] = None,
                 key_id: Optional[builtins.str] = None,
                 owner: Optional[builtins.str] = None,
                 sub_type: Optional[builtins.str] = None,
                 trust: Optional[builtins.str] = None):
        """
        :param builtins.str fingerprint: Fingerprint is the fingerprint of the key
        :param builtins.str key_data: KeyData holds the raw key data, in base64 encoded format.
        :param builtins.str key_id: KeyID specifies the key ID, in hexadecimal string format.
        :param builtins.str owner: Owner holds the owner identification, e.g. a name and e-mail address
        :param builtins.str sub_type: SubType holds the key's sub type
        :param builtins.str trust: Trust holds the level of trust assigned to this key
        """
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)
        if trust is not None:
            pulumi.set(__self__, "trust", trust)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[builtins.str]:
        """
        Fingerprint is the fingerprint of the key
        """
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[builtins.str]):
        pulumi.set(self, "fingerprint", value)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[builtins.str]:
        """
        KeyData holds the raw key data, in base64 encoded format.
        """
        return pulumi.get(self, "key_data")

    @key_data.setter
    def key_data(self, value: Optional[builtins.str]):
        pulumi.set(self, "key_data", value)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[builtins.str]:
        """
        KeyID specifies the key ID, in hexadecimal string format.
        """
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "key_id", value)

    @property
    @pulumi.getter
    def owner(self) -> Optional[builtins.str]:
        """
        Owner holds the owner identification, e.g. a name and e-mail address
        """
        return pulumi.get(self, "owner")

    @owner.setter
    def owner(self, value: Optional[builtins.str]):
        pulumi.set(self, "owner", value)

    @property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[builtins.str]:
        """
        SubType holds the key's sub type
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "sub_type", value)

    @property
    @pulumi.getter
    def trust(self) -> Optional[builtins.str]:
        """
        Trust holds the level of trust assigned to this key
        """
        return pulumi.get(self, "trust")

    @trust.setter
    def trust(self, value: Optional[builtins.str]):
        pulumi.set(self, "trust", value)


if not MYPY:
    class GetGitopsRepoCredCredArgsDict(TypedDict):
        enable_oci: builtins.bool
        """
        Specifies whether helm-oci support should be enabled for this repo.
        """
        github_app_enterprise_base_url: builtins.str
        """
        Specifies the GitHub API URL for GitHub app authentication.
        """
        github_app_id: builtins.str
        """
        Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        """
        github_app_installation_id: builtins.str
        """
        Specifies the ID of the installed GitHub App for GitHub app authentication.
        """
        github_app_private_key: builtins.str
        """
        github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        """
        password: builtins.str
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        ssh_private_key: builtins.str
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        tls_client_cert_data: builtins.str
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        tls_client_cert_key: builtins.str
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        type: builtins.str
        """
        Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        """
        url: builtins.str
        """
        URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        """
        username: builtins.str
        """
        Username to be used for authenticating the remote repository.
        """
elif False:
    GetGitopsRepoCredCredArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGitopsRepoCredCredArgs:
    def __init__(__self__, *,
                 enable_oci: builtins.bool,
                 github_app_enterprise_base_url: builtins.str,
                 github_app_id: builtins.str,
                 github_app_installation_id: builtins.str,
                 github_app_private_key: builtins.str,
                 password: builtins.str,
                 ssh_private_key: builtins.str,
                 tls_client_cert_data: builtins.str,
                 tls_client_cert_key: builtins.str,
                 type: builtins.str,
                 url: builtins.str,
                 username: builtins.str):
        """
        :param builtins.bool enable_oci: Specifies whether helm-oci support should be enabled for this repo.
        :param builtins.str github_app_enterprise_base_url: Specifies the GitHub API URL for GitHub app authentication.
        :param builtins.str github_app_id: Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        :param builtins.str github_app_installation_id: Specifies the ID of the installed GitHub App for GitHub app authentication.
        :param builtins.str github_app_private_key: github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        :param builtins.str password: Password or PAT to be used for authenticating the remote repository.
        :param builtins.str ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param builtins.str tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        :param builtins.str tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        :param builtins.str type: Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        :param builtins.str url: URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        :param builtins.str username: Username to be used for authenticating the remote repository.
        """
        pulumi.set(__self__, "enable_oci", enable_oci)
        pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        pulumi.set(__self__, "github_app_id", github_app_id)
        pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> builtins.bool:
        """
        Specifies whether helm-oci support should be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @enable_oci.setter
    def enable_oci(self, value: builtins.bool):
        pulumi.set(self, "enable_oci", value)

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> builtins.str:
        """
        Specifies the GitHub API URL for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @github_app_enterprise_base_url.setter
    def github_app_enterprise_base_url(self, value: builtins.str):
        pulumi.set(self, "github_app_enterprise_base_url", value)

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> builtins.str:
        """
        Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_id")

    @github_app_id.setter
    def github_app_id(self, value: builtins.str):
        pulumi.set(self, "github_app_id", value)

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> builtins.str:
        """
        Specifies the ID of the installed GitHub App for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_installation_id")

    @github_app_installation_id.setter
    def github_app_installation_id(self, value: builtins.str):
        pulumi.set(self, "github_app_installation_id", value)

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> builtins.str:
        """
        github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        """
        return pulumi.get(self, "github_app_private_key")

    @github_app_private_key.setter
    def github_app_private_key(self, value: builtins.str):
        pulumi.set(self, "github_app_private_key", value)

    @property
    @pulumi.getter
    def password(self) -> builtins.str:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: builtins.str):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> builtins.str:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @ssh_private_key.setter
    def ssh_private_key(self, value: builtins.str):
        pulumi.set(self, "ssh_private_key", value)

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> builtins.str:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @tls_client_cert_data.setter
    def tls_client_cert_data(self, value: builtins.str):
        pulumi.set(self, "tls_client_cert_data", value)

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> builtins.str:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @tls_client_cert_key.setter
    def tls_client_cert_key(self, value: builtins.str):
        pulumi.set(self, "tls_client_cert_key", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: builtins.str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> builtins.str:
        """
        URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: builtins.str):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: builtins.str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetHarRegistryConfigArgsDict(TypedDict):
        type: builtins.str
        """
        Type of registry (VIRTUAL, UPSTREAM)
        """
        auths: NotRequired[Sequence['GetHarRegistryConfigAuthArgsDict']]
        """
        Authentication configuration for UPSTREAM type
        """
        source: NotRequired[builtins.str]
        """
        Source of the upstream
        """
        url: NotRequired[builtins.str]
        """
        URL of the upstream
        """
elif False:
    GetHarRegistryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHarRegistryConfigArgs:
    def __init__(__self__, *,
                 type: builtins.str,
                 auths: Optional[Sequence['GetHarRegistryConfigAuthArgs']] = None,
                 source: Optional[builtins.str] = None,
                 url: Optional[builtins.str] = None):
        """
        :param builtins.str type: Type of registry (VIRTUAL, UPSTREAM)
        :param Sequence['GetHarRegistryConfigAuthArgs'] auths: Authentication configuration for UPSTREAM type
        :param builtins.str source: Source of the upstream
        :param builtins.str url: URL of the upstream
        """
        pulumi.set(__self__, "type", type)
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of registry (VIRTUAL, UPSTREAM)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: builtins.str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def auths(self) -> Optional[Sequence['GetHarRegistryConfigAuthArgs']]:
        """
        Authentication configuration for UPSTREAM type
        """
        return pulumi.get(self, "auths")

    @auths.setter
    def auths(self, value: Optional[Sequence['GetHarRegistryConfigAuthArgs']]):
        pulumi.set(self, "auths", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[builtins.str]:
        """
        Source of the upstream
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[builtins.str]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[builtins.str]:
        """
        URL of the upstream
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetHarRegistryConfigAuthArgsDict(TypedDict):
        auth_type: builtins.str
        """
        Type of authentication (UserPassword, Anonymous)
        """
        user_password: NotRequired['GetHarRegistryConfigAuthUserPasswordArgsDict']
        """
        User password authentication details
        """
elif False:
    GetHarRegistryConfigAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHarRegistryConfigAuthArgs:
    def __init__(__self__, *,
                 auth_type: builtins.str,
                 user_password: Optional['GetHarRegistryConfigAuthUserPasswordArgs'] = None):
        """
        :param builtins.str auth_type: Type of authentication (UserPassword, Anonymous)
        :param 'GetHarRegistryConfigAuthUserPasswordArgs' user_password: User password authentication details
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> builtins.str:
        """
        Type of authentication (UserPassword, Anonymous)
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: builtins.str):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional['GetHarRegistryConfigAuthUserPasswordArgs']:
        """
        User password authentication details
        """
        return pulumi.get(self, "user_password")

    @user_password.setter
    def user_password(self, value: Optional['GetHarRegistryConfigAuthUserPasswordArgs']):
        pulumi.set(self, "user_password", value)


if not MYPY:
    class GetHarRegistryConfigAuthUserPasswordArgsDict(TypedDict):
        user_name: builtins.str
        """
        User name
        """
        secret_identifier: NotRequired[builtins.str]
        """
        Secret identifier
        """
        secret_space_id: NotRequired[builtins.int]
        """
        Secret space ID
        """
        secret_space_path: NotRequired[builtins.str]
        """
        Secret space path
        """
elif False:
    GetHarRegistryConfigAuthUserPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetHarRegistryConfigAuthUserPasswordArgs:
    def __init__(__self__, *,
                 user_name: builtins.str,
                 secret_identifier: Optional[builtins.str] = None,
                 secret_space_id: Optional[builtins.int] = None,
                 secret_space_path: Optional[builtins.str] = None):
        """
        :param builtins.str user_name: User name
        :param builtins.str secret_identifier: Secret identifier
        :param builtins.int secret_space_id: Secret space ID
        :param builtins.str secret_space_path: Secret space path
        """
        pulumi.set(__self__, "user_name", user_name)
        if secret_identifier is not None:
            pulumi.set(__self__, "secret_identifier", secret_identifier)
        if secret_space_id is not None:
            pulumi.set(__self__, "secret_space_id", secret_space_id)
        if secret_space_path is not None:
            pulumi.set(__self__, "secret_space_path", secret_space_path)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> builtins.str:
        """
        User name
        """
        return pulumi.get(self, "user_name")

    @user_name.setter
    def user_name(self, value: builtins.str):
        pulumi.set(self, "user_name", value)

    @property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[builtins.str]:
        """
        Secret identifier
        """
        return pulumi.get(self, "secret_identifier")

    @secret_identifier.setter
    def secret_identifier(self, value: Optional[builtins.str]):
        pulumi.set(self, "secret_identifier", value)

    @property
    @pulumi.getter(name="secretSpaceId")
    def secret_space_id(self) -> Optional[builtins.int]:
        """
        Secret space ID
        """
        return pulumi.get(self, "secret_space_id")

    @secret_space_id.setter
    def secret_space_id(self, value: Optional[builtins.int]):
        pulumi.set(self, "secret_space_id", value)

    @property
    @pulumi.getter(name="secretSpacePath")
    def secret_space_path(self) -> Optional[builtins.str]:
        """
        Secret space path
        """
        return pulumi.get(self, "secret_space_path")

    @secret_space_path.setter
    def secret_space_path(self, value: Optional[builtins.str]):
        pulumi.set(self, "secret_space_path", value)


if not MYPY:
    class GetInfraVariableSetConnectorArgsDict(TypedDict):
        connector_ref: builtins.str
        """
        Unique identifier of the connector.
        """
        type: builtins.str
        """
        Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
elif False:
    GetInfraVariableSetConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfraVariableSetConnectorArgs:
    def __init__(__self__, *,
                 connector_ref: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str connector_ref: Unique identifier of the connector.
        :param builtins.str type: Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> builtins.str:
        """
        Unique identifier of the connector.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: builtins.str):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: builtins.str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetInfraVariableSetEnvironmentVariableArgsDict(TypedDict):
        key: builtins.str
        """
        Key is the identifier for the variable`
        """
        value: builtins.str
        """
        value is the value of the variable
        """
        value_type: builtins.str
        """
        Value type indicates the value type of the variable, text or secret
        """
elif False:
    GetInfraVariableSetEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfraVariableSetEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 value_type: builtins.str):
        """
        :param builtins.str key: Key is the identifier for the variable`
        :param builtins.str value: value is the value of the variable
        :param builtins.str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: builtins.str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: builtins.str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> builtins.str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: builtins.str):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class GetInfraVariableSetTerraformVariableArgsDict(TypedDict):
        key: builtins.str
        """
        Key is the identifier for the variable`
        """
        value: builtins.str
        """
        value is the value of the variable
        """
        value_type: builtins.str
        """
        Value type indicates the value type of the variable, text or secret
        """
elif False:
    GetInfraVariableSetTerraformVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfraVariableSetTerraformVariableArgs:
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 value_type: builtins.str):
        """
        :param builtins.str key: Key is the identifier for the variable`
        :param builtins.str value: value is the value of the variable
        :param builtins.str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: builtins.str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: builtins.str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> builtins.str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: builtins.str):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class GetInfraVariableSetTerraformVariableFileArgsDict(TypedDict):
        repository: builtins.str
        """
        Repository is the name of the repository to fetch the code from.
        """
        repository_connector: builtins.str
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        repository_branch: NotRequired[builtins.str]
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        repository_commit: NotRequired[builtins.str]
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        repository_path: NotRequired[builtins.str]
        """
        Repository path is the path in which the variables reside.
        """
        repository_sha: NotRequired[builtins.str]
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
elif False:
    GetInfraVariableSetTerraformVariableFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfraVariableSetTerraformVariableFileArgs:
    def __init__(__self__, *,
                 repository: builtins.str,
                 repository_connector: builtins.str,
                 repository_branch: Optional[builtins.str] = None,
                 repository_commit: Optional[builtins.str] = None,
                 repository_path: Optional[builtins.str] = None,
                 repository_sha: Optional[builtins.str] = None):
        """
        :param builtins.str repository: Repository is the name of the repository to fetch the code from.
        :param builtins.str repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param builtins.str repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param builtins.str repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param builtins.str repository_path: Repository path is the path in which the variables reside.
        :param builtins.str repository_sha: Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_branch is not None:
            pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit is not None:
            pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_path is not None:
            pulumi.set(__self__, "repository_path", repository_path)
        if repository_sha is not None:
            pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> builtins.str:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: builtins.str):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> builtins.str:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @repository_connector.setter
    def repository_connector(self, value: builtins.str):
        pulumi.set(self, "repository_connector", value)

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> Optional[builtins.str]:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @repository_branch.setter
    def repository_branch(self, value: Optional[builtins.str]):
        pulumi.set(self, "repository_branch", value)

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> Optional[builtins.str]:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @repository_commit.setter
    def repository_commit(self, value: Optional[builtins.str]):
        pulumi.set(self, "repository_commit", value)

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> Optional[builtins.str]:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @repository_path.setter
    def repository_path(self, value: Optional[builtins.str]):
        pulumi.set(self, "repository_path", value)

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> Optional[builtins.str]:
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")

    @repository_sha.setter
    def repository_sha(self, value: Optional[builtins.str]):
        pulumi.set(self, "repository_sha", value)


if not MYPY:
    class GetInfrastructureGitDetailsArgsDict(TypedDict):
        branch: builtins.str
        """
        Name of the branch.
        """
        load_from_cache: builtins.str
        """
        If the Entity is to be fetched from cache
        """
        load_from_fallback_branch: builtins.bool
        """
        Load Infrastructure yaml from fallback branch
        """
        repo_name: builtins.str
        """
        Repo name of remote Infrastructure
        """
elif False:
    GetInfrastructureGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInfrastructureGitDetailsArgs:
    def __init__(__self__, *,
                 branch: builtins.str,
                 load_from_cache: builtins.str,
                 load_from_fallback_branch: builtins.bool,
                 repo_name: builtins.str):
        """
        :param builtins.str branch: Name of the branch.
        :param builtins.str load_from_cache: If the Entity is to be fetched from cache
        :param builtins.bool load_from_fallback_branch: Load Infrastructure yaml from fallback branch
        :param builtins.str repo_name: Repo name of remote Infrastructure
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_cache", load_from_cache)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: builtins.str):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> builtins.str:
        """
        If the Entity is to be fetched from cache
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: builtins.str):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> builtins.bool:
        """
        Load Infrastructure yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: builtins.bool):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Repo name of remote Infrastructure
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class GetInputSetGitDetailsArgsDict(TypedDict):
        base_branch: builtins.str
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch_name: builtins.str
        """
        Name of the branch.
        """
        commit_message: builtins.str
        """
        Commit message used for the merge commit.
        """
        connector_ref: builtins.str
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity.
        """
        file_path: builtins.str
        """
        File path of the Entity in the repository.
        """
        last_commit_id: builtins.str
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: builtins.str
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        parent_entity_connector_ref: builtins.str
        """
        Connector reference for Parent Entity (Pipeline).
        """
        parent_entity_repo_name: builtins.str
        """
        Repository name for Parent Entity (Pipeline).
        """
        repo_name: builtins.str
        """
        Name of the repository.
        """
        store_type: builtins.str
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    GetInputSetGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetInputSetGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: builtins.str,
                 branch_name: builtins.str,
                 commit_message: builtins.str,
                 connector_ref: builtins.str,
                 file_path: builtins.str,
                 last_commit_id: builtins.str,
                 last_object_id: builtins.str,
                 parent_entity_connector_ref: builtins.str,
                 parent_entity_repo_name: builtins.str,
                 repo_name: builtins.str,
                 store_type: builtins.str):
        """
        :param builtins.str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param builtins.str branch_name: Name of the branch.
        :param builtins.str commit_message: Commit message used for the merge commit.
        :param builtins.str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity.
        :param builtins.str file_path: File path of the Entity in the repository.
        :param builtins.str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param builtins.str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param builtins.str parent_entity_connector_ref: Connector reference for Parent Entity (Pipeline).
        :param builtins.str parent_entity_repo_name: Repository name for Parent Entity (Pipeline).
        :param builtins.str repo_name: Name of the repository.
        :param builtins.str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        pulumi.set(__self__, "base_branch", base_branch)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "commit_message", commit_message)
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "file_path", file_path)
        pulumi.set(__self__, "last_commit_id", last_commit_id)
        pulumi.set(__self__, "last_object_id", last_object_id)
        pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        pulumi.set(__self__, "repo_name", repo_name)
        pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> builtins.str:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: builtins.str):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: builtins.str):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> builtins.str:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: builtins.str):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> builtins.str:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: builtins.str):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> builtins.str:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: builtins.str):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> builtins.str:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: builtins.str):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> builtins.str:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: builtins.str):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> builtins.str:
        """
        Connector reference for Parent Entity (Pipeline).
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @parent_entity_connector_ref.setter
    def parent_entity_connector_ref(self, value: builtins.str):
        pulumi.set(self, "parent_entity_connector_ref", value)

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> builtins.str:
        """
        Repository name for Parent Entity (Pipeline).
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @parent_entity_repo_name.setter
    def parent_entity_repo_name(self, value: builtins.str):
        pulumi.set(self, "parent_entity_repo_name", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> builtins.str:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: builtins.str):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class GetOverridesGitDetailsArgsDict(TypedDict):
        branch: builtins.str
        """
        Name of the branch.
        """
        load_from_cache: builtins.bool
        """
        Load service yaml from fallback branch
        """
        load_from_fallback_branch: builtins.bool
        """
        Load service yaml from fallback branch
        """
        repo_name: builtins.str
        """
        Repo name of remote service override
        """
elif False:
    GetOverridesGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOverridesGitDetailsArgs:
    def __init__(__self__, *,
                 branch: builtins.str,
                 load_from_cache: builtins.bool,
                 load_from_fallback_branch: builtins.bool,
                 repo_name: builtins.str):
        """
        :param builtins.str branch: Name of the branch.
        :param builtins.bool load_from_cache: Load service yaml from fallback branch
        :param builtins.bool load_from_fallback_branch: Load service yaml from fallback branch
        :param builtins.str repo_name: Repo name of remote service override
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_cache", load_from_cache)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: builtins.str):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> builtins.bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: builtins.bool):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> builtins.bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: builtins.bool):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Repo name of remote service override
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class GetPipelineGitDetailsArgsDict(TypedDict):
        base_branch: builtins.str
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        branch_name: builtins.str
        """
        Name of the branch.
        """
        commit_message: builtins.str
        """
        Commit message used for the merge commit.
        """
        connector_ref: builtins.str
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity.
        """
        file_path: builtins.str
        """
        File path of the Entity in the repository.
        """
        last_commit_id: builtins.str
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: builtins.str
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        repo_name: builtins.str
        """
        Name of the repository.
        """
        store_type: builtins.str
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
elif False:
    GetPipelineGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPipelineGitDetailsArgs:
    def __init__(__self__, *,
                 base_branch: builtins.str,
                 branch_name: builtins.str,
                 commit_message: builtins.str,
                 connector_ref: builtins.str,
                 file_path: builtins.str,
                 last_commit_id: builtins.str,
                 last_object_id: builtins.str,
                 repo_name: builtins.str,
                 store_type: builtins.str):
        """
        :param builtins.str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param builtins.str branch_name: Name of the branch.
        :param builtins.str commit_message: Commit message used for the merge commit.
        :param builtins.str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity.
        :param builtins.str file_path: File path of the Entity in the repository.
        :param builtins.str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param builtins.str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param builtins.str repo_name: Name of the repository.
        :param builtins.str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        pulumi.set(__self__, "base_branch", base_branch)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "commit_message", commit_message)
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "file_path", file_path)
        pulumi.set(__self__, "last_commit_id", last_commit_id)
        pulumi.set(__self__, "last_object_id", last_object_id)
        pulumi.set(__self__, "repo_name", repo_name)
        pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> builtins.str:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @base_branch.setter
    def base_branch(self, value: builtins.str):
        pulumi.set(self, "base_branch", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: builtins.str):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> builtins.str:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @commit_message.setter
    def commit_message(self, value: builtins.str):
        pulumi.set(self, "commit_message", value)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> builtins.str:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity.
        """
        return pulumi.get(self, "connector_ref")

    @connector_ref.setter
    def connector_ref(self, value: builtins.str):
        pulumi.set(self, "connector_ref", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> builtins.str:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: builtins.str):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> builtins.str:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: builtins.str):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> builtins.str:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: builtins.str):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> builtins.str:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")

    @store_type.setter
    def store_type(self, value: builtins.str):
        pulumi.set(self, "store_type", value)


if not MYPY:
    class GetPolicySetPolicyArgsDict(TypedDict):
        identifier: builtins.str
        """
        Account Identifier of the account
        """
        severity: builtins.str
        """
        Policy failure response - 'warning' for continuation, 'error' for exit
        """
elif False:
    GetPolicySetPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPolicySetPolicyArgs:
    def __init__(__self__, *,
                 identifier: builtins.str,
                 severity: builtins.str):
        """
        :param builtins.str identifier: Account Identifier of the account
        :param builtins.str severity: Policy failure response - 'warning' for continuation, 'error' for exit
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def identifier(self) -> builtins.str:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "identifier")

    @identifier.setter
    def identifier(self, value: builtins.str):
        pulumi.set(self, "identifier", value)

    @property
    @pulumi.getter
    def severity(self) -> builtins.str:
        """
        Policy failure response - 'warning' for continuation, 'error' for exit
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: builtins.str):
        pulumi.set(self, "severity", value)


if not MYPY:
    class GetRepoRuleBranchBypassArgsDict(TypedDict):
        repo_owners: NotRequired[builtins.bool]
        """
        Allow users with repository edit permission to bypass.
        """
        user_ids: NotRequired[Sequence[builtins.str]]
        """
        List of user ids with who can bypass.
        """
elif False:
    GetRepoRuleBranchBypassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepoRuleBranchBypassArgs:
    def __init__(__self__, *,
                 repo_owners: Optional[builtins.bool] = None,
                 user_ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool repo_owners: Allow users with repository edit permission to bypass.
        :param Sequence[builtins.str] user_ids: List of user ids with who can bypass.
        """
        if repo_owners is not None:
            pulumi.set(__self__, "repo_owners", repo_owners)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="repoOwners")
    def repo_owners(self) -> Optional[builtins.bool]:
        """
        Allow users with repository edit permission to bypass.
        """
        return pulumi.get(self, "repo_owners")

    @repo_owners.setter
    def repo_owners(self, value: Optional[builtins.bool]):
        pulumi.set(self, "repo_owners", value)

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of user ids with who can bypass.
        """
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class GetRepoRuleBranchPatternArgsDict(TypedDict):
        default_branch: NotRequired[builtins.bool]
        """
        Should rule apply to default branch of the repository.
        """
        excludes: NotRequired[Sequence[builtins.str]]
        """
        Globstar branch patterns on which rules will NOT be applied.
        """
        includes: NotRequired[Sequence[builtins.str]]
        """
        Globstar branch patterns on which rules will be applied.
        """
elif False:
    GetRepoRuleBranchPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepoRuleBranchPatternArgs:
    def __init__(__self__, *,
                 default_branch: Optional[builtins.bool] = None,
                 excludes: Optional[Sequence[builtins.str]] = None,
                 includes: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool default_branch: Should rule apply to default branch of the repository.
        :param Sequence[builtins.str] excludes: Globstar branch patterns on which rules will NOT be applied.
        :param Sequence[builtins.str] includes: Globstar branch patterns on which rules will be applied.
        """
        if default_branch is not None:
            pulumi.set(__self__, "default_branch", default_branch)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> Optional[builtins.bool]:
        """
        Should rule apply to default branch of the repository.
        """
        return pulumi.get(self, "default_branch")

    @default_branch.setter
    def default_branch(self, value: Optional[builtins.bool]):
        pulumi.set(self, "default_branch", value)

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[builtins.str]]:
        """
        Globstar branch patterns on which rules will NOT be applied.
        """
        return pulumi.get(self, "excludes")

    @excludes.setter
    def excludes(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "excludes", value)

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[builtins.str]]:
        """
        Globstar branch patterns on which rules will be applied.
        """
        return pulumi.get(self, "includes")

    @includes.setter
    def includes(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "includes", value)


if not MYPY:
    class GetRepoRuleBranchPolicyArgsDict(TypedDict):
        allow_merge_strategies: NotRequired[Sequence[builtins.str]]
        """
        Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        """
        block_branch_creation: NotRequired[builtins.bool]
        """
        Only allow users with bypass permission to create matching branches.
        """
        block_branch_deletion: NotRequired[builtins.bool]
        """
        Only allow users with bypass permission to delete matching branches.
        """
        delete_branch_on_merge: NotRequired[builtins.bool]
        """
        Automatically delete the source branch of a pull request after it is merged.
        """
        require_code_owners: NotRequired[builtins.bool]
        """
        Require approval on pull requests from one reviewer for each codeowner rule.
        """
        require_latest_commit_approval: NotRequired[builtins.bool]
        """
        Require re-approval when there are new changes in the pull request.
        """
        require_minimum_approval_count: NotRequired[builtins.int]
        """
        Require approval on pull requests from a minimum number of reviewers.
        """
        require_no_change_request: NotRequired[builtins.bool]
        """
        Require all request for changes have been resolved.
        """
        require_pull_request: NotRequired[builtins.bool]
        """
        Do not allow any changes to matching branches without a pull request.
        """
        require_resolve_all_comments: NotRequired[builtins.bool]
        """
        All comments on a pull request must be resolved before it can be merged.
        """
        require_status_checks: NotRequired[Sequence[builtins.str]]
        """
        Selected status checks must pass before a pull request can be merged.
        """
elif False:
    GetRepoRuleBranchPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepoRuleBranchPolicyArgs:
    def __init__(__self__, *,
                 allow_merge_strategies: Optional[Sequence[builtins.str]] = None,
                 block_branch_creation: Optional[builtins.bool] = None,
                 block_branch_deletion: Optional[builtins.bool] = None,
                 delete_branch_on_merge: Optional[builtins.bool] = None,
                 require_code_owners: Optional[builtins.bool] = None,
                 require_latest_commit_approval: Optional[builtins.bool] = None,
                 require_minimum_approval_count: Optional[builtins.int] = None,
                 require_no_change_request: Optional[builtins.bool] = None,
                 require_pull_request: Optional[builtins.bool] = None,
                 require_resolve_all_comments: Optional[builtins.bool] = None,
                 require_status_checks: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] allow_merge_strategies: Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        :param builtins.bool block_branch_creation: Only allow users with bypass permission to create matching branches.
        :param builtins.bool block_branch_deletion: Only allow users with bypass permission to delete matching branches.
        :param builtins.bool delete_branch_on_merge: Automatically delete the source branch of a pull request after it is merged.
        :param builtins.bool require_code_owners: Require approval on pull requests from one reviewer for each codeowner rule.
        :param builtins.bool require_latest_commit_approval: Require re-approval when there are new changes in the pull request.
        :param builtins.int require_minimum_approval_count: Require approval on pull requests from a minimum number of reviewers.
        :param builtins.bool require_no_change_request: Require all request for changes have been resolved.
        :param builtins.bool require_pull_request: Do not allow any changes to matching branches without a pull request.
        :param builtins.bool require_resolve_all_comments: All comments on a pull request must be resolved before it can be merged.
        :param Sequence[builtins.str] require_status_checks: Selected status checks must pass before a pull request can be merged.
        """
        if allow_merge_strategies is not None:
            pulumi.set(__self__, "allow_merge_strategies", allow_merge_strategies)
        if block_branch_creation is not None:
            pulumi.set(__self__, "block_branch_creation", block_branch_creation)
        if block_branch_deletion is not None:
            pulumi.set(__self__, "block_branch_deletion", block_branch_deletion)
        if delete_branch_on_merge is not None:
            pulumi.set(__self__, "delete_branch_on_merge", delete_branch_on_merge)
        if require_code_owners is not None:
            pulumi.set(__self__, "require_code_owners", require_code_owners)
        if require_latest_commit_approval is not None:
            pulumi.set(__self__, "require_latest_commit_approval", require_latest_commit_approval)
        if require_minimum_approval_count is not None:
            pulumi.set(__self__, "require_minimum_approval_count", require_minimum_approval_count)
        if require_no_change_request is not None:
            pulumi.set(__self__, "require_no_change_request", require_no_change_request)
        if require_pull_request is not None:
            pulumi.set(__self__, "require_pull_request", require_pull_request)
        if require_resolve_all_comments is not None:
            pulumi.set(__self__, "require_resolve_all_comments", require_resolve_all_comments)
        if require_status_checks is not None:
            pulumi.set(__self__, "require_status_checks", require_status_checks)

    @property
    @pulumi.getter(name="allowMergeStrategies")
    def allow_merge_strategies(self) -> Optional[Sequence[builtins.str]]:
        """
        Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        """
        return pulumi.get(self, "allow_merge_strategies")

    @allow_merge_strategies.setter
    def allow_merge_strategies(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "allow_merge_strategies", value)

    @property
    @pulumi.getter(name="blockBranchCreation")
    def block_branch_creation(self) -> Optional[builtins.bool]:
        """
        Only allow users with bypass permission to create matching branches.
        """
        return pulumi.get(self, "block_branch_creation")

    @block_branch_creation.setter
    def block_branch_creation(self, value: Optional[builtins.bool]):
        pulumi.set(self, "block_branch_creation", value)

    @property
    @pulumi.getter(name="blockBranchDeletion")
    def block_branch_deletion(self) -> Optional[builtins.bool]:
        """
        Only allow users with bypass permission to delete matching branches.
        """
        return pulumi.get(self, "block_branch_deletion")

    @block_branch_deletion.setter
    def block_branch_deletion(self, value: Optional[builtins.bool]):
        pulumi.set(self, "block_branch_deletion", value)

    @property
    @pulumi.getter(name="deleteBranchOnMerge")
    def delete_branch_on_merge(self) -> Optional[builtins.bool]:
        """
        Automatically delete the source branch of a pull request after it is merged.
        """
        return pulumi.get(self, "delete_branch_on_merge")

    @delete_branch_on_merge.setter
    def delete_branch_on_merge(self, value: Optional[builtins.bool]):
        pulumi.set(self, "delete_branch_on_merge", value)

    @property
    @pulumi.getter(name="requireCodeOwners")
    def require_code_owners(self) -> Optional[builtins.bool]:
        """
        Require approval on pull requests from one reviewer for each codeowner rule.
        """
        return pulumi.get(self, "require_code_owners")

    @require_code_owners.setter
    def require_code_owners(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_code_owners", value)

    @property
    @pulumi.getter(name="requireLatestCommitApproval")
    def require_latest_commit_approval(self) -> Optional[builtins.bool]:
        """
        Require re-approval when there are new changes in the pull request.
        """
        return pulumi.get(self, "require_latest_commit_approval")

    @require_latest_commit_approval.setter
    def require_latest_commit_approval(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_latest_commit_approval", value)

    @property
    @pulumi.getter(name="requireMinimumApprovalCount")
    def require_minimum_approval_count(self) -> Optional[builtins.int]:
        """
        Require approval on pull requests from a minimum number of reviewers.
        """
        return pulumi.get(self, "require_minimum_approval_count")

    @require_minimum_approval_count.setter
    def require_minimum_approval_count(self, value: Optional[builtins.int]):
        pulumi.set(self, "require_minimum_approval_count", value)

    @property
    @pulumi.getter(name="requireNoChangeRequest")
    def require_no_change_request(self) -> Optional[builtins.bool]:
        """
        Require all request for changes have been resolved.
        """
        return pulumi.get(self, "require_no_change_request")

    @require_no_change_request.setter
    def require_no_change_request(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_no_change_request", value)

    @property
    @pulumi.getter(name="requirePullRequest")
    def require_pull_request(self) -> Optional[builtins.bool]:
        """
        Do not allow any changes to matching branches without a pull request.
        """
        return pulumi.get(self, "require_pull_request")

    @require_pull_request.setter
    def require_pull_request(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_pull_request", value)

    @property
    @pulumi.getter(name="requireResolveAllComments")
    def require_resolve_all_comments(self) -> Optional[builtins.bool]:
        """
        All comments on a pull request must be resolved before it can be merged.
        """
        return pulumi.get(self, "require_resolve_all_comments")

    @require_resolve_all_comments.setter
    def require_resolve_all_comments(self, value: Optional[builtins.bool]):
        pulumi.set(self, "require_resolve_all_comments", value)

    @property
    @pulumi.getter(name="requireStatusChecks")
    def require_status_checks(self) -> Optional[Sequence[builtins.str]]:
        """
        Selected status checks must pass before a pull request can be merged.
        """
        return pulumi.get(self, "require_status_checks")

    @require_status_checks.setter
    def require_status_checks(self, value: Optional[Sequence[builtins.str]]):
        pulumi.set(self, "require_status_checks", value)


if not MYPY:
    class GetRepoSourceArgsDict(TypedDict):
        host: NotRequired[builtins.str]
        """
        The host URL for the import source.
        """
        password: NotRequired[builtins.str]
        """
        The password for authentication when importing.
        """
        repo: NotRequired[builtins.str]
        """
        The full identifier of the repository on the SCM provider's platform.
        """
        type: NotRequired[builtins.str]
        """
        The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        """
        username: NotRequired[builtins.str]
        """
        The username for authentication when importing.
        """
elif False:
    GetRepoSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRepoSourceArgs:
    def __init__(__self__, *,
                 host: Optional[builtins.str] = None,
                 password: Optional[builtins.str] = None,
                 repo: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None,
                 username: Optional[builtins.str] = None):
        """
        :param builtins.str host: The host URL for the import source.
        :param builtins.str password: The password for authentication when importing.
        :param builtins.str repo: The full identifier of the repository on the SCM provider's platform.
        :param builtins.str type: The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        :param builtins.str username: The username for authentication when importing.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> Optional[builtins.str]:
        """
        The host URL for the import source.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[builtins.str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[builtins.str]:
        """
        The password for authentication when importing.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[builtins.str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[builtins.str]:
        """
        The full identifier of the repository on the SCM provider's platform.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[builtins.str]):
        pulumi.set(self, "repo", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[builtins.str]:
        """
        The username for authentication when importing.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetSecretTextAdditionalMetadataArgsDict(TypedDict):
        values: NotRequired[Sequence['GetSecretTextAdditionalMetadataValueArgsDict']]
elif False:
    GetSecretTextAdditionalMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretTextAdditionalMetadataArgs:
    def __init__(__self__, *,
                 values: Optional[Sequence['GetSecretTextAdditionalMetadataValueArgs']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['GetSecretTextAdditionalMetadataValueArgs']]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Optional[Sequence['GetSecretTextAdditionalMetadataValueArgs']]):
        pulumi.set(self, "values", value)


if not MYPY:
    class GetSecretTextAdditionalMetadataValueArgsDict(TypedDict):
        version: NotRequired[builtins.str]
elif False:
    GetSecretTextAdditionalMetadataValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretTextAdditionalMetadataValueArgs:
    def __init__(__self__, *,
                 version: Optional[builtins.str] = None):
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GetServiceGitDetailsArgsDict(TypedDict):
        branch: builtins.str
        """
        Name of the branch.
        """
        load_from_fallback_branch: builtins.bool
        """
        Load service yaml from fallback branch
        """
        repo_name: builtins.str
        """
        Repo name of remote service
        """
elif False:
    GetServiceGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceGitDetailsArgs:
    def __init__(__self__, *,
                 branch: builtins.str,
                 load_from_fallback_branch: builtins.bool,
                 repo_name: builtins.str):
        """
        :param builtins.str branch: Name of the branch.
        :param builtins.bool load_from_fallback_branch: Load service yaml from fallback branch
        :param builtins.str repo_name: Repo name of remote service
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: builtins.str):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> builtins.bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: builtins.bool):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Repo name of remote service
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class GetServiceOverridesV2GitDetailsArgsDict(TypedDict):
        branch: builtins.str
        """
        Name of the branch.
        """
        load_from_cache: builtins.bool
        """
        Load service yaml from fallback branch
        """
        load_from_fallback_branch: builtins.bool
        """
        Load service yaml from fallback branch
        """
        repo_name: builtins.str
        """
        Repo name of remote service override
        """
elif False:
    GetServiceOverridesV2GitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetServiceOverridesV2GitDetailsArgs:
    def __init__(__self__, *,
                 branch: builtins.str,
                 load_from_cache: builtins.bool,
                 load_from_fallback_branch: builtins.bool,
                 repo_name: builtins.str):
        """
        :param builtins.str branch: Name of the branch.
        :param builtins.bool load_from_cache: Load service yaml from fallback branch
        :param builtins.bool load_from_fallback_branch: Load service yaml from fallback branch
        :param builtins.str repo_name: Repo name of remote service override
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_cache", load_from_cache)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> builtins.str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: builtins.str):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> builtins.bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_cache")

    @load_from_cache.setter
    def load_from_cache(self, value: builtins.bool):
        pulumi.set(self, "load_from_cache", value)

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> builtins.bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @load_from_fallback_branch.setter
    def load_from_fallback_branch(self, value: builtins.bool):
        pulumi.set(self, "load_from_fallback_branch", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> builtins.str:
        """
        Repo name of remote service override
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: builtins.str):
        pulumi.set(self, "repo_name", value)


if not MYPY:
    class GetTemplateGitDetailsArgsDict(TypedDict):
        last_commit_id: builtins.str
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        last_object_id: builtins.str
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        branch_name: NotRequired[builtins.str]
        """
        Name of the branch.
        """
        file_path: NotRequired[builtins.str]
        """
        File path of the Entity in the repository.
        """
        file_url: NotRequired[builtins.str]
        """
        File url of the Entity in the repository.
        """
        repo_name: NotRequired[builtins.str]
        """
        Name of the repository.
        """
        repo_url: NotRequired[builtins.str]
        """
        Repo url of the Entity in the repository.
        """
elif False:
    GetTemplateGitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTemplateGitDetailsArgs:
    def __init__(__self__, *,
                 last_commit_id: builtins.str,
                 last_object_id: builtins.str,
                 branch_name: Optional[builtins.str] = None,
                 file_path: Optional[builtins.str] = None,
                 file_url: Optional[builtins.str] = None,
                 repo_name: Optional[builtins.str] = None,
                 repo_url: Optional[builtins.str] = None):
        """
        :param builtins.str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param builtins.str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param builtins.str branch_name: Name of the branch.
        :param builtins.str file_path: File path of the Entity in the repository.
        :param builtins.str file_url: File url of the Entity in the repository.
        :param builtins.str repo_name: Name of the repository.
        :param builtins.str repo_url: Repo url of the Entity in the repository.
        """
        pulumi.set(__self__, "last_commit_id", last_commit_id)
        pulumi.set(__self__, "last_object_id", last_object_id)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if file_url is not None:
            pulumi.set(__self__, "file_url", file_url)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> builtins.str:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @last_commit_id.setter
    def last_commit_id(self, value: builtins.str):
        pulumi.set(self, "last_commit_id", value)

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> builtins.str:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @last_object_id.setter
    def last_object_id(self, value: builtins.str):
        pulumi.set(self, "last_object_id", value)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[builtins.str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @branch_name.setter
    def branch_name(self, value: Optional[builtins.str]):
        pulumi.set(self, "branch_name", value)

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[builtins.str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @file_path.setter
    def file_path(self, value: Optional[builtins.str]):
        pulumi.set(self, "file_path", value)

    @property
    @pulumi.getter(name="fileUrl")
    def file_url(self) -> Optional[builtins.str]:
        """
        File url of the Entity in the repository.
        """
        return pulumi.get(self, "file_url")

    @file_url.setter
    def file_url(self, value: Optional[builtins.str]):
        pulumi.set(self, "file_url", value)

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[builtins.str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @repo_name.setter
    def repo_name(self, value: Optional[builtins.str]):
        pulumi.set(self, "repo_name", value)

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[builtins.str]:
        """
        Repo url of the Entity in the repository.
        """
        return pulumi.get(self, "repo_url")

    @repo_url.setter
    def repo_url(self, value: Optional[builtins.str]):
        pulumi.set(self, "repo_url", value)


if not MYPY:
    class GetUsergroupNotificationConfigArgsDict(TypedDict):
        group_email: builtins.str
        """
        Group email.
        """
        microsoft_teams_webhook_url: builtins.str
        """
        Url of Microsoft teams webhook.
        """
        pager_duty_key: builtins.str
        """
        Pager duty key.
        """
        send_email_to_all_users: builtins.bool
        """
        Send email to all the group members.
        """
        slack_webhook_url: builtins.str
        """
        Url of slack webhook.
        """
        type: builtins.str
        """
        Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
elif False:
    GetUsergroupNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetUsergroupNotificationConfigArgs:
    def __init__(__self__, *,
                 group_email: builtins.str,
                 microsoft_teams_webhook_url: builtins.str,
                 pager_duty_key: builtins.str,
                 send_email_to_all_users: builtins.bool,
                 slack_webhook_url: builtins.str,
                 type: builtins.str):
        """
        :param builtins.str group_email: Group email.
        :param builtins.str microsoft_teams_webhook_url: Url of Microsoft teams webhook.
        :param builtins.str pager_duty_key: Pager duty key.
        :param builtins.bool send_email_to_all_users: Send email to all the group members.
        :param builtins.str slack_webhook_url: Url of slack webhook.
        :param builtins.str type: Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        pulumi.set(__self__, "group_email", group_email)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "pager_duty_key", pager_duty_key)
        pulumi.set(__self__, "send_email_to_all_users", send_email_to_all_users)
        pulumi.set(__self__, "slack_webhook_url", slack_webhook_url)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupEmail")
    def group_email(self) -> builtins.str:
        """
        Group email.
        """
        return pulumi.get(self, "group_email")

    @group_email.setter
    def group_email(self, value: builtins.str):
        pulumi.set(self, "group_email", value)

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> builtins.str:
        """
        Url of Microsoft teams webhook.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @microsoft_teams_webhook_url.setter
    def microsoft_teams_webhook_url(self, value: builtins.str):
        pulumi.set(self, "microsoft_teams_webhook_url", value)

    @property
    @pulumi.getter(name="pagerDutyKey")
    def pager_duty_key(self) -> builtins.str:
        """
        Pager duty key.
        """
        return pulumi.get(self, "pager_duty_key")

    @pager_duty_key.setter
    def pager_duty_key(self, value: builtins.str):
        pulumi.set(self, "pager_duty_key", value)

    @property
    @pulumi.getter(name="sendEmailToAllUsers")
    def send_email_to_all_users(self) -> builtins.bool:
        """
        Send email to all the group members.
        """
        return pulumi.get(self, "send_email_to_all_users")

    @send_email_to_all_users.setter
    def send_email_to_all_users(self, value: builtins.bool):
        pulumi.set(self, "send_email_to_all_users", value)

    @property
    @pulumi.getter(name="slackWebhookUrl")
    def slack_webhook_url(self) -> builtins.str:
        """
        Url of slack webhook.
        """
        return pulumi.get(self, "slack_webhook_url")

    @slack_webhook_url.setter
    def slack_webhook_url(self, value: builtins.str):
        pulumi.set(self, "slack_webhook_url", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: builtins.str):
        pulumi.set(self, "type", value)


if not MYPY:
    class GetWorkspaceEnvironmentVariableArgsDict(TypedDict):
        key: builtins.str
        """
        Key is the identifier for the variable`
        """
        value: builtins.str
        """
        value is the value of the variable
        """
        value_type: builtins.str
        """
        Value type indicates the value type of the variable, text or secret
        """
elif False:
    GetWorkspaceEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkspaceEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 value_type: builtins.str):
        """
        :param builtins.str key: Key is the identifier for the variable`
        :param builtins.str value: value is the value of the variable
        :param builtins.str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: builtins.str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: builtins.str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> builtins.str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: builtins.str):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class GetWorkspaceTerraformVariableArgsDict(TypedDict):
        key: builtins.str
        """
        Key is the identifier for the variable`
        """
        value: builtins.str
        """
        value is the value of the variable
        """
        value_type: builtins.str
        """
        Value type indicates the value type of the variable, text or secret
        """
elif False:
    GetWorkspaceTerraformVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkspaceTerraformVariableArgs:
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 value_type: builtins.str):
        """
        :param builtins.str key: Key is the identifier for the variable`
        :param builtins.str value: value is the value of the variable
        :param builtins.str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: builtins.str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: builtins.str):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> builtins.str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: builtins.str):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class GetWorkspaceTerraformVariableFileArgsDict(TypedDict):
        repository: builtins.str
        """
        Repository is the name of the repository to fetch the code from.
        """
        repository_branch: builtins.str
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        repository_commit: builtins.str
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        repository_connector: builtins.str
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        repository_path: builtins.str
        """
        Repository path is the path in which the variables reside.
        """
        repository_sha: builtins.str
        """
        Repository commit is SHA to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
elif False:
    GetWorkspaceTerraformVariableFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkspaceTerraformVariableFileArgs:
    def __init__(__self__, *,
                 repository: builtins.str,
                 repository_branch: builtins.str,
                 repository_commit: builtins.str,
                 repository_connector: builtins.str,
                 repository_path: builtins.str,
                 repository_sha: builtins.str):
        """
        :param builtins.str repository: Repository is the name of the repository to fetch the code from.
        :param builtins.str repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param builtins.str repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param builtins.str repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param builtins.str repository_path: Repository path is the path in which the variables reside.
        :param builtins.str repository_sha: Repository commit is SHA to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_branch", repository_branch)
        pulumi.set(__self__, "repository_commit", repository_commit)
        pulumi.set(__self__, "repository_connector", repository_connector)
        pulumi.set(__self__, "repository_path", repository_path)
        pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> builtins.str:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: builtins.str):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> builtins.str:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @repository_branch.setter
    def repository_branch(self, value: builtins.str):
        pulumi.set(self, "repository_branch", value)

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> builtins.str:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @repository_commit.setter
    def repository_commit(self, value: builtins.str):
        pulumi.set(self, "repository_commit", value)

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> builtins.str:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @repository_connector.setter
    def repository_connector(self, value: builtins.str):
        pulumi.set(self, "repository_connector", value)

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> builtins.str:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @repository_path.setter
    def repository_path(self, value: builtins.str):
        pulumi.set(self, "repository_path", value)

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> builtins.str:
        """
        Repository commit is SHA to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")

    @repository_sha.setter
    def repository_sha(self, value: builtins.str):
        pulumi.set(self, "repository_sha", value)


