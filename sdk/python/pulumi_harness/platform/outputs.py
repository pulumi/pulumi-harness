# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AppDynamicsConnectorApiToken',
    'AppDynamicsConnectorUsernamePassword',
    'ArtifactoryConnectorCredentials',
    'AwsCCConnectorCrossAccountAccess',
    'AwsConnectorCrossAccountAccess',
    'AwsConnectorEqualJitterBackoffStrategy',
    'AwsConnectorFixedDelayBackoffStrategy',
    'AwsConnectorFullJitterBackoffStrategy',
    'AwsConnectorInheritFromDelegate',
    'AwsConnectorIrsa',
    'AwsConnectorManual',
    'AwsConnectorOidcAuthentication',
    'AwsKmsConnectorCredentials',
    'AwsKmsConnectorCredentialsAssumeRole',
    'AwsKmsConnectorCredentialsManual',
    'AwsKmsConnectorCredentialsOidcAuthentication',
    'AwsSecretManagerConnectorCredentials',
    'AwsSecretManagerConnectorCredentialsAssumeRole',
    'AwsSecretManagerConnectorCredentialsManual',
    'AwsSecretManagerConnectorCredentialsOidcAuthentication',
    'AzureCloudCostConnectorBillingExportSpec',
    'AzureCloudProviderConnectorCredentials',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth',
    'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa',
    'AzureCloudProviderConnectorCredentialsAzureManualDetails',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert',
    'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey',
    'BitbucketConnectorApiAuthentication',
    'BitbucketConnectorCredentials',
    'BitbucketConnectorCredentialsHttp',
    'BitbucketConnectorCredentialsSsh',
    'ConnectorAzureArtifactsCredentials',
    'ConnectorCustomSecretManagerTemplateInput',
    'ConnectorCustomSecretManagerTemplateInputEnvironmentVariable',
    'ConnectorCustomhealthsourceHeader',
    'ConnectorCustomhealthsourceParam',
    'ConnectorGcpKmsManual',
    'ConnectorGcpKmsOidcAuthentication',
    'ConnectorJdbcCredentials',
    'ConnectorJdbcCredentialsServiceAccount',
    'ConnectorJdbcCredentialsUsernamePassword',
    'ConnectorPdcHost',
    'ConnectorRancherBearerToken',
    'DbSchemaSchemaSource',
    'DockerConnectorCredentials',
    'ElasticsearchConnectorApiToken',
    'ElasticsearchConnectorNoAuthentication',
    'ElasticsearchConnectorUsernamePassword',
    'EnvironmentClustersMappingCluster',
    'EnvironmentGitDetails',
    'FeatureFlagEnvironment',
    'FeatureFlagEnvironmentAddTargetRule',
    'FeatureFlagTag',
    'FeatureFlagTargetGroupRule',
    'FeatureFlagVariation',
    'FileStoreFileCreatedBy',
    'FileStoreFileLastModifiedBy',
    'FileStoreFolderCreatedBy',
    'FileStoreFolderLastModifiedBy',
    'FiltersFilterProperties',
    'GcpCloudCostConnectorBillingExportSpec',
    'GcpConnectorInheritFromDelegate',
    'GcpConnectorManual',
    'GcpConnectorOidcAuthentication',
    'GcpSecretManagerConnectorOidcAuthentication',
    'GitConnectorCredentials',
    'GitConnectorCredentialsHttp',
    'GitConnectorCredentialsSsh',
    'GitOpsAgentMetadata',
    'GitOpsApplicationsApplication',
    'GitOpsApplicationsApplicationMetadata',
    'GitOpsApplicationsApplicationMetadataOwnerReference',
    'GitOpsApplicationsApplicationSpec',
    'GitOpsApplicationsApplicationSpecDestination',
    'GitOpsApplicationsApplicationSpecSource',
    'GitOpsApplicationsApplicationSpecSourceDirectory',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar',
    'GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla',
    'GitOpsApplicationsApplicationSpecSourceHelm',
    'GitOpsApplicationsApplicationSpecSourceHelmFileParameter',
    'GitOpsApplicationsApplicationSpecSourceHelmParameter',
    'GitOpsApplicationsApplicationSpecSourceKsonnet',
    'GitOpsApplicationsApplicationSpecSourceKsonnetParameter',
    'GitOpsApplicationsApplicationSpecSourceKustomize',
    'GitOpsApplicationsApplicationSpecSourcePlugin',
    'GitOpsApplicationsApplicationSpecSourcePluginEnv',
    'GitOpsApplicationsApplicationSpecSyncPolicy',
    'GitOpsApplicationsApplicationSpecSyncPolicyAutomated',
    'GitOpsApplicationsApplicationSpecSyncPolicyRetry',
    'GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff',
    'GitOpsClusterRequest',
    'GitOpsClusterRequestCluster',
    'GitOpsClusterRequestClusterConfig',
    'GitOpsClusterRequestClusterConfigExecProviderConfig',
    'GitOpsClusterRequestClusterConfigTlsClientConfig',
    'GitOpsClusterRequestClusterInfo',
    'GitOpsClusterRequestClusterInfoCacheInfo',
    'GitOpsClusterRequestClusterInfoConnectionState',
    'GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt',
    'GitOpsClusterRequestClusterRefreshRequestedAt',
    'GitOpsGnupgRequest',
    'GitOpsGnupgRequestPublickey',
    'GitOpsRepoCertRequest',
    'GitOpsRepoCertRequestCertificate',
    'GitOpsRepoCertRequestCertificateItem',
    'GitOpsRepoCertRequestCertificateMetadata',
    'GitOpsRepoCredCred',
    'GitOpsRepositoryEcrGen',
    'GitOpsRepositoryEcrGenJwtAuth',
    'GitOpsRepositoryEcrGenSecretRef',
    'GitOpsRepositoryGcrGen',
    'GitOpsRepositoryGcrGenWorkloadIdentity',
    'GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRef',
    'GitOpsRepositoryRepo',
    'GitOpsRepositoryUpdateMask',
    'GithubConnectorApiAuthentication',
    'GithubConnectorApiAuthenticationGithubApp',
    'GithubConnectorCredentials',
    'GithubConnectorCredentialsHttp',
    'GithubConnectorCredentialsHttpAnonymouse',
    'GithubConnectorCredentialsHttpGithubApp',
    'GithubConnectorCredentialsSsh',
    'GitlabConnectorApiAuthentication',
    'GitlabConnectorCredentials',
    'GitlabConnectorCredentialsHttp',
    'GitlabConnectorCredentialsSsh',
    'GitopsAppProjectProject',
    'GitopsAppProjectProjectMetadata',
    'GitopsAppProjectProjectMetadataManagedField',
    'GitopsAppProjectProjectSpec',
    'GitopsAppProjectProjectSpecClusterResourceBlacklist',
    'GitopsAppProjectProjectSpecClusterResourceWhitelist',
    'GitopsAppProjectProjectSpecDestination',
    'GitopsAppProjectProjectSpecNamespaceResourceBlacklist',
    'GitopsAppProjectProjectSpecNamespaceResourceWhitelist',
    'GitopsAppProjectProjectSpecOrphanedResource',
    'GitopsAppProjectProjectSpecOrphanedResourceIgnore',
    'GitopsAppProjectProjectSpecRole',
    'GitopsAppProjectProjectSpecRoleJwtToken',
    'GitopsAppProjectProjectSpecSignatureKey',
    'GitopsAppProjectProjectSpecSyncWindow',
    'HarRegistryConfig',
    'HarRegistryConfigAuth',
    'HarRegistryConfigAuthUserPassword',
    'HelmConnectorCredentials',
    'InfraVariableSetConnector',
    'InfraVariableSetEnvironmentVariable',
    'InfraVariableSetTerraformVariable',
    'InfraVariableSetTerraformVariableFile',
    'InfrastructureGitDetails',
    'InputSetGitDetails',
    'InputSetGitImportInfo',
    'InputSetInputSetImportRequest',
    'JenkinsConnectorAuth',
    'JenkinsConnectorAuthJenkinsBearerToken',
    'JenkinsConnectorAuthJenkinsUserNamePassword',
    'JiraConnectorAuth',
    'JiraConnectorAuthPersonalAccessToken',
    'JiraConnectorAuthUsernamePassword',
    'KubernetesConnectorClientKeyCert',
    'KubernetesConnectorInheritFromDelegate',
    'KubernetesConnectorOpenidConnect',
    'KubernetesConnectorServiceAccount',
    'KubernetesConnectorUsernamePassword',
    'ManualFreezeCurrentOrUpcomingWindow',
    'ManualFreezeFreezeWindow',
    'ManualFreezeFreezeWindowRecurrence',
    'ManualFreezeFreezeWindowRecurrenceRecurrenceSpec',
    'MonitoredServiceRequest',
    'MonitoredServiceRequestChangeSource',
    'MonitoredServiceRequestDependency',
    'MonitoredServiceRequestHealthSource',
    'MonitoredServiceRequestNotificationRuleRef',
    'NexusConnectorCredentials',
    'NotificationRuleRequest',
    'NotificationRuleRequestCondition',
    'NotificationRuleRequestNotificationMethod',
    'OciHelmConnectorCredentials',
    'OverridesGitDetails',
    'PipelineFiltersFilterProperties',
    'PipelineFiltersFilterPropertiesModuleProperties',
    'PipelineFiltersFilterPropertiesModulePropertiesCd',
    'PipelineFiltersFilterPropertiesModulePropertiesCi',
    'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo',
    'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest',
    'PipelineGitDetails',
    'PipelineGitImportInfo',
    'PipelinePipelineImportRequest',
    'PolicySetPolicy',
    'PrometheusConnectorHeader',
    'ProviderSpec',
    'RepoRuleBranchBypass',
    'RepoRuleBranchPattern',
    'RepoRuleBranchPolicy',
    'RepoSource',
    'ResourceGroupIncludedScope',
    'ResourceGroupResourceFilter',
    'ResourceGroupResourceFilterResource',
    'ResourceGroupResourceFilterResourceAttributeFilter',
    'RoleAssignmentsPrincipal',
    'SecretSshkeyKerberos',
    'SecretSshkeyKerberosTgtKeyTabFilePathSpec',
    'SecretSshkeyKerberosTgtPasswordSpec',
    'SecretSshkeySsh',
    'SecretSshkeySshSshPasswordCredential',
    'SecretSshkeySshSshkeyPathCredential',
    'SecretSshkeySshSshkeyReferenceCredential',
    'SecretTextAdditionalMetadata',
    'SecretTextAdditionalMetadataValue',
    'ServiceGitDetails',
    'ServiceNowConnectorAuth',
    'ServiceNowConnectorAuthAdfs',
    'ServiceNowConnectorAuthRefreshToken',
    'ServiceNowConnectorAuthUsernamePassword',
    'ServiceOverridesV2GitDetails',
    'SloRequest',
    'SloRequestNotificationRuleRef',
    'SloRequestSloTarget',
    'SpotConnectorPermanentToken',
    'TasConnectorCredentials',
    'TasConnectorCredentialsTasManualDetails',
    'TemplateFiltersFilterProperties',
    'TemplateGitDetails',
    'TemplateGitImportDetails',
    'TemplateTemplateImportRequest',
    'TerraformCloudConnectorCredentials',
    'TerraformCloudConnectorCredentialsApiToken',
    'UserRoleBinding',
    'UsergroupNotificationConfig',
    'VariablesSpec',
    'WorkspaceEnvironmentVariable',
    'WorkspaceTerraformVariable',
    'WorkspaceTerraformVariableFile',
    'GetAppDynamicsConnectorApiTokenResult',
    'GetAppDynamicsConnectorUsernamePasswordResult',
    'GetArtifactoryConnectorCredentialResult',
    'GetAwsCCConnectorCrossAccountAccessResult',
    'GetAwsConnectorCrossAccountAccessResult',
    'GetAwsConnectorEqualJitterBackoffStrategyResult',
    'GetAwsConnectorFixedDelayBackoffStrategyResult',
    'GetAwsConnectorFullJitterBackoffStrategyResult',
    'GetAwsConnectorInheritFromDelegateResult',
    'GetAwsConnectorIrsaResult',
    'GetAwsConnectorManualResult',
    'GetAwsConnectorOidcAuthenticationResult',
    'GetAwsKmsConnectorCredentialResult',
    'GetAwsKmsConnectorCredentialAssumeRoleResult',
    'GetAwsKmsConnectorCredentialManualResult',
    'GetAwsKmsConnectorCredentialOidcAuthenticationResult',
    'GetAwsSecretManagerConnectorCredentialResult',
    'GetAwsSecretManagerConnectorCredentialAssumeRoleResult',
    'GetAwsSecretManagerConnectorCredentialManualResult',
    'GetAwsSecretManagerConnectorCredentialOidcAuthenticationResult',
    'GetAzureCloudCostConnectorBillingExportSpecResult',
    'GetAzureCloudProviderConnectorCredentialResult',
    'GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailResult',
    'GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthResult',
    'GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUaResult',
    'GetAzureCloudProviderConnectorCredentialAzureManualDetailResult',
    'GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthResult',
    'GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCertResult',
    'GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKeyResult',
    'GetBitbucketConnectorApiAuthenticationResult',
    'GetBitbucketConnectorCredentialResult',
    'GetBitbucketConnectorCredentialHttpResult',
    'GetBitbucketConnectorCredentialSshResult',
    'GetCcmFiltersFilterPropertyResult',
    'GetConnectorCustomSecretManagerTemplateInputResult',
    'GetConnectorCustomSecretManagerTemplateInputEnvironmentVariableResult',
    'GetConnectorCustomhealthsourceHeaderResult',
    'GetConnectorCustomhealthsourceParamResult',
    'GetConnectorGcpKmsManualResult',
    'GetConnectorGcpKmsOidcAuthenticationResult',
    'GetConnectorJdbcCredentialResult',
    'GetConnectorJdbcCredentialServiceAccountResult',
    'GetConnectorJdbcCredentialUsernamePasswordResult',
    'GetConnectorPdcHostResult',
    'GetConnectorRancherBearerTokenResult',
    'GetDbSchemaSchemaSourceResult',
    'GetDockerConnectorCredentialResult',
    'GetElasticsearchConnectorApiTokenResult',
    'GetElasticsearchConnectorUsernamePasswordResult',
    'GetEnvironmentClustersMappingClusterResult',
    'GetEnvironmentGitDetailsResult',
    'GetEnvironmentListEnvironmentResult',
    'GetFileStoreFileCreatedByResult',
    'GetFileStoreFileLastModifiedByResult',
    'GetFileStoreFolderCreatedByResult',
    'GetFileStoreFolderLastModifiedByResult',
    'GetFiltersFilterPropertyResult',
    'GetGcpCloudCostConnectorBillingExportSpecResult',
    'GetGcpConnectorInheritFromDelegateResult',
    'GetGcpConnectorManualResult',
    'GetGcpConnectorOidcAuthenticationResult',
    'GetGcpSecretManagerConnectorOidcAuthenticationResult',
    'GetGitConnectorCredentialResult',
    'GetGitConnectorCredentialHttpResult',
    'GetGitConnectorCredentialSshResult',
    'GetGithubConnectorApiAuthenticationResult',
    'GetGithubConnectorApiAuthenticationGithubAppResult',
    'GetGithubConnectorCredentialResult',
    'GetGithubConnectorCredentialHttpResult',
    'GetGithubConnectorCredentialHttpAnonymouseResult',
    'GetGithubConnectorCredentialHttpGithubAppResult',
    'GetGithubConnectorCredentialSshResult',
    'GetGitlabConnectorApiAuthenticationResult',
    'GetGitlabConnectorCredentialResult',
    'GetGitlabConnectorCredentialHttpResult',
    'GetGitlabConnectorCredentialSshResult',
    'GetGitopsAgentDeployYamlProxyResult',
    'GetGitopsAgentMetadataResult',
    'GetGitopsApplicationsApplicationResult',
    'GetGitopsApplicationsApplicationMetadataResult',
    'GetGitopsApplicationsApplicationMetadataOwnerReferenceResult',
    'GetGitopsApplicationsApplicationSpecResult',
    'GetGitopsApplicationsApplicationSpecDestinationResult',
    'GetGitopsApplicationsApplicationSpecSourceResult',
    'GetGitopsApplicationsApplicationSpecSourceDirectoryResult',
    'GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetResult',
    'GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarResult',
    'GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaResult',
    'GetGitopsApplicationsApplicationSpecSourceHelmResult',
    'GetGitopsApplicationsApplicationSpecSourceHelmFileParameterResult',
    'GetGitopsApplicationsApplicationSpecSourceHelmParameterResult',
    'GetGitopsApplicationsApplicationSpecSourceKsonnetResult',
    'GetGitopsApplicationsApplicationSpecSourceKsonnetParameterResult',
    'GetGitopsApplicationsApplicationSpecSourceKustomizeResult',
    'GetGitopsApplicationsApplicationSpecSourcePluginResult',
    'GetGitopsApplicationsApplicationSpecSourcePluginEnvResult',
    'GetGitopsApplicationsApplicationSpecSyncPolicyResult',
    'GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedResult',
    'GetGitopsApplicationsApplicationSpecSyncPolicyRetryResult',
    'GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffResult',
    'GetGitopsClusterRequestResult',
    'GetGitopsClusterRequestClusterResult',
    'GetGitopsClusterRequestClusterConfigResult',
    'GetGitopsClusterRequestClusterConfigExecProviderConfigResult',
    'GetGitopsClusterRequestClusterConfigTlsClientConfigResult',
    'GetGitopsClusterRequestClusterInfoResult',
    'GetGitopsClusterRequestClusterInfoCacheInfoResult',
    'GetGitopsClusterRequestClusterInfoConnectionStateResult',
    'GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtResult',
    'GetGitopsClusterRequestClusterRefreshRequestedAtResult',
    'GetGitopsGnupgRequestResult',
    'GetGitopsGnupgRequestPublickeyResult',
    'GetGitopsRepoCredCredResult',
    'GetGitopsRepositoryRepoResult',
    'GetHarRegistryConfigResult',
    'GetHarRegistryConfigAuthResult',
    'GetHarRegistryConfigAuthUserPasswordResult',
    'GetHelmConnectorCredentialResult',
    'GetInfraVariableSetConnectorResult',
    'GetInfraVariableSetEnvironmentVariableResult',
    'GetInfraVariableSetTerraformVariableResult',
    'GetInfraVariableSetTerraformVariableFileResult',
    'GetInfrastructureGitDetailsResult',
    'GetInputSetGitDetailsResult',
    'GetJenkinsConnectorAuthResult',
    'GetJenkinsConnectorAuthJenkinsBearerTokenResult',
    'GetJenkinsConnectorAuthJenkinsUserNamePasswordResult',
    'GetJiraConnectorAuthResult',
    'GetJiraConnectorAuthPersonalAccessTokenResult',
    'GetJiraConnectorAuthUsernamePasswordResult',
    'GetKubernetesConnectorClientKeyCertResult',
    'GetKubernetesConnectorInheritFromDelegateResult',
    'GetKubernetesConnectorOpenidConnectResult',
    'GetKubernetesConnectorServiceAccountResult',
    'GetKubernetesConnectorUsernamePasswordResult',
    'GetManualFreezeCurrentOrUpcomingWindowResult',
    'GetManualFreezeFreezeWindowResult',
    'GetManualFreezeFreezeWindowRecurrenceResult',
    'GetManualFreezeFreezeWindowRecurrenceRecurrenceSpecResult',
    'GetNexusConnectorCredentialResult',
    'GetOciHelmConnectorCredentialResult',
    'GetOverridesGitDetailsResult',
    'GetPermissionsPermissionResult',
    'GetPipelineFiltersFilterPropertyResult',
    'GetPipelineFiltersFilterPropertyModulePropertiesResult',
    'GetPipelineFiltersFilterPropertyModulePropertiesCdResult',
    'GetPipelineFiltersFilterPropertyModulePropertiesCiResult',
    'GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoResult',
    'GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoPullRequestResult',
    'GetPipelineGitDetailsResult',
    'GetPipelineListPipelineResult',
    'GetPolicySetPolicyResult',
    'GetProjectListProjectResult',
    'GetPrometheusConnectorHeaderResult',
    'GetRepoRuleBranchBypassResult',
    'GetRepoRuleBranchPatternResult',
    'GetRepoRuleBranchPolicyResult',
    'GetRepoSourceResult',
    'GetResourceGroupIncludedScopeResult',
    'GetResourceGroupResourceFilterResult',
    'GetResourceGroupResourceFilterResourceResult',
    'GetResourceGroupResourceFilterResourceAttributeFilterResult',
    'GetRoleAssignmentsPrincipalResult',
    'GetSecretSshkeyKerberoResult',
    'GetSecretSshkeyKerberoTgtKeyTabFilePathSpecResult',
    'GetSecretSshkeyKerberoTgtPasswordSpecResult',
    'GetSecretSshkeySshResult',
    'GetSecretSshkeySshSshPasswordCredentialResult',
    'GetSecretSshkeySshSshkeyPathCredentialResult',
    'GetSecretSshkeySshSshkeyReferenceCredentialResult',
    'GetSecretTextAdditionalMetadataResult',
    'GetSecretTextAdditionalMetadataValueResult',
    'GetServiceGitDetailsResult',
    'GetServiceListServiceResult',
    'GetServiceNowConnectorAuthResult',
    'GetServiceNowConnectorAuthAdfResult',
    'GetServiceNowConnectorAuthRefreshTokenResult',
    'GetServiceNowConnectorAuthUsernamePasswordResult',
    'GetServiceOverridesV2GitDetailsResult',
    'GetSpotConnectorPermanentTokenResult',
    'GetTasConnectorCredentialResult',
    'GetTasConnectorCredentialTasManualDetailResult',
    'GetTemplateFiltersFilterPropertyResult',
    'GetTemplateGitDetailsResult',
    'GetTerraformCloudConnectorCredentialResult',
    'GetTerraformCloudConnectorCredentialApiTokenResult',
    'GetUsergroupNotificationConfigResult',
    'GetVariablesSpecResult',
    'GetWorkspaceEnvironmentVariableResult',
    'GetWorkspaceOutputValueOutputValueResult',
    'GetWorkspaceTerraformVariableResult',
    'GetWorkspaceTerraformVariableFileResult',
]

@pulumi.output_type
class AppDynamicsConnectorApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretRef":
            suggest = "client_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDynamicsConnectorApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDynamicsConnectorApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDynamicsConnectorApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_ref: str):
        """
        :param str client_id: The client id used for connecting to App Dynamics.
        :param str client_secret_ref: Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id used for connecting to App Dynamics.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> str:
        """
        Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")


@pulumi.output_type
class AppDynamicsConnectorUsernamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDynamicsConnectorUsernamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDynamicsConnectorUsernamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDynamicsConnectorUsernamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ArtifactoryConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ArtifactoryConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ArtifactoryConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ArtifactoryConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class AwsCCConnectorCrossAccountAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalId":
            suggest = "external_id"
        elif key == "roleArn":
            suggest = "role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsCCConnectorCrossAccountAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsCCConnectorCrossAccountAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsCCConnectorCrossAccountAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_id: str,
                 role_arn: str):
        """
        :param str external_id: The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        :param str role_arn: The ARN of the role to use for cross-account access.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role to use for cross-account access.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class AwsConnectorCrossAccountAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorCrossAccountAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorCrossAccountAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorCrossAccountAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_arn: str,
                 external_id: Optional[str] = None):
        """
        :param str role_arn: The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        :param str external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class AwsConnectorEqualJitterBackoffStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseDelay":
            suggest = "base_delay"
        elif key == "maxBackoffTime":
            suggest = "max_backoff_time"
        elif key == "retryCount":
            suggest = "retry_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorEqualJitterBackoffStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorEqualJitterBackoffStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorEqualJitterBackoffStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_delay: Optional[int] = None,
                 max_backoff_time: Optional[int] = None,
                 retry_count: Optional[int] = None):
        """
        :param int base_delay: Base delay.
        :param int max_backoff_time: Max BackOff Time.
        :param int retry_count: Retry Count.
        """
        if base_delay is not None:
            pulumi.set(__self__, "base_delay", base_delay)
        if max_backoff_time is not None:
            pulumi.set(__self__, "max_backoff_time", max_backoff_time)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="baseDelay")
    def base_delay(self) -> Optional[int]:
        """
        Base delay.
        """
        return pulumi.get(self, "base_delay")

    @property
    @pulumi.getter(name="maxBackoffTime")
    def max_backoff_time(self) -> Optional[int]:
        """
        Max BackOff Time.
        """
        return pulumi.get(self, "max_backoff_time")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")


@pulumi.output_type
class AwsConnectorFixedDelayBackoffStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedBackoff":
            suggest = "fixed_backoff"
        elif key == "retryCount":
            suggest = "retry_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorFixedDelayBackoffStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorFixedDelayBackoffStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorFixedDelayBackoffStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_backoff: Optional[int] = None,
                 retry_count: Optional[int] = None):
        """
        :param int fixed_backoff: Fixed Backoff.
        :param int retry_count: Retry Count.
        """
        if fixed_backoff is not None:
            pulumi.set(__self__, "fixed_backoff", fixed_backoff)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="fixedBackoff")
    def fixed_backoff(self) -> Optional[int]:
        """
        Fixed Backoff.
        """
        return pulumi.get(self, "fixed_backoff")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")


@pulumi.output_type
class AwsConnectorFullJitterBackoffStrategy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseDelay":
            suggest = "base_delay"
        elif key == "maxBackoffTime":
            suggest = "max_backoff_time"
        elif key == "retryCount":
            suggest = "retry_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorFullJitterBackoffStrategy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorFullJitterBackoffStrategy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorFullJitterBackoffStrategy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_delay: Optional[int] = None,
                 max_backoff_time: Optional[int] = None,
                 retry_count: Optional[int] = None):
        """
        :param int base_delay: Base delay.
        :param int max_backoff_time: Max BackOff Time.
        :param int retry_count: Retry Count.
        """
        if base_delay is not None:
            pulumi.set(__self__, "base_delay", base_delay)
        if max_backoff_time is not None:
            pulumi.set(__self__, "max_backoff_time", max_backoff_time)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="baseDelay")
    def base_delay(self) -> Optional[int]:
        """
        Base delay.
        """
        return pulumi.get(self, "base_delay")

    @property
    @pulumi.getter(name="maxBackoffTime")
    def max_backoff_time(self) -> Optional[int]:
        """
        Max BackOff Time.
        """
        return pulumi.get(self, "max_backoff_time")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")


@pulumi.output_type
class AwsConnectorInheritFromDelegate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorInheritFromDelegate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorInheritFromDelegate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorInheritFromDelegate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 region: Optional[str] = None):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str region: Test Region to perform Connection test of AWS Connector.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class AwsConnectorIrsa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorIrsa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorIrsa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorIrsa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 region: Optional[str] = None):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str region: Test Region to perform Connection test of AWS Connector.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class AwsConnectorManual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKeyRef":
            suggest = "secret_key_ref"
        elif key == "accessKey":
            suggest = "access_key"
        elif key == "accessKeyRef":
            suggest = "access_key_ref"
        elif key == "delegateSelectors":
            suggest = "delegate_selectors"
        elif key == "sessionTokenRef":
            suggest = "session_token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorManual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorManual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorManual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key_ref: str,
                 access_key: Optional[str] = None,
                 access_key_ref: Optional[str] = None,
                 delegate_selectors: Optional[Sequence[str]] = None,
                 region: Optional[str] = None,
                 session_token_ref: Optional[str] = None):
        """
        :param str secret_key_ref: Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str access_key: AWS access key.
        :param str access_key_ref: Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: Connect only use delegates with these tags.
        :param str region: Test Region to perform Connection test of AWS Connector.
        :param str session_token_ref: Reference to the Harness secret containing the aws session token.
        """
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_key_ref is not None:
            pulumi.set(__self__, "access_key_ref", access_key_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if session_token_ref is not None:
            pulumi.set(__self__, "session_token_ref", session_token_ref)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        AWS access key.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        Connect only use delegates with these tags.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="sessionTokenRef")
    def session_token_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the aws session token.
        """
        return pulumi.get(self, "session_token_ref")


@pulumi.output_type
class AwsConnectorOidcAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegateSelectors":
            suggest = "delegate_selectors"
        elif key == "iamRoleArn":
            suggest = "iam_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsConnectorOidcAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsConnectorOidcAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsConnectorOidcAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 iam_role_arn: str,
                 region: Optional[str] = None):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str iam_role_arn: The IAM Role to assume the credentials from.
        :param str region: Test Region to perform Connection test of AWS Connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The IAM Role to assume the credentials from.
        """
        return pulumi.get(self, "iam_role_arn")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class AwsKmsConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assumeRole":
            suggest = "assume_role"
        elif key == "inheritFromDelegate":
            suggest = "inherit_from_delegate"
        elif key == "oidcAuthentication":
            suggest = "oidc_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsKmsConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsKmsConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsKmsConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assume_role: Optional['outputs.AwsKmsConnectorCredentialsAssumeRole'] = None,
                 inherit_from_delegate: Optional[bool] = None,
                 manual: Optional['outputs.AwsKmsConnectorCredentialsManual'] = None,
                 oidc_authentication: Optional['outputs.AwsKmsConnectorCredentialsOidcAuthentication'] = None):
        """
        :param 'AwsKmsConnectorCredentialsAssumeRoleArgs' assume_role: Connect using STS assume role.
        :param bool inherit_from_delegate: Inherit the credentials from from the delegate.
        :param 'AwsKmsConnectorCredentialsManualArgs' manual: Specify the AWS key and secret used for authenticating.
        :param 'AwsKmsConnectorCredentialsOidcAuthenticationArgs' oidc_authentication: Connect using OIDC authentication.
        """
        if assume_role is not None:
            pulumi.set(__self__, "assume_role", assume_role)
        if inherit_from_delegate is not None:
            pulumi.set(__self__, "inherit_from_delegate", inherit_from_delegate)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)
        if oidc_authentication is not None:
            pulumi.set(__self__, "oidc_authentication", oidc_authentication)

    @property
    @pulumi.getter(name="assumeRole")
    def assume_role(self) -> Optional['outputs.AwsKmsConnectorCredentialsAssumeRole']:
        """
        Connect using STS assume role.
        """
        return pulumi.get(self, "assume_role")

    @property
    @pulumi.getter(name="inheritFromDelegate")
    def inherit_from_delegate(self) -> Optional[bool]:
        """
        Inherit the credentials from from the delegate.
        """
        return pulumi.get(self, "inherit_from_delegate")

    @property
    @pulumi.getter
    def manual(self) -> Optional['outputs.AwsKmsConnectorCredentialsManual']:
        """
        Specify the AWS key and secret used for authenticating.
        """
        return pulumi.get(self, "manual")

    @property
    @pulumi.getter(name="oidcAuthentication")
    def oidc_authentication(self) -> Optional['outputs.AwsKmsConnectorCredentialsOidcAuthentication']:
        """
        Connect using OIDC authentication.
        """
        return pulumi.get(self, "oidc_authentication")


@pulumi.output_type
class AwsKmsConnectorCredentialsAssumeRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsKmsConnectorCredentialsAssumeRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsKmsConnectorCredentialsAssumeRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsKmsConnectorCredentialsAssumeRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 role_arn: str,
                 external_id: Optional[str] = None):
        """
        :param int duration: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        :param str role_arn: The ARN of the role to assume.
        :param str external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class AwsKmsConnectorCredentialsManual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKeyRef":
            suggest = "access_key_ref"
        elif key == "secretKeyRef":
            suggest = "secret_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsKmsConnectorCredentialsManual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsKmsConnectorCredentialsManual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsKmsConnectorCredentialsManual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key_ref: str,
                 secret_key_ref: str):
        """
        :param str access_key_ref: The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str secret_key_ref: The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "access_key_ref", access_key_ref)
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class AwsKmsConnectorCredentialsOidcAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamRoleArn":
            suggest = "iam_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsKmsConnectorCredentialsOidcAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsKmsConnectorCredentialsOidcAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsKmsConnectorCredentialsOidcAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_role_arn: str):
        """
        :param str iam_role_arn: The ARN of the IAM role to assume.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The ARN of the IAM role to assume.
        """
        return pulumi.get(self, "iam_role_arn")


@pulumi.output_type
class AwsSecretManagerConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assumeRole":
            suggest = "assume_role"
        elif key == "inheritFromDelegate":
            suggest = "inherit_from_delegate"
        elif key == "oidcAuthentication":
            suggest = "oidc_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSecretManagerConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSecretManagerConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSecretManagerConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assume_role: Optional['outputs.AwsSecretManagerConnectorCredentialsAssumeRole'] = None,
                 inherit_from_delegate: Optional[bool] = None,
                 manual: Optional['outputs.AwsSecretManagerConnectorCredentialsManual'] = None,
                 oidc_authentication: Optional['outputs.AwsSecretManagerConnectorCredentialsOidcAuthentication'] = None):
        """
        :param 'AwsSecretManagerConnectorCredentialsAssumeRoleArgs' assume_role: Connect using STS assume role.
        :param bool inherit_from_delegate: Inherit the credentials from from the delegate.
        :param 'AwsSecretManagerConnectorCredentialsManualArgs' manual: Specify the AWS key and secret used for authenticating.
        :param 'AwsSecretManagerConnectorCredentialsOidcAuthenticationArgs' oidc_authentication: Authentication using harness oidc.
        """
        if assume_role is not None:
            pulumi.set(__self__, "assume_role", assume_role)
        if inherit_from_delegate is not None:
            pulumi.set(__self__, "inherit_from_delegate", inherit_from_delegate)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)
        if oidc_authentication is not None:
            pulumi.set(__self__, "oidc_authentication", oidc_authentication)

    @property
    @pulumi.getter(name="assumeRole")
    def assume_role(self) -> Optional['outputs.AwsSecretManagerConnectorCredentialsAssumeRole']:
        """
        Connect using STS assume role.
        """
        return pulumi.get(self, "assume_role")

    @property
    @pulumi.getter(name="inheritFromDelegate")
    def inherit_from_delegate(self) -> Optional[bool]:
        """
        Inherit the credentials from from the delegate.
        """
        return pulumi.get(self, "inherit_from_delegate")

    @property
    @pulumi.getter
    def manual(self) -> Optional['outputs.AwsSecretManagerConnectorCredentialsManual']:
        """
        Specify the AWS key and secret used for authenticating.
        """
        return pulumi.get(self, "manual")

    @property
    @pulumi.getter(name="oidcAuthentication")
    def oidc_authentication(self) -> Optional['outputs.AwsSecretManagerConnectorCredentialsOidcAuthentication']:
        """
        Authentication using harness oidc.
        """
        return pulumi.get(self, "oidc_authentication")


@pulumi.output_type
class AwsSecretManagerConnectorCredentialsAssumeRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleArn":
            suggest = "role_arn"
        elif key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSecretManagerConnectorCredentialsAssumeRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSecretManagerConnectorCredentialsAssumeRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSecretManagerConnectorCredentialsAssumeRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: int,
                 role_arn: str,
                 external_id: Optional[str] = None):
        """
        :param int duration: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        :param str role_arn: The ARN of the role to assume.
        :param str external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role to assume.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[str]:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")


@pulumi.output_type
class AwsSecretManagerConnectorCredentialsManual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKeyRef":
            suggest = "secret_key_ref"
        elif key == "accessKeyPlainText":
            suggest = "access_key_plain_text"
        elif key == "accessKeyRef":
            suggest = "access_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSecretManagerConnectorCredentialsManual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSecretManagerConnectorCredentialsManual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSecretManagerConnectorCredentialsManual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key_ref: str,
                 access_key_plain_text: Optional[str] = None,
                 access_key_ref: Optional[str] = None):
        """
        :param str secret_key_ref: The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str access_key_plain_text: The plain text AWS access key. This is required if the access*key*ref is not provided.
        :param str access_key_ref: The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if access_key_plain_text is not None:
            pulumi.set(__self__, "access_key_plain_text", access_key_plain_text)
        if access_key_ref is not None:
            pulumi.set(__self__, "access_key_ref", access_key_ref)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @property
    @pulumi.getter(name="accessKeyPlainText")
    def access_key_plain_text(self) -> Optional[str]:
        """
        The plain text AWS access key. This is required if the access*key*ref is not provided.
        """
        return pulumi.get(self, "access_key_plain_text")

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> Optional[str]:
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")


@pulumi.output_type
class AwsSecretManagerConnectorCredentialsOidcAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iamRoleArn":
            suggest = "iam_role_arn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsSecretManagerConnectorCredentialsOidcAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsSecretManagerConnectorCredentialsOidcAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsSecretManagerConnectorCredentialsOidcAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iam_role_arn: str):
        """
        :param str iam_role_arn: The IAM role ARN.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The IAM role ARN.
        """
        return pulumi.get(self, "iam_role_arn")


@pulumi.output_type
class AzureCloudCostConnectorBillingExportSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerName":
            suggest = "container_name"
        elif key == "directoryName":
            suggest = "directory_name"
        elif key == "reportName":
            suggest = "report_name"
        elif key == "storageAccountName":
            suggest = "storage_account_name"
        elif key == "subscriptionId":
            suggest = "subscription_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudCostConnectorBillingExportSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudCostConnectorBillingExportSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudCostConnectorBillingExportSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_name: str,
                 directory_name: str,
                 report_name: str,
                 storage_account_name: str,
                 subscription_id: str):
        """
        :param str container_name: Name of the container.
        :param str directory_name: Name of the directory.
        :param str report_name: Name of the report.
        :param str storage_account_name: Name of the storage account.
        :param str subscription_id: Subsription Id.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "report_name", report_name)
        pulumi.set(__self__, "storage_account_name", storage_account_name)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        Name of the container.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> str:
        """
        Name of the directory.
        """
        return pulumi.get(self, "directory_name")

    @property
    @pulumi.getter(name="reportName")
    def report_name(self) -> str:
        """
        Name of the report.
        """
        return pulumi.get(self, "report_name")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> str:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subsription Id.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class AzureCloudProviderConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureInheritFromDelegateDetails":
            suggest = "azure_inherit_from_delegate_details"
        elif key == "azureManualDetails":
            suggest = "azure_manual_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 azure_inherit_from_delegate_details: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails'] = None,
                 azure_manual_details: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetails'] = None):
        """
        :param str type: Type can either be InheritFromDelegate or ManualConfig.
        :param 'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsArgs' azure_inherit_from_delegate_details: Authenticate to Azure Cloud Provider using details inheriting from delegate.
        :param 'AzureCloudProviderConnectorCredentialsAzureManualDetailsArgs' azure_manual_details: Authenticate to Azure Cloud Provider using manual details.
        """
        pulumi.set(__self__, "type", type)
        if azure_inherit_from_delegate_details is not None:
            pulumi.set(__self__, "azure_inherit_from_delegate_details", azure_inherit_from_delegate_details)
        if azure_manual_details is not None:
            pulumi.set(__self__, "azure_manual_details", azure_manual_details)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can either be InheritFromDelegate or ManualConfig.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureInheritFromDelegateDetails")
    def azure_inherit_from_delegate_details(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails']:
        """
        Authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        return pulumi.get(self, "azure_inherit_from_delegate_details")

    @property
    @pulumi.getter(name="azureManualDetails")
    def azure_manual_details(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetails']:
        """
        Authenticate to Azure Cloud Provider using manual details.
        """
        return pulumi.get(self, "azure_manual_details")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetails(dict):
    def __init__(__self__, *,
                 auth: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth'] = None):
        """
        :param 'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthArgs' auth: Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        if auth is not None:
            pulumi.set(__self__, "auth", auth)

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth']:
        """
        Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        return pulumi.get(self, "auth")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureMsiAuthUa":
            suggest = "azure_msi_auth_ua"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 azure_msi_auth_ua: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa'] = None):
        """
        :param str type: Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        :param 'AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUaArgs' azure_msi_auth_ua: Azure UserAssigned MSI auth details.
        """
        pulumi.set(__self__, "type", type)
        if azure_msi_auth_ua is not None:
            pulumi.set(__self__, "azure_msi_auth_ua", azure_msi_auth_ua)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureMsiAuthUa")
    def azure_msi_auth_ua(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa']:
        """
        Azure UserAssigned MSI auth details.
        """
        return pulumi.get(self, "azure_msi_auth_ua")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentialsAzureInheritFromDelegateDetailsAuthAzureMsiAuthUa.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[str] = None):
        """
        :param str client_id: Client Id of the ManagedIdentity resource.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client Id of the ManagedIdentity resource.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureManualDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentialsAzureManualDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: Optional[str] = None,
                 auth: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth'] = None,
                 tenant_id: Optional[str] = None):
        """
        :param str application_id: Application ID of the Azure App.
        :param 'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthArgs' auth: Contains Azure auth details.
        :param str tenant_id: The Azure Active Directory (AAD) directory ID where you created your application.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if auth is not None:
            pulumi.set(__self__, "auth", auth)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        Application ID of the Azure App.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def auth(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth']:
        """
        Contains Azure auth details.
        """
        return pulumi.get(self, "auth")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[str]:
        """
        The Azure Active Directory (AAD) directory ID where you created your application.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureClientKeyCert":
            suggest = "azure_client_key_cert"
        elif key == "azureClientSecretKey":
            suggest = "azure_client_secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetailsAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 azure_client_key_cert: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert'] = None,
                 azure_client_secret_key: Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey'] = None,
                 type: Optional[str] = None):
        """
        :param 'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCertArgs' azure_client_key_cert: Azure client key certificate details.
        :param 'AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKeyArgs' azure_client_secret_key: Azure Client Secret Key details.
        :param str type: Type can either be Certificate or Secret.
        """
        if azure_client_key_cert is not None:
            pulumi.set(__self__, "azure_client_key_cert", azure_client_key_cert)
        if azure_client_secret_key is not None:
            pulumi.set(__self__, "azure_client_secret_key", azure_client_secret_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="azureClientKeyCert")
    def azure_client_key_cert(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert']:
        """
        Azure client key certificate details.
        """
        return pulumi.get(self, "azure_client_key_cert")

    @property
    @pulumi.getter(name="azureClientSecretKey")
    def azure_client_secret_key(self) -> Optional['outputs.AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey']:
        """
        Azure Client Secret Key details.
        """
        return pulumi.get(self, "azure_client_secret_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type can either be Certificate or Secret.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateRef":
            suggest = "certificate_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientKeyCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 certificate_ref: Optional[str] = None):
        """
        :param str certificate_ref: Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if certificate_ref is not None:
            pulumi.set(__self__, "certificate_ref", certificate_ref)

    @property
    @pulumi.getter(name="certificateRef")
    def certificate_ref(self) -> Optional[str]:
        """
        Reference of the secret for the certificate. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "certificate_ref")


@pulumi.output_type
class AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureCloudProviderConnectorCredentialsAzureManualDetailsAuthAzureClientSecretKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_ref: Optional[str] = None):
        """
        :param str secret_ref: Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[str]:
        """
        Reference of the secret for the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class BitbucketConnectorApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenRef":
            suggest = "token_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BitbucketConnectorApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BitbucketConnectorApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BitbucketConnectorApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str token_ref: Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: The username used for connecting to the api.
        :param str username_ref: The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username used for connecting to the api.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class BitbucketConnectorCredentials(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.BitbucketConnectorCredentialsHttp'] = None,
                 ssh: Optional['outputs.BitbucketConnectorCredentialsSsh'] = None):
        """
        :param 'BitbucketConnectorCredentialsHttpArgs' http: Authenticate using Username and password over http(s) for the connection.
        :param 'BitbucketConnectorCredentialsSshArgs' ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.BitbucketConnectorCredentialsHttp']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def ssh(self) -> Optional['outputs.BitbucketConnectorCredentialsSsh']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class BitbucketConnectorCredentialsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BitbucketConnectorCredentialsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BitbucketConnectorCredentialsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BitbucketConnectorCredentialsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: Optional[str] = None,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if password_ref is not None:
            pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class BitbucketConnectorCredentialsSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeyRef":
            suggest = "ssh_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BitbucketConnectorCredentialsSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BitbucketConnectorCredentialsSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BitbucketConnectorCredentialsSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class ConnectorAzureArtifactsCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenRef":
            suggest = "token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorAzureArtifactsCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorAzureArtifactsCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorAzureArtifactsCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class ConnectorCustomSecretManagerTemplateInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariables":
            suggest = "environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorCustomSecretManagerTemplateInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorCustomSecretManagerTemplateInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorCustomSecretManagerTemplateInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_variables: Optional[Sequence['outputs.ConnectorCustomSecretManagerTemplateInputEnvironmentVariable']] = None):
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Sequence['outputs.ConnectorCustomSecretManagerTemplateInputEnvironmentVariable']]:
        return pulumi.get(self, "environment_variables")


@pulumi.output_type
class ConnectorCustomSecretManagerTemplateInputEnvironmentVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str,
                 default: Optional[bool] = None):
        """
        :param str name: : Name of the resource.
        :param str type: : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if default is not None:
            pulumi.set(__self__, "default", default)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        : Name of the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def default(self) -> Optional[bool]:
        return pulumi.get(self, "default")


@pulumi.output_type
class ConnectorCustomhealthsourceHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedValueRef":
            suggest = "encrypted_value_ref"
        elif key == "valueEncrypted":
            suggest = "value_encrypted"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorCustomhealthsourceHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorCustomhealthsourceHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorCustomhealthsourceHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 encrypted_value_ref: Optional[str] = None,
                 value: Optional[str] = None,
                 value_encrypted: Optional[bool] = None):
        """
        :param str key: Key.
        :param str encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str value: Value.
        :param bool value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_value_ref is not None:
            pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_encrypted is not None:
            pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> Optional[bool]:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")


@pulumi.output_type
class ConnectorCustomhealthsourceParam(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedValueRef":
            suggest = "encrypted_value_ref"
        elif key == "valueEncrypted":
            suggest = "value_encrypted"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorCustomhealthsourceParam. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorCustomhealthsourceParam.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorCustomhealthsourceParam.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 encrypted_value_ref: Optional[str] = None,
                 value: Optional[str] = None,
                 value_encrypted: Optional[bool] = None):
        """
        :param str key: Key.
        :param str encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str value: Value.
        :param bool value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_value_ref is not None:
            pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_encrypted is not None:
            pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> Optional[bool]:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")


@pulumi.output_type
class ConnectorGcpKmsManual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorGcpKmsManual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorGcpKmsManual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorGcpKmsManual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credentials: str,
                 delegate_selectors: Optional[Sequence[str]] = None):
        """
        :param str credentials: Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: The delegates to connect with.
        """
        pulumi.set(__self__, "credentials", credentials)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        The delegates to connect with.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class ConnectorGcpKmsOidcAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpProjectId":
            suggest = "gcp_project_id"
        elif key == "providerId":
            suggest = "provider_id"
        elif key == "serviceAccountEmail":
            suggest = "service_account_email"
        elif key == "workloadPoolId":
            suggest = "workload_pool_id"
        elif key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorGcpKmsOidcAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorGcpKmsOidcAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorGcpKmsOidcAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_project_id: str,
                 provider_id: str,
                 service_account_email: str,
                 workload_pool_id: str,
                 delegate_selectors: Optional[Sequence[str]] = None):
        """
        :param str gcp_project_id: The project number of the GCP project that is used to create the workload identity.
        :param str provider_id: The OIDC provider ID value configured in GCP.
        :param str service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param str workload_pool_id: The workload pool ID value created in GCP.
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> str:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class ConnectorJdbcCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "passwordRef":
            suggest = "password_ref"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "usernamePassword":
            suggest = "username_password"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorJdbcCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorJdbcCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorJdbcCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: Optional[str] = None,
                 password_ref: Optional[str] = None,
                 service_account: Optional['outputs.ConnectorJdbcCredentialsServiceAccount'] = None,
                 username: Optional[str] = None,
                 username_password: Optional['outputs.ConnectorJdbcCredentialsUsernamePassword'] = None,
                 username_ref: Optional[str] = None):
        """
        :param str auth_type: Authentication types for JDBC connector
        :param str password_ref: The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param 'ConnectorJdbcCredentialsServiceAccountArgs' service_account: Authenticate using service account.
        :param str username: The username to use for the database server.
        :param 'ConnectorJdbcCredentialsUsernamePasswordArgs' username_password: Authenticate using username password.
        :param str username_ref: The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if password_ref is not None:
            pulumi.set(__self__, "password_ref", password_ref)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[str]:
        """
        Authentication types for JDBC connector
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> Optional[str]:
        """
        The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional['outputs.ConnectorJdbcCredentialsServiceAccount']:
        """
        Authenticate using service account.
        """
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to use for the database server.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.ConnectorJdbcCredentialsUsernamePassword']:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_password")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class ConnectorJdbcCredentialsServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenRef":
            suggest = "token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorJdbcCredentialsServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorJdbcCredentialsServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorJdbcCredentialsServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class ConnectorJdbcCredentialsUsernamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorJdbcCredentialsUsernamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorJdbcCredentialsUsernamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorJdbcCredentialsUsernamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class ConnectorPdcHost(dict):
    def __init__(__self__, *,
                 hostname: str,
                 attributes: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: Hostname e.g. 87.23.66.11:80
        :param Mapping[str, str] attributes: Host attributes with values. e.g. type, region, name, ip, etc.
        """
        pulumi.set(__self__, "hostname", hostname)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Hostname e.g. 87.23.66.11:80
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        Host attributes with values. e.g. type, region, name, ip, etc.
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class ConnectorRancherBearerToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bearerTokenRef":
            suggest = "bearer_token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectorRancherBearerToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectorRancherBearerToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectorRancherBearerToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bearer_token_ref: str):
        """
        :param str bearer_token_ref: Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "bearer_token_ref", bearer_token_ref)

    @property
    @pulumi.getter(name="bearerTokenRef")
    def bearer_token_ref(self) -> str:
        """
        Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "bearer_token_ref")


@pulumi.output_type
class DbSchemaSchemaSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "archivePath":
            suggest = "archive_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DbSchemaSchemaSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DbSchemaSchemaSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DbSchemaSchemaSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector: str,
                 location: str,
                 archive_path: Optional[str] = None,
                 repo: Optional[str] = None):
        """
        :param str connector: Connector to repository at which to find details about the database schema
        :param str location: The path within the specified repository at which to find details about the database schema
        :param str archive_path: If connector type is artifactory, path to the archive file which contains the changeLog
        :param str repo: If connector url is of account, which repository to connect to using the connector
        """
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "location", location)
        if archive_path is not None:
            pulumi.set(__self__, "archive_path", archive_path)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def connector(self) -> str:
        """
        Connector to repository at which to find details about the database schema
        """
        return pulumi.get(self, "connector")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The path within the specified repository at which to find details about the database schema
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="archivePath")
    def archive_path(self) -> Optional[str]:
        """
        If connector type is artifactory, path to the archive file which contains the changeLog
        """
        return pulumi.get(self, "archive_path")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        """
        If connector url is of account, which repository to connect to using the connector
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class DockerConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DockerConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DockerConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DockerConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        :param str username: The username to use for the docker registry.
        :param str username_ref: The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username to use for the docker registry.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class ElasticsearchConnectorApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretRef":
            suggest = "client_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchConnectorApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchConnectorApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchConnectorApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 client_secret_ref: str):
        """
        :param str client_id: The client id used for connecting to ElasticSearch.
        :param str client_secret_ref: Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id used for connecting to ElasticSearch.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> str:
        """
        Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")


@pulumi.output_type
class ElasticsearchConnectorNoAuthentication(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ElasticsearchConnectorUsernamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchConnectorUsernamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchConnectorUsernamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchConnectorUsernamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class EnvironmentClustersMappingCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentIdentifier":
            suggest = "agent_identifier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentClustersMappingCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentClustersMappingCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentClustersMappingCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_identifier: Optional[str] = None,
                 identifier: Optional[str] = None,
                 name: Optional[str] = None,
                 scope: Optional[str] = None):
        """
        :param str agent_identifier: agent identifier of the cluster (include scope prefix)
        :param str identifier: identifier of the cluster
        :param str name: name of the cluster
        :param str scope: scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        if agent_identifier is not None:
            pulumi.set(__self__, "agent_identifier", agent_identifier)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> Optional[str]:
        """
        agent identifier of the cluster (include scope prefix)
        """
        return pulumi.get(self, "agent_identifier")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        identifier of the cluster
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name of the cluster
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class EnvironmentGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "importFromGit":
            suggest = "import_from_git"
        elif key == "isForceImport":
            suggest = "is_force_import"
        elif key == "isHarnesscodeRepo":
            suggest = "is_harnesscode_repo"
        elif key == "isNewBranch":
            suggest = "is_new_branch"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "loadFromCache":
            suggest = "load_from_cache"
        elif key == "loadFromFallbackBranch":
            suggest = "load_from_fallback_branch"
        elif key == "parentEntityConnectorRef":
            suggest = "parent_entity_connector_ref"
        elif key == "parentEntityRepoName":
            suggest = "parent_entity_repo_name"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnvironmentGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnvironmentGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnvironmentGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 import_from_git: Optional[bool] = None,
                 is_force_import: Optional[bool] = None,
                 is_harnesscode_repo: Optional[bool] = None,
                 is_new_branch: Optional[bool] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 load_from_cache: Optional[str] = None,
                 load_from_fallback_branch: Optional[bool] = None,
                 parent_entity_connector_ref: Optional[str] = None,
                 parent_entity_repo_name: Optional[str] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch: Name of the branch.
        :param str commit_message: message for the commit in Git Repo.
        :param str connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param bool import_from_git: Flag to set if importing from Git
        :param bool is_force_import: Flag to set if force importing from Git
        :param bool is_harnesscode_repo: If the gitProvider is HarnessCode
        :param bool is_new_branch: If a new branch creation is requested.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Environment.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Environment.
        :param str load_from_cache: If the Entity is to be fetched from cache
        :param bool load_from_fallback_branch: Whether the file has to be get from fallback_branch.
        :param str parent_entity_connector_ref: Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str parent_entity_repo_name: Name of the repository where parent entity lies.
        :param str repo_name: Name of the repository.
        :param str store_type: store type of the entity.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if import_from_git is not None:
            pulumi.set(__self__, "import_from_git", import_from_git)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if is_harnesscode_repo is not None:
            pulumi.set(__self__, "is_harnesscode_repo", is_harnesscode_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if parent_entity_connector_ref is not None:
            pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        if parent_entity_repo_name is not None:
            pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        message for the commit in Git Repo.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="importFromGit")
    def import_from_git(self) -> Optional[bool]:
        """
        Flag to set if importing from Git
        """
        return pulumi.get(self, "import_from_git")

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[bool]:
        """
        Flag to set if force importing from Git
        """
        return pulumi.get(self, "is_force_import")

    @property
    @pulumi.getter(name="isHarnesscodeRepo")
    def is_harnesscode_repo(self) -> Optional[bool]:
        """
        If the gitProvider is HarnessCode
        """
        return pulumi.get(self, "is_harnesscode_repo")

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[bool]:
        """
        If a new branch creation is requested.
        """
        return pulumi.get(self, "is_new_branch")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Environment.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating Environment.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[str]:
        """
        If the Entity is to be fetched from cache
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[bool]:
        """
        Whether the file has to be get from fallback_branch.
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> Optional[str]:
        """
        Name of the repository where parent entity lies.
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        store type of the entity.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class FeatureFlagEnvironment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addTargetRules":
            suggest = "add_target_rules"
        elif key == "defaultOffVariation":
            suggest = "default_off_variation"
        elif key == "defaultOnVariation":
            suggest = "default_on_variation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FeatureFlagEnvironment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FeatureFlagEnvironment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FeatureFlagEnvironment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 identifier: str,
                 add_target_rules: Optional[Sequence['outputs.FeatureFlagEnvironmentAddTargetRule']] = None,
                 default_off_variation: Optional[str] = None,
                 default_on_variation: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str identifier: Identifier of the Environment
        :param Sequence['FeatureFlagEnvironmentAddTargetRuleArgs'] add_target_rules: The targeting rules for the flag
        :param str default_off_variation: Default variation to be served when flag is 'off'
        :param str default_on_variation: Default variation to be served when flag is 'on'
        :param str state: State of the flag in this environment. Possible values are 'on' and 'off'
        """
        pulumi.set(__self__, "identifier", identifier)
        if add_target_rules is not None:
            pulumi.set(__self__, "add_target_rules", add_target_rules)
        if default_off_variation is not None:
            pulumi.set(__self__, "default_off_variation", default_off_variation)
        if default_on_variation is not None:
            pulumi.set(__self__, "default_on_variation", default_on_variation)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifier of the Environment
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="addTargetRules")
    def add_target_rules(self) -> Optional[Sequence['outputs.FeatureFlagEnvironmentAddTargetRule']]:
        """
        The targeting rules for the flag
        """
        return pulumi.get(self, "add_target_rules")

    @property
    @pulumi.getter(name="defaultOffVariation")
    def default_off_variation(self) -> Optional[str]:
        """
        Default variation to be served when flag is 'off'
        """
        return pulumi.get(self, "default_off_variation")

    @property
    @pulumi.getter(name="defaultOnVariation")
    def default_on_variation(self) -> Optional[str]:
        """
        Default variation to be served when flag is 'on'
        """
        return pulumi.get(self, "default_on_variation")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of the flag in this environment. Possible values are 'on' and 'off'
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class FeatureFlagEnvironmentAddTargetRule(dict):
    def __init__(__self__, *,
                 targets: Optional[Sequence[str]] = None,
                 variation: Optional[str] = None):
        """
        :param Sequence[str] targets: The targets of the rule
        :param str variation: The identifier of the variation. Valid values are `enabled`, `disabled`
        """
        if targets is not None:
            pulumi.set(__self__, "targets", targets)
        if variation is not None:
            pulumi.set(__self__, "variation", variation)

    @property
    @pulumi.getter
    def targets(self) -> Optional[Sequence[str]]:
        """
        The targets of the rule
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def variation(self) -> Optional[str]:
        """
        The identifier of the variation. Valid values are `enabled`, `disabled`
        """
        return pulumi.get(self, "variation")


@pulumi.output_type
class FeatureFlagTag(dict):
    def __init__(__self__, *,
                 identifier: str):
        """
        :param str identifier: The identifier of the tag
        """
        pulumi.set(__self__, "identifier", identifier)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier of the tag
        """
        return pulumi.get(self, "identifier")


@pulumi.output_type
class FeatureFlagTargetGroupRule(dict):
    def __init__(__self__, *,
                 attribute: str,
                 op: str,
                 values: Sequence[str],
                 id: Optional[str] = None,
                 negate: Optional[bool] = None):
        """
        :param str attribute: The attribute to use in the clause.  This can be any target attribute
        :param str op: The type of operation such as equals, starts_with, contains
        :param Sequence[str] values: The values that are compared against the operator
        :param str id: The ID of this resource.
        :param bool negate: Is the operation negated?
        """
        pulumi.set(__self__, "attribute", attribute)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "values", values)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if negate is not None:
            pulumi.set(__self__, "negate", negate)

    @property
    @pulumi.getter
    def attribute(self) -> str:
        """
        The attribute to use in the clause.  This can be any target attribute
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The type of operation such as equals, starts_with, contains
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        The values that are compared against the operator
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this resource.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def negate(self) -> Optional[bool]:
        """
        Is the operation negated?
        """
        return pulumi.get(self, "negate")


@pulumi.output_type
class FeatureFlagVariation(dict):
    def __init__(__self__, *,
                 description: str,
                 identifier: str,
                 name: str,
                 value: str):
        """
        :param str description: The description of the variation
        :param str identifier: The identifier of the variation
        :param str name: The user friendly name of the variation
        :param str value: The value of the variation
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the variation
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        The identifier of the variation
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The user friendly name of the variation
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the variation
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class FileStoreFileCreatedBy(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str email: User email
        :param str name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FileStoreFileLastModifiedBy(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str email: User email
        :param str name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FileStoreFolderCreatedBy(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str email: User email
        :param str name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FileStoreFolderLastModifiedBy(dict):
    def __init__(__self__, *,
                 email: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str email: User email
        :param str name: User name
        """
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class FiltersFilterProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FiltersFilterProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FiltersFilterProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FiltersFilterProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str filter_type: Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GcpCloudCostConnectorBillingExportSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSetId":
            suggest = "data_set_id"
        elif key == "tableId":
            suggest = "table_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpCloudCostConnectorBillingExportSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpCloudCostConnectorBillingExportSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpCloudCostConnectorBillingExportSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_set_id: str,
                 table_id: str):
        """
        :param str data_set_id: Data Set Id.
        :param str table_id: Table Id.
        """
        pulumi.set(__self__, "data_set_id", data_set_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="dataSetId")
    def data_set_id(self) -> str:
        """
        Data Set Id.
        """
        return pulumi.get(self, "data_set_id")

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> str:
        """
        Table Id.
        """
        return pulumi.get(self, "table_id")


@pulumi.output_type
class GcpConnectorInheritFromDelegate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpConnectorInheritFromDelegate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpConnectorInheritFromDelegate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpConnectorInheritFromDelegate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegate_selectors: Sequence[str]):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class GcpConnectorManual(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretKeyRef":
            suggest = "secret_key_ref"
        elif key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpConnectorManual. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpConnectorManual.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpConnectorManual.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_key_ref: str,
                 delegate_selectors: Optional[Sequence[str]] = None):
        """
        :param str secret_key_ref: Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: The delegates to connect with.
        """
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        The delegates to connect with.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class GcpConnectorOidcAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpProjectId":
            suggest = "gcp_project_id"
        elif key == "providerId":
            suggest = "provider_id"
        elif key == "serviceAccountEmail":
            suggest = "service_account_email"
        elif key == "workloadPoolId":
            suggest = "workload_pool_id"
        elif key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpConnectorOidcAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpConnectorOidcAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpConnectorOidcAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_project_id: str,
                 provider_id: str,
                 service_account_email: str,
                 workload_pool_id: str,
                 delegate_selectors: Optional[Sequence[str]] = None):
        """
        :param str gcp_project_id: The project number of the GCP project that is used to create the workload identity.
        :param str provider_id: The OIDC provider ID value configured in GCP.
        :param str service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param str workload_pool_id: The workload pool ID value created in GCP.
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> str:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class GcpSecretManagerConnectorOidcAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpProjectId":
            suggest = "gcp_project_id"
        elif key == "providerId":
            suggest = "provider_id"
        elif key == "serviceAccountEmail":
            suggest = "service_account_email"
        elif key == "workloadPoolId":
            suggest = "workload_pool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSecretManagerConnectorOidcAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSecretManagerConnectorOidcAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSecretManagerConnectorOidcAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_project_id: str,
                 provider_id: str,
                 service_account_email: str,
                 workload_pool_id: str):
        """
        :param str gcp_project_id: The project number of the GCP project that is used to create the workload identity.
        :param str provider_id: The OIDC provider ID value configured in GCP.
        :param str service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param str workload_pool_id: The workload pool ID value created in GCP.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The project number of the GCP project that is used to create the workload identity.
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> str:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")


@pulumi.output_type
class GitConnectorCredentials(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.GitConnectorCredentialsHttp'] = None,
                 ssh: Optional['outputs.GitConnectorCredentialsSsh'] = None):
        """
        :param 'GitConnectorCredentialsHttpArgs' http: Authenticate using Username and password over http(s) for the connection.
        :param 'GitConnectorCredentialsSshArgs' ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.GitConnectorCredentialsHttp']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def ssh(self) -> Optional['outputs.GitConnectorCredentialsSsh']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class GitConnectorCredentialsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitConnectorCredentialsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitConnectorCredentialsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitConnectorCredentialsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GitConnectorCredentialsSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeyRef":
            suggest = "ssh_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitConnectorCredentialsSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitConnectorCredentialsSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitConnectorCredentialsSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GitOpsAgentMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "highAvailability":
            suggest = "high_availability"
        elif key == "isNamespaced":
            suggest = "is_namespaced"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsAgentMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsAgentMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsAgentMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 high_availability: Optional[bool] = None,
                 is_namespaced: Optional[bool] = None,
                 namespace: Optional[str] = None):
        """
        :param bool high_availability: Indicates if the agent is deployed in HA mode.
        :param bool is_namespaced: Indicates if the agent is namespaced.
        :param str namespace: The kubernetes namespace where the agent should be installed.
        """
        if high_availability is not None:
            pulumi.set(__self__, "high_availability", high_availability)
        if is_namespaced is not None:
            pulumi.set(__self__, "is_namespaced", is_namespaced)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter(name="highAvailability")
    def high_availability(self) -> Optional[bool]:
        """
        Indicates if the agent is deployed in HA mode.
        """
        return pulumi.get(self, "high_availability")

    @property
    @pulumi.getter(name="isNamespaced")
    def is_namespaced(self) -> Optional[bool]:
        """
        Indicates if the agent is namespaced.
        """
        return pulumi.get(self, "is_namespaced")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        The kubernetes namespace where the agent should be installed.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GitOpsApplicationsApplication(dict):
    def __init__(__self__, *,
                 metadatas: Sequence['outputs.GitOpsApplicationsApplicationMetadata'],
                 specs: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpec']] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationMetadataArgs'] metadatas: Metadata corresponding to the resources. This includes all the objects a user must create.
        :param Sequence['GitOpsApplicationsApplicationSpecArgs'] specs: Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GitOpsApplicationsApplicationMetadata']:
        """
        Metadata corresponding to the resources. This includes all the objects a user must create.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter
    def specs(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpec']]:
        """
        Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        """
        return pulumi.get(self, "specs")


@pulumi.output_type
class GitOpsApplicationsApplicationMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "generateName":
            suggest = "generate_name"
        elif key == "ownerReferences":
            suggest = "owner_references"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 cluster_name: Optional[str] = None,
                 finalizers: Optional[Sequence[str]] = None,
                 generate_name: Optional[str] = None,
                 generation: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 owner_references: Optional[Sequence['outputs.GitOpsApplicationsApplicationMetadataOwnerReference']] = None,
                 uid: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        :param str cluster_name: Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        :param Sequence[str] finalizers: Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        :param str generate_name: An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        :param str generation: A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        :param str name: Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        :param str namespace: Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        :param Sequence['GitOpsApplicationsApplicationMetadataOwnerReferenceArgs'] owner_references: List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        :param str uid: UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if finalizers is not None:
            pulumi.set(__self__, "finalizers", finalizers)
        if generate_name is not None:
            pulumi.set(__self__, "generate_name", generate_name)
        if generation is not None:
            pulumi.set(__self__, "generation", generation)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if owner_references is not None:
            pulumi.set(__self__, "owner_references", owner_references)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def finalizers(self) -> Optional[Sequence[str]]:
        """
        Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        """
        return pulumi.get(self, "finalizers")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> Optional[str]:
        """
        An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> Optional[str]:
        """
        A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="ownerReferences")
    def owner_references(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationMetadataOwnerReference']]:
        """
        List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        """
        return pulumi.get(self, "owner_references")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GitOpsApplicationsApplicationMetadataOwnerReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "blockOwnerDeletion":
            suggest = "block_owner_deletion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationMetadataOwnerReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationMetadataOwnerReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationMetadataOwnerReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 block_owner_deletion: Optional[bool] = None,
                 controller: Optional[bool] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None,
                 uid: Optional[str] = None):
        """
        :param str api_version: API version of the referent.
        :param bool block_owner_deletion: If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        :param bool controller: Indicates if the reference points to the managing controller.
        :param str kind: Kind of the referent.
        :param str name: Name of the referent.
        :param str uid: UID of the referent.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if block_owner_deletion is not None:
            pulumi.set(__self__, "block_owner_deletion", block_owner_deletion)
        if controller is not None:
            pulumi.set(__self__, "controller", controller)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="blockOwnerDeletion")
    def block_owner_deletion(self) -> Optional[bool]:
        """
        If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        """
        return pulumi.get(self, "block_owner_deletion")

    @property
    @pulumi.getter
    def controller(self) -> Optional[bool]:
        """
        Indicates if the reference points to the managing controller.
        """
        return pulumi.get(self, "controller")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the referent.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uid(self) -> Optional[str]:
        """
        UID of the referent.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GitOpsApplicationsApplicationSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "syncPolicies":
            suggest = "sync_policies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destinations: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecDestination']] = None,
                 project: Optional[str] = None,
                 source: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSource']] = None,
                 sources: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSource']] = None,
                 sync_policies: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicy']] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationSpecDestinationArgs'] destinations: Information about the GitOps application's destination.
        :param str project: The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceArgs'] source: Contains all information about the source of the GitOps application.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceArgs'] sources: List of sources for the GitOps application. Multi Source support
        :param Sequence['GitOpsApplicationsApplicationSpecSyncPolicyArgs'] sync_policies: Controls when a sync will be performed in response to updates in git.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)
        if sync_policies is not None:
            pulumi.set(__self__, "sync_policies", sync_policies)

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecDestination']]:
        """
        Information about the GitOps application's destination.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def source(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSource']]:
        """
        Contains all information about the source of the GitOps application.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def sources(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSource']]:
        """
        List of sources for the GitOps application. Multi Source support
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="syncPolicies")
    def sync_policies(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicy']]:
        """
        Controls when a sync will be performed in response to updates in git.
        """
        return pulumi.get(self, "sync_policies")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecDestination(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server: Optional[str] = None):
        """
        :param str name: URL of the target cluster and must be set to the kubernetes control plane API.
        :param str namespace: Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        :param str server: URL of the target cluster server for the GitOps application.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        URL of the target cluster and must be set to the kubernetes control plane API.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        URL of the target cluster server for the GitOps application.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoUrl":
            suggest = "repo_url"
        elif key == "targetRevision":
            suggest = "target_revision"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repo_url: str,
                 target_revision: str,
                 chart: Optional[str] = None,
                 directories: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectory']] = None,
                 helms: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceHelm']] = None,
                 ksonnets: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceKsonnet']] = None,
                 kustomizes: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceKustomize']] = None,
                 path: Optional[str] = None,
                 plugins: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourcePlugin']] = None,
                 ref: Optional[str] = None):
        """
        :param str repo_url: URL to the repository (git or helm) that contains the GitOps application manifests.
        :param str target_revision: Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        :param str chart: Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceDirectoryArgs'] directories: Options for applications of type plain YAML or Jsonnet.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceHelmArgs'] helms: Holds helm specific options.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceKsonnetArgs'] ksonnets: Ksonnet specific options.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceKustomizeArgs'] kustomizes: Options specific to a GitOps application source specific to Kustomize.
        :param str path: Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        :param Sequence['GitOpsApplicationsApplicationSpecSourcePluginArgs'] plugins: Options specific to config management plugins.
        :param str ref: Reference name to be used in other source spec, used for multi-source applications.
        """
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "target_revision", target_revision)
        if chart is not None:
            pulumi.set(__self__, "chart", chart)
        if directories is not None:
            pulumi.set(__self__, "directories", directories)
        if helms is not None:
            pulumi.set(__self__, "helms", helms)
        if ksonnets is not None:
            pulumi.set(__self__, "ksonnets", ksonnets)
        if kustomizes is not None:
            pulumi.set(__self__, "kustomizes", kustomizes)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if plugins is not None:
            pulumi.set(__self__, "plugins", plugins)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> str:
        """
        URL to the repository (git or helm) that contains the GitOps application manifests.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="targetRevision")
    def target_revision(self) -> str:
        """
        Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        """
        return pulumi.get(self, "target_revision")

    @property
    @pulumi.getter
    def chart(self) -> Optional[str]:
        """
        Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        """
        return pulumi.get(self, "chart")

    @property
    @pulumi.getter
    def directories(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectory']]:
        """
        Options for applications of type plain YAML or Jsonnet.
        """
        return pulumi.get(self, "directories")

    @property
    @pulumi.getter
    def helms(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceHelm']]:
        """
        Holds helm specific options.
        """
        return pulumi.get(self, "helms")

    @property
    @pulumi.getter
    def ksonnets(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceKsonnet']]:
        """
        Ksonnet specific options.
        """
        return pulumi.get(self, "ksonnets")

    @property
    @pulumi.getter
    def kustomizes(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceKustomize']]:
        """
        Options specific to a GitOps application source specific to Kustomize.
        """
        return pulumi.get(self, "kustomizes")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def plugins(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourcePlugin']]:
        """
        Options specific to config management plugins.
        """
        return pulumi.get(self, "plugins")

    @property
    @pulumi.getter
    def ref(self) -> Optional[str]:
        """
        Reference name to be used in other source spec, used for multi-source applications.
        """
        return pulumi.get(self, "ref")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceDirectory(dict):
    def __init__(__self__, *,
                 exclude: Optional[str] = None,
                 include: Optional[str] = None,
                 jsonnets: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet']] = None,
                 recurse: Optional[bool] = None):
        """
        :param str exclude: Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        :param str include: Glob pattern to match paths against that should be explicitly included during manifest generation.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetArgs'] jsonnets: Options specific to applications of type Jsonnet.
        :param bool recurse: Indicates to scan a directory recursively for manifests.
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if jsonnets is not None:
            pulumi.set(__self__, "jsonnets", jsonnets)
        if recurse is not None:
            pulumi.set(__self__, "recurse", recurse)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[str]:
        """
        Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter
    def include(self) -> Optional[str]:
        """
        Glob pattern to match paths against that should be explicitly included during manifest generation.
        """
        return pulumi.get(self, "include")

    @property
    @pulumi.getter
    def jsonnets(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet']]:
        """
        Options specific to applications of type Jsonnet.
        """
        return pulumi.get(self, "jsonnets")

    @property
    @pulumi.getter
    def recurse(self) -> Optional[bool]:
        """
        Indicates to scan a directory recursively for manifests.
        """
        return pulumi.get(self, "recurse")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extVars":
            suggest = "ext_vars"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSourceDirectoryJsonnet.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ext_vars: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar']] = None,
                 libs: Optional[Sequence[str]] = None,
                 tlas: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla']] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs'] ext_vars: List of jsonnet external variables.
        :param Sequence[str] libs: Additional library search dirs.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs'] tlas: List of jsonnet top-level arguments(TLAS).
        """
        if ext_vars is not None:
            pulumi.set(__self__, "ext_vars", ext_vars)
        if libs is not None:
            pulumi.set(__self__, "libs", libs)
        if tlas is not None:
            pulumi.set(__self__, "tlas", tlas)

    @property
    @pulumi.getter(name="extVars")
    def ext_vars(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar']]:
        """
        List of jsonnet external variables.
        """
        return pulumi.get(self, "ext_vars")

    @property
    @pulumi.getter
    def libs(self) -> Optional[Sequence[str]]:
        """
        Additional library search dirs.
        """
        return pulumi.get(self, "libs")

    @property
    @pulumi.getter
    def tlas(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla']]:
        """
        List of jsonnet top-level arguments(TLAS).
        """
        return pulumi.get(self, "tlas")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetExtVar(dict):
    def __init__(__self__, *,
                 code: Optional[bool] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool code: Code of the external variables of jsonnet application.
        :param str name: Name of the external variables of jsonnet application.
        :param str value: Value of the external variables of jsonnet application.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[bool]:
        """
        Code of the external variables of jsonnet application.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the external variables of jsonnet application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the external variables of jsonnet application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceDirectoryJsonnetTla(dict):
    def __init__(__self__, *,
                 code: Optional[bool] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool code: Code of the TLAS of the jsonnet application.
        :param str name: Name of the TLAS of the jsonnet application.
        :param str value: Value of the TLAS of the jsonnet application.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[bool]:
        """
        Code of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceHelm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileParameters":
            suggest = "file_parameters"
        elif key == "passCredentials":
            suggest = "pass_credentials"
        elif key == "releaseName":
            suggest = "release_name"
        elif key == "valueFiles":
            suggest = "value_files"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSourceHelm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSourceHelm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSourceHelm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_parameters: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceHelmFileParameter']] = None,
                 parameters: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceHelmParameter']] = None,
                 pass_credentials: Optional[bool] = None,
                 release_name: Optional[str] = None,
                 value_files: Optional[Sequence[str]] = None,
                 values: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationSpecSourceHelmFileParameterArgs'] file_parameters: File parameters to the helm template.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceHelmParameterArgs'] parameters: List of helm parameters which are passed to the helm template command upon manifest generation.
        :param bool pass_credentials: Indicates if to pass credentials to all domains (helm's --pass-credentials)
        :param str release_name: Helm release name to use. If omitted it will use the GitOps application name.
        :param Sequence[str] value_files: List of helm value files to use when generating a template.
        :param str values: Helm values to be passed to helm template, typically defined as a block.
        :param str version: Helm version to use for templating (either "2" or "3")
        """
        if file_parameters is not None:
            pulumi.set(__self__, "file_parameters", file_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pass_credentials is not None:
            pulumi.set(__self__, "pass_credentials", pass_credentials)
        if release_name is not None:
            pulumi.set(__self__, "release_name", release_name)
        if value_files is not None:
            pulumi.set(__self__, "value_files", value_files)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="fileParameters")
    def file_parameters(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceHelmFileParameter']]:
        """
        File parameters to the helm template.
        """
        return pulumi.get(self, "file_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceHelmParameter']]:
        """
        List of helm parameters which are passed to the helm template command upon manifest generation.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="passCredentials")
    def pass_credentials(self) -> Optional[bool]:
        """
        Indicates if to pass credentials to all domains (helm's --pass-credentials)
        """
        return pulumi.get(self, "pass_credentials")

    @property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> Optional[str]:
        """
        Helm release name to use. If omitted it will use the GitOps application name.
        """
        return pulumi.get(self, "release_name")

    @property
    @pulumi.getter(name="valueFiles")
    def value_files(self) -> Optional[Sequence[str]]:
        """
        List of helm value files to use when generating a template.
        """
        return pulumi.get(self, "value_files")

    @property
    @pulumi.getter
    def values(self) -> Optional[str]:
        """
        Helm values to be passed to helm template, typically defined as a block.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Helm version to use for templating (either "2" or "3")
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceHelmFileParameter(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str name: Name of the helm parameter.
        :param str path: Path to the file containing the values of the helm parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the helm parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to the file containing the values of the helm parameter.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceHelmParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forceString":
            suggest = "force_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSourceHelmParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSourceHelmParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSourceHelmParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 force_string: Optional[bool] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool force_string: Indicates if helm should interpret booleans and numbers as strings.
        :param str name: Name of the helm parameter.
        :param str value: Value of the Helm parameter.
        """
        if force_string is not None:
            pulumi.set(__self__, "force_string", force_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="forceString")
    def force_string(self) -> Optional[bool]:
        """
        Indicates if helm should interpret booleans and numbers as strings.
        """
        return pulumi.get(self, "force_string")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the helm parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the Helm parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceKsonnet(dict):
    def __init__(__self__, *,
                 environment: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceKsonnetParameter']] = None):
        """
        :param str environment: Ksonnet application environment name.
        :param Sequence['GitOpsApplicationsApplicationSpecSourceKsonnetParameterArgs'] parameters: List of ksonnet component parameter override values.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Ksonnet application environment name.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourceKsonnetParameter']]:
        """
        List of ksonnet component parameter override values.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceKsonnetParameter(dict):
    def __init__(__self__, *,
                 component: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str component: Component of the parameter of the ksonnet application.
        :param str name: Name of the parameter of the ksonnet application.
        :param str value: Value of the parameter of the ksonnet application.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        Component of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourceKustomize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commonAnnotations":
            suggest = "common_annotations"
        elif key == "commonLabels":
            suggest = "common_labels"
        elif key == "forceCommonAnnotations":
            suggest = "force_common_annotations"
        elif key == "forceCommonLabels":
            suggest = "force_common_labels"
        elif key == "namePrefix":
            suggest = "name_prefix"
        elif key == "nameSuffix":
            suggest = "name_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSourceKustomize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSourceKustomize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSourceKustomize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 common_annotations: Optional[Mapping[str, str]] = None,
                 common_labels: Optional[Mapping[str, str]] = None,
                 force_common_annotations: Optional[bool] = None,
                 force_common_labels: Optional[bool] = None,
                 images: Optional[Sequence[str]] = None,
                 name_prefix: Optional[str] = None,
                 name_suffix: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param Mapping[str, str] common_annotations: List of additional annotations to add to rendered manifests.
        :param Mapping[str, str] common_labels: List of additional labels to add to rendered manifests.
        :param bool force_common_annotations: Indicates if to force applying common annotations to resources for kustomize apps.
        :param bool force_common_labels: Indicates if to force apply common labels to resources for kustomize apps.
        :param Sequence[str] images: List of kustomize image override specifications.
        :param str name_prefix: Prefix prepended to resources for kustomize apps.
        :param str name_suffix: Suffix appended to resources for kustomize apps.
        :param str version: Version of kustomize to use for rendering manifests.
        """
        if common_annotations is not None:
            pulumi.set(__self__, "common_annotations", common_annotations)
        if common_labels is not None:
            pulumi.set(__self__, "common_labels", common_labels)
        if force_common_annotations is not None:
            pulumi.set(__self__, "force_common_annotations", force_common_annotations)
        if force_common_labels is not None:
            pulumi.set(__self__, "force_common_labels", force_common_labels)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if name_prefix is not None:
            pulumi.set(__self__, "name_prefix", name_prefix)
        if name_suffix is not None:
            pulumi.set(__self__, "name_suffix", name_suffix)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="commonAnnotations")
    def common_annotations(self) -> Optional[Mapping[str, str]]:
        """
        List of additional annotations to add to rendered manifests.
        """
        return pulumi.get(self, "common_annotations")

    @property
    @pulumi.getter(name="commonLabels")
    def common_labels(self) -> Optional[Mapping[str, str]]:
        """
        List of additional labels to add to rendered manifests.
        """
        return pulumi.get(self, "common_labels")

    @property
    @pulumi.getter(name="forceCommonAnnotations")
    def force_common_annotations(self) -> Optional[bool]:
        """
        Indicates if to force applying common annotations to resources for kustomize apps.
        """
        return pulumi.get(self, "force_common_annotations")

    @property
    @pulumi.getter(name="forceCommonLabels")
    def force_common_labels(self) -> Optional[bool]:
        """
        Indicates if to force apply common labels to resources for kustomize apps.
        """
        return pulumi.get(self, "force_common_labels")

    @property
    @pulumi.getter
    def images(self) -> Optional[Sequence[str]]:
        """
        List of kustomize image override specifications.
        """
        return pulumi.get(self, "images")

    @property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> Optional[str]:
        """
        Prefix prepended to resources for kustomize apps.
        """
        return pulumi.get(self, "name_prefix")

    @property
    @pulumi.getter(name="nameSuffix")
    def name_suffix(self) -> Optional[str]:
        """
        Suffix appended to resources for kustomize apps.
        """
        return pulumi.get(self, "name_suffix")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of kustomize to use for rendering manifests.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourcePlugin(dict):
    def __init__(__self__, *,
                 envs: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourcePluginEnv']] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationSpecSourcePluginEnvArgs'] envs: Entry in the GitOps application's environment.
        :param str name: Name of the plugin.
        """
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSourcePluginEnv']]:
        """
        Entry in the GitOps application's environment.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSourcePluginEnv(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name of the variable, usually expressed in uppercase.
        :param str value: Value of the variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the variable, usually expressed in uppercase.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSyncPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "syncOptions":
            suggest = "sync_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSyncPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSyncPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSyncPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 automateds: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicyAutomated']] = None,
                 retries: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicyRetry']] = None,
                 sync_options: Optional[Sequence[str]] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationSpecSyncPolicyAutomatedArgs'] automateds: Controls the behavior of an automated sync.
        :param Sequence['GitOpsApplicationsApplicationSpecSyncPolicyRetryArgs'] retries: Contains information about the strategy to apply when a sync failed.
        :param Sequence[str] sync_options: Options allow you to specify whole app sync-options.
        """
        if automateds is not None:
            pulumi.set(__self__, "automateds", automateds)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if sync_options is not None:
            pulumi.set(__self__, "sync_options", sync_options)

    @property
    @pulumi.getter
    def automateds(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicyAutomated']]:
        """
        Controls the behavior of an automated sync.
        """
        return pulumi.get(self, "automateds")

    @property
    @pulumi.getter
    def retries(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicyRetry']]:
        """
        Contains information about the strategy to apply when a sync failed.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter(name="syncOptions")
    def sync_options(self) -> Optional[Sequence[str]]:
        """
        Options allow you to specify whole app sync-options.
        """
        return pulumi.get(self, "sync_options")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSyncPolicyAutomated(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowEmpty":
            suggest = "allow_empty"
        elif key == "selfHeal":
            suggest = "self_heal"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSyncPolicyAutomated. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSyncPolicyAutomated.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSyncPolicyAutomated.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_empty: Optional[bool] = None,
                 prune: Optional[bool] = None,
                 self_heal: Optional[bool] = None):
        """
        :param bool allow_empty: Indicates to allows apps to have zero live resources (default: false).
        :param bool prune: Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        :param bool self_heal: Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
        if allow_empty is not None:
            pulumi.set(__self__, "allow_empty", allow_empty)
        if prune is not None:
            pulumi.set(__self__, "prune", prune)
        if self_heal is not None:
            pulumi.set(__self__, "self_heal", self_heal)

    @property
    @pulumi.getter(name="allowEmpty")
    def allow_empty(self) -> Optional[bool]:
        """
        Indicates to allows apps to have zero live resources (default: false).
        """
        return pulumi.get(self, "allow_empty")

    @property
    @pulumi.getter
    def prune(self) -> Optional[bool]:
        """
        Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        """
        return pulumi.get(self, "prune")

    @property
    @pulumi.getter(name="selfHeal")
    def self_heal(self) -> Optional[bool]:
        """
        Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
        return pulumi.get(self, "self_heal")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSyncPolicyRetry(dict):
    def __init__(__self__, *,
                 backoffs: Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff']] = None,
                 limit: Optional[str] = None):
        """
        :param Sequence['GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs'] backoffs: Backoff strategy to use on subsequent retries for failing syncs.
        :param str limit: Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
        if backoffs is not None:
            pulumi.set(__self__, "backoffs", backoffs)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def backoffs(self) -> Optional[Sequence['outputs.GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff']]:
        """
        Backoff strategy to use on subsequent retries for failing syncs.
        """
        return pulumi.get(self, "backoffs")

    @property
    @pulumi.getter
    def limit(self) -> Optional[str]:
        """
        Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxDuration":
            suggest = "max_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsApplicationsApplicationSpecSyncPolicyRetryBackoff.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 factor: Optional[str] = None,
                 max_duration: Optional[str] = None):
        """
        :param str duration: Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        :param str factor: Factor to multiply the base duration after each failed retry.
        :param str max_duration: Maximum amount of time allowed of the backoff strategy.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if factor is not None:
            pulumi.set(__self__, "factor", factor)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def factor(self) -> Optional[str]:
        """
        Factor to multiply the base duration after each failed retry.
        """
        return pulumi.get(self, "factor")

    @property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional[str]:
        """
        Maximum amount of time allowed of the backoff strategy.
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class GitOpsClusterRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "updatedFields":
            suggest = "updated_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 clusters: Optional[Sequence['outputs.GitOpsClusterRequestCluster']] = None,
                 tags: Optional[Sequence[str]] = None,
                 updated_fields: Optional[Sequence[str]] = None,
                 upsert: Optional[bool] = None):
        """
        :param Sequence['GitOpsClusterRequestClusterArgs'] clusters: GitOps cluster details.
        :param Sequence[str] tags: Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        :param Sequence[str] updated_fields: Fields which are updated.
        :param bool upsert: Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_fields is not None:
            pulumi.set(__self__, "updated_fields", updated_fields)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.GitOpsClusterRequestCluster']]:
        """
        GitOps cluster details.
        """
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="updatedFields")
    def updated_fields(self) -> Optional[Sequence[str]]:
        """
        Fields which are updated.
        """
        return pulumi.get(self, "updated_fields")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class GitOpsClusterRequestCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterResources":
            suggest = "cluster_resources"
        elif key == "refreshRequestedAts":
            suggest = "refresh_requested_ats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 configs: Sequence['outputs.GitOpsClusterRequestClusterConfig'],
                 server: str,
                 annotations: Optional[Mapping[str, str]] = None,
                 cluster_resources: Optional[bool] = None,
                 infos: Optional[Sequence['outputs.GitOpsClusterRequestClusterInfo']] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 project: Optional[str] = None,
                 refresh_requested_ats: Optional[Sequence['outputs.GitOpsClusterRequestClusterRefreshRequestedAt']] = None,
                 shard: Optional[str] = None):
        """
        :param Sequence['GitOpsClusterRequestClusterConfigArgs'] configs: GitOps cluster config.
        :param str server: API server URL of the kubernetes cluster.
        :param Mapping[str, str] annotations: Annotations for cluster secret metadata.
        :param bool cluster_resources: Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        :param Sequence['GitOpsClusterRequestClusterInfoArgs'] infos: Information about cluster cache and state.
        :param Mapping[str, str] labels: Labels for cluster secret metadata.
        :param str name: Name of the cluster. If omitted, the server address will be used.
        :param Sequence[str] namespaces: List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        :param str project: The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        :param Sequence['GitOpsClusterRequestClusterRefreshRequestedAtArgs'] refresh_requested_ats: Time when cluster cache refresh has been requested.
        :param str shard: Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
        pulumi.set(__self__, "configs", configs)
        pulumi.set(__self__, "server", server)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_resources is not None:
            pulumi.set(__self__, "cluster_resources", cluster_resources)
        if infos is not None:
            pulumi.set(__self__, "infos", infos)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if refresh_requested_ats is not None:
            pulumi.set(__self__, "refresh_requested_ats", refresh_requested_ats)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)

    @property
    @pulumi.getter
    def configs(self) -> Sequence['outputs.GitOpsClusterRequestClusterConfig']:
        """
        GitOps cluster config.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        API server URL of the kubernetes cluster.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations for cluster secret metadata.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterResources")
    def cluster_resources(self) -> Optional[bool]:
        """
        Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        """
        return pulumi.get(self, "cluster_resources")

    @property
    @pulumi.getter
    def infos(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterInfo']]:
        """
        Information about cluster cache and state.
        """
        return pulumi.get(self, "infos")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels for cluster secret metadata.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cluster. If omitted, the server address will be used.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="refreshRequestedAts")
    def refresh_requested_ats(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterRefreshRequestedAt']]:
        """
        Time when cluster cache refresh has been requested.
        """
        return pulumi.get(self, "refresh_requested_ats")

    @property
    @pulumi.getter
    def shard(self) -> Optional[str]:
        """
        Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
        return pulumi.get(self, "shard")


@pulumi.output_type
class GitOpsClusterRequestClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsClusterName":
            suggest = "aws_cluster_name"
        elif key == "bearerToken":
            suggest = "bearer_token"
        elif key == "clusterConnectionType":
            suggest = "cluster_connection_type"
        elif key == "disableCompression":
            suggest = "disable_compression"
        elif key == "execProviderConfigs":
            suggest = "exec_provider_configs"
        elif key == "proxyUrl":
            suggest = "proxy_url"
        elif key == "roleARN":
            suggest = "role_arn"
        elif key == "tlsClientConfigs":
            suggest = "tls_client_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_cluster_name: Optional[str] = None,
                 bearer_token: Optional[str] = None,
                 cluster_connection_type: Optional[str] = None,
                 disable_compression: Optional[bool] = None,
                 exec_provider_configs: Optional[Sequence['outputs.GitOpsClusterRequestClusterConfigExecProviderConfig']] = None,
                 password: Optional[str] = None,
                 proxy_url: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 tls_client_configs: Optional[Sequence['outputs.GitOpsClusterRequestClusterConfigTlsClientConfig']] = None,
                 username: Optional[str] = None):
        """
        :param str aws_cluster_name: AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        :param str bearer_token: Bearer authentication token the cluster.
        :param str cluster_connection_type: Identifies the authentication method used to connect to the cluster.
        :param bool disable_compression: DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        :param Sequence['GitOpsClusterRequestClusterConfigExecProviderConfigArgs'] exec_provider_configs: Configuration for an exec provider.
        :param str password: Password of the server of the cluster.
        :param str proxy_url: The URL to the proxy to be used for all requests send to the cluster's API server
        :param str role_arn: Optional role ARN. If set then used for AWS IAM Authenticator.
        :param Sequence['GitOpsClusterRequestClusterConfigTlsClientConfigArgs'] tls_client_configs: Settings to enable transport layer security.
        :param str username: Username of the server of the cluster.
        """
        if aws_cluster_name is not None:
            pulumi.set(__self__, "aws_cluster_name", aws_cluster_name)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if cluster_connection_type is not None:
            pulumi.set(__self__, "cluster_connection_type", cluster_connection_type)
        if disable_compression is not None:
            pulumi.set(__self__, "disable_compression", disable_compression)
        if exec_provider_configs is not None:
            pulumi.set(__self__, "exec_provider_configs", exec_provider_configs)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if tls_client_configs is not None:
            pulumi.set(__self__, "tls_client_configs", tls_client_configs)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="awsClusterName")
    def aws_cluster_name(self) -> Optional[str]:
        """
        AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        """
        return pulumi.get(self, "aws_cluster_name")

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[str]:
        """
        Bearer authentication token the cluster.
        """
        return pulumi.get(self, "bearer_token")

    @property
    @pulumi.getter(name="clusterConnectionType")
    def cluster_connection_type(self) -> Optional[str]:
        """
        Identifies the authentication method used to connect to the cluster.
        """
        return pulumi.get(self, "cluster_connection_type")

    @property
    @pulumi.getter(name="disableCompression")
    def disable_compression(self) -> Optional[bool]:
        """
        DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        """
        return pulumi.get(self, "disable_compression")

    @property
    @pulumi.getter(name="execProviderConfigs")
    def exec_provider_configs(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterConfigExecProviderConfig']]:
        """
        Configuration for an exec provider.
        """
        return pulumi.get(self, "exec_provider_configs")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password of the server of the cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        """
        The URL to the proxy to be used for all requests send to the cluster's API server
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter(name="roleARN")
    def role_arn(self) -> Optional[str]:
        """
        Optional role ARN. If set then used for AWS IAM Authenticator.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="tlsClientConfigs")
    def tls_client_configs(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterConfigTlsClientConfig']]:
        """
        Settings to enable transport layer security.
        """
        return pulumi.get(self, "tls_client_configs")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the server of the cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GitOpsClusterRequestClusterConfigExecProviderConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "installHint":
            suggest = "install_hint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestClusterConfigExecProviderConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestClusterConfigExecProviderConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestClusterConfigExecProviderConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[str] = None,
                 env: Optional[Mapping[str, str]] = None,
                 install_hint: Optional[str] = None):
        """
        :param str api_version: Preferred input version of the ExecInfo.
        :param Sequence[str] args: Arguments to pass to the command when executing it.
        :param str command: Command to execute.
        :param Mapping[str, str] env: Additional environment variables to expose to the process.
        :param str install_hint: Message displayed when the executable is not found.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if install_hint is not None:
            pulumi.set(__self__, "install_hint", install_hint)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Preferred input version of the ExecInfo.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to pass to the command when executing it.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[str]:
        """
        Command to execute.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        """
        Additional environment variables to expose to the process.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="installHint")
    def install_hint(self) -> Optional[str]:
        """
        Message displayed when the executable is not found.
        """
        return pulumi.get(self, "install_hint")


@pulumi.output_type
class GitOpsClusterRequestClusterConfigTlsClientConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caData":
            suggest = "ca_data"
        elif key == "certData":
            suggest = "cert_data"
        elif key == "keyData":
            suggest = "key_data"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestClusterConfigTlsClientConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestClusterConfigTlsClientConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestClusterConfigTlsClientConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_data: Optional[str] = None,
                 cert_data: Optional[str] = None,
                 insecure: Optional[bool] = None,
                 key_data: Optional[str] = None,
                 server_name: Optional[str] = None):
        """
        :param str ca_data: CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        :param str cert_data: Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        :param bool insecure: Indicates if the TLS connection to the cluster should be insecure.
        :param str key_data: Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        :param str server_name: Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
        if ca_data is not None:
            pulumi.set(__self__, "ca_data", ca_data)
        if cert_data is not None:
            pulumi.set(__self__, "cert_data", cert_data)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caData")
    def ca_data(self) -> Optional[str]:
        """
        CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        """
        return pulumi.get(self, "ca_data")

    @property
    @pulumi.getter(name="certData")
    def cert_data(self) -> Optional[str]:
        """
        Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "cert_data")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Indicates if the TLS connection to the cluster should be insecure.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[str]:
        """
        Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "key_data")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class GitOpsClusterRequestClusterInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersions":
            suggest = "api_versions"
        elif key == "applicationsCount":
            suggest = "applications_count"
        elif key == "cacheInfos":
            suggest = "cache_infos"
        elif key == "connectionStates":
            suggest = "connection_states"
        elif key == "serverVersion":
            suggest = "server_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestClusterInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestClusterInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestClusterInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_versions: Optional[Sequence[str]] = None,
                 applications_count: Optional[str] = None,
                 cache_infos: Optional[Sequence['outputs.GitOpsClusterRequestClusterInfoCacheInfo']] = None,
                 connection_states: Optional[Sequence['outputs.GitOpsClusterRequestClusterInfoConnectionState']] = None,
                 server_version: Optional[str] = None):
        """
        :param Sequence[str] api_versions: List of API versions supported by the cluster.
        :param str applications_count: Number of applications managed by Argo CD on the cluster.
        :param Sequence['GitOpsClusterRequestClusterInfoCacheInfoArgs'] cache_infos: Information about the cluster cache.
        :param Sequence['GitOpsClusterRequestClusterInfoConnectionStateArgs'] connection_states: Information about the connection to the cluster.
        :param str server_version: Kubernetes version of the cluster.
        """
        if api_versions is not None:
            pulumi.set(__self__, "api_versions", api_versions)
        if applications_count is not None:
            pulumi.set(__self__, "applications_count", applications_count)
        if cache_infos is not None:
            pulumi.set(__self__, "cache_infos", cache_infos)
        if connection_states is not None:
            pulumi.set(__self__, "connection_states", connection_states)
        if server_version is not None:
            pulumi.set(__self__, "server_version", server_version)

    @property
    @pulumi.getter(name="apiVersions")
    def api_versions(self) -> Optional[Sequence[str]]:
        """
        List of API versions supported by the cluster.
        """
        return pulumi.get(self, "api_versions")

    @property
    @pulumi.getter(name="applicationsCount")
    def applications_count(self) -> Optional[str]:
        """
        Number of applications managed by Argo CD on the cluster.
        """
        return pulumi.get(self, "applications_count")

    @property
    @pulumi.getter(name="cacheInfos")
    def cache_infos(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterInfoCacheInfo']]:
        """
        Information about the cluster cache.
        """
        return pulumi.get(self, "cache_infos")

    @property
    @pulumi.getter(name="connectionStates")
    def connection_states(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterInfoConnectionState']]:
        """
        Information about the connection to the cluster.
        """
        return pulumi.get(self, "connection_states")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> Optional[str]:
        """
        Kubernetes version of the cluster.
        """
        return pulumi.get(self, "server_version")


@pulumi.output_type
class GitOpsClusterRequestClusterInfoCacheInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apisCount":
            suggest = "apis_count"
        elif key == "lastCacheSyncTime":
            suggest = "last_cache_sync_time"
        elif key == "resourcesCount":
            suggest = "resources_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestClusterInfoCacheInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestClusterInfoCacheInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestClusterInfoCacheInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apis_count: Optional[str] = None,
                 last_cache_sync_time: Optional[str] = None,
                 resources_count: Optional[str] = None):
        """
        :param str apis_count: Number of observed kubernetes API count.
        :param str last_cache_sync_time: Time of most recent cache synchronization.
        :param str resources_count: Number of observed kubernetes resources.
        """
        if apis_count is not None:
            pulumi.set(__self__, "apis_count", apis_count)
        if last_cache_sync_time is not None:
            pulumi.set(__self__, "last_cache_sync_time", last_cache_sync_time)
        if resources_count is not None:
            pulumi.set(__self__, "resources_count", resources_count)

    @property
    @pulumi.getter(name="apisCount")
    def apis_count(self) -> Optional[str]:
        """
        Number of observed kubernetes API count.
        """
        return pulumi.get(self, "apis_count")

    @property
    @pulumi.getter(name="lastCacheSyncTime")
    def last_cache_sync_time(self) -> Optional[str]:
        """
        Time of most recent cache synchronization.
        """
        return pulumi.get(self, "last_cache_sync_time")

    @property
    @pulumi.getter(name="resourcesCount")
    def resources_count(self) -> Optional[str]:
        """
        Number of observed kubernetes resources.
        """
        return pulumi.get(self, "resources_count")


@pulumi.output_type
class GitOpsClusterRequestClusterInfoConnectionState(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attemptedAts":
            suggest = "attempted_ats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsClusterRequestClusterInfoConnectionState. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsClusterRequestClusterInfoConnectionState.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsClusterRequestClusterInfoConnectionState.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attempted_ats: Optional[Sequence['outputs.GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt']] = None,
                 message: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param Sequence['GitOpsClusterRequestClusterInfoConnectionStateAttemptedAtArgs'] attempted_ats: Time when cluster cache refresh has been requested.
        :param str message: Information about the connection status.
        :param str status: Current status indicator of the connection.
        """
        if attempted_ats is not None:
            pulumi.set(__self__, "attempted_ats", attempted_ats)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="attemptedAts")
    def attempted_ats(self) -> Optional[Sequence['outputs.GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt']]:
        """
        Time when cluster cache refresh has been requested.
        """
        return pulumi.get(self, "attempted_ats")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Information about the connection status.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Current status indicator of the connection.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GitOpsClusterRequestClusterInfoConnectionStateAttemptedAt(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        :param str seconds: Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GitOpsClusterRequestClusterRefreshRequestedAt(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        :param str seconds: Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GitOpsGnupgRequest(dict):
    def __init__(__self__, *,
                 upsert: bool,
                 publickeys: Optional[Sequence['outputs.GitOpsGnupgRequestPublickey']] = None):
        """
        :param bool upsert: Indicates if the GnuPG Key should be inserted if not present or updated if present.
        :param Sequence['GitOpsGnupgRequestPublickeyArgs'] publickeys: Public key details.
        """
        pulumi.set(__self__, "upsert", upsert)
        if publickeys is not None:
            pulumi.set(__self__, "publickeys", publickeys)

    @property
    @pulumi.getter
    def upsert(self) -> bool:
        """
        Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        return pulumi.get(self, "upsert")

    @property
    @pulumi.getter
    def publickeys(self) -> Optional[Sequence['outputs.GitOpsGnupgRequestPublickey']]:
        """
        Public key details.
        """
        return pulumi.get(self, "publickeys")


@pulumi.output_type
class GitOpsGnupgRequestPublickey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyData":
            suggest = "key_data"
        elif key == "keyId":
            suggest = "key_id"
        elif key == "subType":
            suggest = "sub_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsGnupgRequestPublickey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsGnupgRequestPublickey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsGnupgRequestPublickey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_data: str,
                 fingerprint: Optional[str] = None,
                 key_id: Optional[str] = None,
                 owner: Optional[str] = None,
                 sub_type: Optional[str] = None,
                 trust: Optional[str] = None):
        """
        :param str key_data: KeyData holds the raw key data, in base64 encoded format.
        :param str fingerprint: Fingerprint is the fingerprint of the key
        :param str key_id: KeyID specifies the key ID, in hexadecimal string format.
        :param str owner: Owner holds the owner identification, e.g. a name and e-mail address
        :param str sub_type: SubType holds the key's sub type
        :param str trust: Trust holds the level of trust assigned to this key
        """
        pulumi.set(__self__, "key_data", key_data)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)
        if trust is not None:
            pulumi.set(__self__, "trust", trust)

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> str:
        """
        KeyData holds the raw key data, in base64 encoded format.
        """
        return pulumi.get(self, "key_data")

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        """
        Fingerprint is the fingerprint of the key
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        KeyID specifies the key ID, in hexadecimal string format.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner holds the owner identification, e.g. a name and e-mail address
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[str]:
        """
        SubType holds the key's sub type
        """
        return pulumi.get(self, "sub_type")

    @property
    @pulumi.getter
    def trust(self) -> Optional[str]:
        """
        Trust holds the level of trust assigned to this key
        """
        return pulumi.get(self, "trust")


@pulumi.output_type
class GitOpsRepoCertRequest(dict):
    def __init__(__self__, *,
                 certificates: Optional[Sequence['outputs.GitOpsRepoCertRequestCertificate']] = None,
                 upsert: Optional[bool] = None):
        """
        :param Sequence['GitOpsRepoCertRequestCertificateArgs'] certificates: certificates details.
        :param bool upsert: Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
        """
        if certificates is not None:
            pulumi.set(__self__, "certificates", certificates)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def certificates(self) -> Optional[Sequence['outputs.GitOpsRepoCertRequestCertificate']]:
        """
        certificates details.
        """
        return pulumi.get(self, "certificates")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        Indicates if the GitOps repository certificate should be updated if existing and inserted if not.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class GitOpsRepoCertRequestCertificate(dict):
    def __init__(__self__, *,
                 items: Optional[Sequence['outputs.GitOpsRepoCertRequestCertificateItem']] = None,
                 metadatas: Optional[Sequence['outputs.GitOpsRepoCertRequestCertificateMetadata']] = None):
        """
        :param Sequence['GitOpsRepoCertRequestCertificateItemArgs'] items: List of certificates to be processed.
        :param Sequence['GitOpsRepoCertRequestCertificateMetadataArgs'] metadatas: metadata details
        """
        if items is not None:
            pulumi.set(__self__, "items", items)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)

    @property
    @pulumi.getter
    def items(self) -> Optional[Sequence['outputs.GitOpsRepoCertRequestCertificateItem']]:
        """
        List of certificates to be processed.
        """
        return pulumi.get(self, "items")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GitOpsRepoCertRequestCertificateMetadata']]:
        """
        metadata details
        """
        return pulumi.get(self, "metadatas")


@pulumi.output_type
class GitOpsRepoCertRequestCertificateItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certData":
            suggest = "cert_data"
        elif key == "certInfo":
            suggest = "cert_info"
        elif key == "certSubType":
            suggest = "cert_sub_type"
        elif key == "certType":
            suggest = "cert_type"
        elif key == "serverName":
            suggest = "server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepoCertRequestCertificateItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepoCertRequestCertificateItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepoCertRequestCertificateItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_data: Optional[str] = None,
                 cert_info: Optional[str] = None,
                 cert_sub_type: Optional[str] = None,
                 cert_type: Optional[str] = None,
                 server_name: Optional[str] = None):
        """
        :param str cert_data: CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
        :param str cert_info: CertInfo will hold additional certificate info, dependent on the certificate type .
        :param str cert_sub_type: CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
        :param str cert_type: CertType specifies the type of the certificate - currently one of https or ssh.
        :param str server_name: ServerName specifies the DNS name of the server this certificate is intended.
        """
        if cert_data is not None:
            pulumi.set(__self__, "cert_data", cert_data)
        if cert_info is not None:
            pulumi.set(__self__, "cert_info", cert_info)
        if cert_sub_type is not None:
            pulumi.set(__self__, "cert_sub_type", cert_sub_type)
        if cert_type is not None:
            pulumi.set(__self__, "cert_type", cert_type)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="certData")
    def cert_data(self) -> Optional[str]:
        """
        CertData contains the actual certificate data, dependent on the certificate type. The value should be base64 encoded
        """
        return pulumi.get(self, "cert_data")

    @property
    @pulumi.getter(name="certInfo")
    def cert_info(self) -> Optional[str]:
        """
        CertInfo will hold additional certificate info, dependent on the certificate type .
        """
        return pulumi.get(self, "cert_info")

    @property
    @pulumi.getter(name="certSubType")
    def cert_sub_type(self) -> Optional[str]:
        """
        CertSubType specifies the sub type of the cert, i.e. ssh-rsa.
        """
        return pulumi.get(self, "cert_sub_type")

    @property
    @pulumi.getter(name="certType")
    def cert_type(self) -> Optional[str]:
        """
        CertType specifies the type of the certificate - currently one of https or ssh.
        """
        return pulumi.get(self, "cert_type")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        ServerName specifies the DNS name of the server this certificate is intended.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class GitOpsRepoCertRequestCertificateMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "continue":
            suggest = "continue_"
        elif key == "remainingItemCount":
            suggest = "remaining_item_count"
        elif key == "resourceVersion":
            suggest = "resource_version"
        elif key == "selfLink":
            suggest = "self_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepoCertRequestCertificateMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepoCertRequestCertificateMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepoCertRequestCertificateMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 continue_: Optional[str] = None,
                 remaining_item_count: Optional[str] = None,
                 resource_version: Optional[str] = None,
                 self_link: Optional[str] = None):
        """
        :param str continue_: continue may be set if the user set a limit on the number of items returned.
        :param str remaining_item_count: subsequent items in the list.
        :param str resource_version: Identifies the server's internal version.
        :param str self_link: selfLink is a URL representing this object.
        """
        if continue_ is not None:
            pulumi.set(__self__, "continue_", continue_)
        if remaining_item_count is not None:
            pulumi.set(__self__, "remaining_item_count", remaining_item_count)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)
        if self_link is not None:
            pulumi.set(__self__, "self_link", self_link)

    @property
    @pulumi.getter(name="continue")
    def continue_(self) -> Optional[str]:
        """
        continue may be set if the user set a limit on the number of items returned.
        """
        return pulumi.get(self, "continue_")

    @property
    @pulumi.getter(name="remainingItemCount")
    def remaining_item_count(self) -> Optional[str]:
        """
        subsequent items in the list.
        """
        return pulumi.get(self, "remaining_item_count")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Identifies the server's internal version.
        """
        return pulumi.get(self, "resource_version")

    @property
    @pulumi.getter(name="selfLink")
    def self_link(self) -> Optional[str]:
        """
        selfLink is a URL representing this object.
        """
        return pulumi.get(self, "self_link")


@pulumi.output_type
class GitOpsRepoCredCred(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableOci":
            suggest = "enable_oci"
        elif key == "githubAppEnterpriseBaseUrl":
            suggest = "github_app_enterprise_base_url"
        elif key == "githubAppId":
            suggest = "github_app_id"
        elif key == "githubAppInstallationId":
            suggest = "github_app_installation_id"
        elif key == "githubAppPrivateKey":
            suggest = "github_app_private_key"
        elif key == "sshPrivateKey":
            suggest = "ssh_private_key"
        elif key == "tlsClientCertData":
            suggest = "tls_client_cert_data"
        elif key == "tlsClientCertKey":
            suggest = "tls_client_cert_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepoCredCred. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepoCredCred.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepoCredCred.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_oci: Optional[bool] = None,
                 github_app_enterprise_base_url: Optional[str] = None,
                 github_app_id: Optional[str] = None,
                 github_app_installation_id: Optional[str] = None,
                 github_app_private_key: Optional[str] = None,
                 password: Optional[str] = None,
                 ssh_private_key: Optional[str] = None,
                 tls_client_cert_data: Optional[str] = None,
                 tls_client_cert_key: Optional[str] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param bool enable_oci: Specifies whether helm-oci support should be enabled for this repo.
        :param str github_app_enterprise_base_url: Specifies the GitHub API URL for GitHub app authentication.
        :param str github_app_id: Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        :param str github_app_installation_id: Specifies the ID of the installed GitHub App for GitHub app authentication.
        :param str github_app_private_key: github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        :param str password: Password or PAT to be used for authenticating the remote repository.
        :param str ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param str tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        :param str tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        :param str type: Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        :param str url: URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        :param str username: Username to be used for authenticating the remote repository.
        """
        if enable_oci is not None:
            pulumi.set(__self__, "enable_oci", enable_oci)
        if github_app_enterprise_base_url is not None:
            pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        if github_app_id is not None:
            pulumi.set(__self__, "github_app_id", github_app_id)
        if github_app_installation_id is not None:
            pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        if github_app_private_key is not None:
            pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if ssh_private_key is not None:
            pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        if tls_client_cert_data is not None:
            pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        if tls_client_cert_key is not None:
            pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> Optional[bool]:
        """
        Specifies whether helm-oci support should be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> Optional[str]:
        """
        Specifies the GitHub API URL for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> Optional[str]:
        """
        Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_id")

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> Optional[str]:
        """
        Specifies the ID of the installed GitHub App for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_installation_id")

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> Optional[str]:
        """
        github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        """
        return pulumi.get(self, "github_app_private_key")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> Optional[str]:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> Optional[str]:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> Optional[str]:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GitOpsRepositoryEcrGen(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jwtAuth":
            suggest = "jwt_auth"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepositoryEcrGen. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepositoryEcrGen.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepositoryEcrGen.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jwt_auth: Optional['outputs.GitOpsRepositoryEcrGenJwtAuth'] = None,
                 region: Optional[str] = None,
                 secret_ref: Optional['outputs.GitOpsRepositoryEcrGenSecretRef'] = None):
        """
        :param 'GitOpsRepositoryEcrGenJwtAuthArgs' jwt_auth: JWT authentication specific configuration.
        :param str region: AWS region.
        :param 'GitOpsRepositoryEcrGenSecretRefArgs' secret_ref: Secret reference to the AWS credentials.
        """
        if jwt_auth is not None:
            pulumi.set(__self__, "jwt_auth", jwt_auth)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="jwtAuth")
    def jwt_auth(self) -> Optional['outputs.GitOpsRepositoryEcrGenJwtAuth']:
        """
        JWT authentication specific configuration.
        """
        return pulumi.get(self, "jwt_auth")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        AWS region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional['outputs.GitOpsRepositoryEcrGenSecretRef']:
        """
        Secret reference to the AWS credentials.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GitOpsRepositoryEcrGenJwtAuth(dict):
    def __init__(__self__, *,
                 audiences: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param Sequence[str] audiences: Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        :param str name: The name of the ServiceAccount resource being referred to.
        :param str namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[str]]:
        """
        Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        """
        return pulumi.get(self, "audiences")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ServiceAccount resource being referred to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GitOpsRepositoryEcrGenSecretRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "awsAccessKeyId":
            suggest = "aws_access_key_id"
        elif key == "awsSecretAccessKey":
            suggest = "aws_secret_access_key"
        elif key == "awsSessionToken":
            suggest = "aws_session_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepositoryEcrGenSecretRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepositoryEcrGenSecretRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepositoryEcrGenSecretRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aws_access_key_id: Optional[str] = None,
                 aws_secret_access_key: Optional[str] = None,
                 aws_session_token: Optional[str] = None):
        """
        :param str aws_access_key_id: AWS access key id.
        :param str aws_secret_access_key: AWS secret access key.
        :param str aws_session_token: AWS session token.
        """
        if aws_access_key_id is not None:
            pulumi.set(__self__, "aws_access_key_id", aws_access_key_id)
        if aws_secret_access_key is not None:
            pulumi.set(__self__, "aws_secret_access_key", aws_secret_access_key)
        if aws_session_token is not None:
            pulumi.set(__self__, "aws_session_token", aws_session_token)

    @property
    @pulumi.getter(name="awsAccessKeyId")
    def aws_access_key_id(self) -> Optional[str]:
        """
        AWS access key id.
        """
        return pulumi.get(self, "aws_access_key_id")

    @property
    @pulumi.getter(name="awsSecretAccessKey")
    def aws_secret_access_key(self) -> Optional[str]:
        """
        AWS secret access key.
        """
        return pulumi.get(self, "aws_secret_access_key")

    @property
    @pulumi.getter(name="awsSessionToken")
    def aws_session_token(self) -> Optional[str]:
        """
        AWS session token.
        """
        return pulumi.get(self, "aws_session_token")


@pulumi.output_type
class GitOpsRepositoryGcrGen(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "workloadIdentity":
            suggest = "workload_identity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepositoryGcrGen. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepositoryGcrGen.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepositoryGcrGen.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 project_id: Optional[str] = None,
                 workload_identity: Optional['outputs.GitOpsRepositoryGcrGenWorkloadIdentity'] = None):
        """
        :param str access_key: GCP access key.
        :param str project_id: GCP project id.
        :param 'GitOpsRepositoryGcrGenWorkloadIdentityArgs' workload_identity: GCP workload identity.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if workload_identity is not None:
            pulumi.set(__self__, "workload_identity", workload_identity)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        GCP access key.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        GCP project id.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter(name="workloadIdentity")
    def workload_identity(self) -> Optional['outputs.GitOpsRepositoryGcrGenWorkloadIdentity']:
        """
        GCP workload identity.
        """
        return pulumi.get(self, "workload_identity")


@pulumi.output_type
class GitOpsRepositoryGcrGenWorkloadIdentity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterLocation":
            suggest = "cluster_location"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "clusterProjectId":
            suggest = "cluster_project_id"
        elif key == "serviceAccountRef":
            suggest = "service_account_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepositoryGcrGenWorkloadIdentity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepositoryGcrGenWorkloadIdentity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepositoryGcrGenWorkloadIdentity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_location: Optional[str] = None,
                 cluster_name: Optional[str] = None,
                 cluster_project_id: Optional[str] = None,
                 service_account_ref: Optional['outputs.GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRef'] = None):
        """
        :param str cluster_location: Cluster location.
        :param str cluster_name: Cluster name.
        :param str cluster_project_id: Cluster project id.
        :param 'GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRefArgs' service_account_ref: Service account reference.
        """
        if cluster_location is not None:
            pulumi.set(__self__, "cluster_location", cluster_location)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if cluster_project_id is not None:
            pulumi.set(__self__, "cluster_project_id", cluster_project_id)
        if service_account_ref is not None:
            pulumi.set(__self__, "service_account_ref", service_account_ref)

    @property
    @pulumi.getter(name="clusterLocation")
    def cluster_location(self) -> Optional[str]:
        """
        Cluster location.
        """
        return pulumi.get(self, "cluster_location")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Cluster name.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter(name="clusterProjectId")
    def cluster_project_id(self) -> Optional[str]:
        """
        Cluster project id.
        """
        return pulumi.get(self, "cluster_project_id")

    @property
    @pulumi.getter(name="serviceAccountRef")
    def service_account_ref(self) -> Optional['outputs.GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRef']:
        """
        Service account reference.
        """
        return pulumi.get(self, "service_account_ref")


@pulumi.output_type
class GitOpsRepositoryGcrGenWorkloadIdentityServiceAccountRef(dict):
    def __init__(__self__, *,
                 audiences: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param Sequence[str] audiences: Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        :param str name: The name of the ServiceAccount resource being referred to.
        :param str namespace: Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[str]]:
        """
        Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
        """
        return pulumi.get(self, "audiences")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the ServiceAccount resource being referred to.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class GitOpsRepositoryRepo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionType":
            suggest = "connection_type"
        elif key == "enableLfs":
            suggest = "enable_lfs"
        elif key == "enableOci":
            suggest = "enable_oci"
        elif key == "githubAppEnterpriseBaseUrl":
            suggest = "github_app_enterprise_base_url"
        elif key == "githubAppId":
            suggest = "github_app_id"
        elif key == "githubAppInstallationId":
            suggest = "github_app_installation_id"
        elif key == "githubAppPrivateKey":
            suggest = "github_app_private_key"
        elif key == "inheritedCreds":
            suggest = "inherited_creds"
        elif key == "insecureIgnoreHostKey":
            suggest = "insecure_ignore_host_key"
        elif key == "sshPrivateKey":
            suggest = "ssh_private_key"
        elif key == "tlsClientCertData":
            suggest = "tls_client_cert_data"
        elif key == "tlsClientCertKey":
            suggest = "tls_client_cert_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitOpsRepositoryRepo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitOpsRepositoryRepo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitOpsRepositoryRepo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_type: str,
                 repo: str,
                 enable_lfs: Optional[bool] = None,
                 enable_oci: Optional[bool] = None,
                 github_app_enterprise_base_url: Optional[str] = None,
                 github_app_id: Optional[str] = None,
                 github_app_installation_id: Optional[str] = None,
                 github_app_private_key: Optional[str] = None,
                 inherited_creds: Optional[bool] = None,
                 insecure: Optional[bool] = None,
                 insecure_ignore_host_key: Optional[bool] = None,
                 name: Optional[str] = None,
                 password: Optional[str] = None,
                 project: Optional[str] = None,
                 proxy: Optional[str] = None,
                 ssh_private_key: Optional[str] = None,
                 tls_client_cert_data: Optional[str] = None,
                 tls_client_cert_key: Optional[str] = None,
                 type_: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str connection_type: Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS*ANONYMOUS", "GITHUB*ENTERPRISE".
        :param str repo: URL to the remote repository.
        :param bool enable_lfs: Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        :param bool enable_oci: Indicates if helm-oci support must be enabled for this repo.
        :param str github_app_enterprise_base_url: Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        :param str github_app_id: Id of the GitHub app used to access the repo.
        :param str github_app_installation_id: Installation id of the GitHub app used to access the repo.
        :param str github_app_private_key: GitHub app private key PEM data.
        :param bool inherited_creds: Indicates if the credentials were inherited from a repository credential.
        :param bool insecure: Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        :param bool insecure_ignore_host_key: Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        :param str name: Name to be used for this repo. Only used with Helm repos.
        :param str password: Password or PAT to be used for authenticating the remote repository.
        :param str project: The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        :param str proxy: The HTTP/HTTPS proxy used to access the repo.
        :param str ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param str tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        :param str tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        :param str type_: Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        :param str username: Username to be used for authenticating the remote repository.
        """
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "repo", repo)
        if enable_lfs is not None:
            pulumi.set(__self__, "enable_lfs", enable_lfs)
        if enable_oci is not None:
            pulumi.set(__self__, "enable_oci", enable_oci)
        if github_app_enterprise_base_url is not None:
            pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        if github_app_id is not None:
            pulumi.set(__self__, "github_app_id", github_app_id)
        if github_app_installation_id is not None:
            pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        if github_app_private_key is not None:
            pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        if inherited_creds is not None:
            pulumi.set(__self__, "inherited_creds", inherited_creds)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if insecure_ignore_host_key is not None:
            pulumi.set(__self__, "insecure_ignore_host_key", insecure_ignore_host_key)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if ssh_private_key is not None:
            pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        if tls_client_cert_data is not None:
            pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        if tls_client_cert_key is not None:
            pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        if type_ is not None:
            pulumi.set(__self__, "type_", type_)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS*ANONYMOUS", "GITHUB*ENTERPRISE".
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter
    def repo(self) -> str:
        """
        URL to the remote repository.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter(name="enableLfs")
    def enable_lfs(self) -> Optional[bool]:
        """
        Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        """
        return pulumi.get(self, "enable_lfs")

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> Optional[bool]:
        """
        Indicates if helm-oci support must be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> Optional[str]:
        """
        Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> Optional[str]:
        """
        Id of the GitHub app used to access the repo.
        """
        return pulumi.get(self, "github_app_id")

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> Optional[str]:
        """
        Installation id of the GitHub app used to access the repo.
        """
        return pulumi.get(self, "github_app_installation_id")

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> Optional[str]:
        """
        GitHub app private key PEM data.
        """
        return pulumi.get(self, "github_app_private_key")

    @property
    @pulumi.getter(name="inheritedCreds")
    def inherited_creds(self) -> Optional[bool]:
        """
        Indicates if the credentials were inherited from a repository credential.
        """
        return pulumi.get(self, "inherited_creds")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="insecureIgnoreHostKey")
    def insecure_ignore_host_key(self) -> Optional[bool]:
        """
        Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        """
        return pulumi.get(self, "insecure_ignore_host_key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name to be used for this repo. Only used with Helm repos.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        The HTTP/HTTPS proxy used to access the repo.
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> Optional[str]:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> Optional[str]:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> Optional[str]:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @property
    @pulumi.getter
    def type_(self) -> Optional[str]:
        """
        Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        """
        return pulumi.get(self, "type_")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GitOpsRepositoryUpdateMask(dict):
    def __init__(__self__, *,
                 paths: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] paths: The set of field mask paths.
        """
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @property
    @pulumi.getter
    def paths(self) -> Optional[Sequence[str]]:
        """
        The set of field mask paths.
        """
        return pulumi.get(self, "paths")


@pulumi.output_type
class GithubConnectorApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "githubApp":
            suggest = "github_app"
        elif key == "tokenRef":
            suggest = "token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubConnectorApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubConnectorApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubConnectorApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 github_app: Optional['outputs.GithubConnectorApiAuthenticationGithubApp'] = None,
                 token_ref: Optional[str] = None):
        """
        :param 'GithubConnectorApiAuthenticationGithubAppArgs' github_app: Configuration for using the github app for interacting with the github api.
        :param str token_ref: Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if github_app is not None:
            pulumi.set(__self__, "github_app", github_app)
        if token_ref is not None:
            pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="githubApp")
    def github_app(self) -> Optional['outputs.GithubConnectorApiAuthenticationGithubApp']:
        """
        Configuration for using the github app for interacting with the github api.
        """
        return pulumi.get(self, "github_app")

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> Optional[str]:
        """
        Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class GithubConnectorApiAuthenticationGithubApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKeyRef":
            suggest = "private_key_ref"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "applicationIdRef":
            suggest = "application_id_ref"
        elif key == "installationId":
            suggest = "installation_id"
        elif key == "installationIdRef":
            suggest = "installation_id_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubConnectorApiAuthenticationGithubApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubConnectorApiAuthenticationGithubApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubConnectorApiAuthenticationGithubApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key_ref: str,
                 application_id: Optional[str] = None,
                 application_id_ref: Optional[str] = None,
                 installation_id: Optional[str] = None,
                 installation_id_ref: Optional[str] = None):
        """
        :param str private_key_ref: Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str application_id: Enter the GitHub App ID from the GitHub App General tab.
        :param str application_id_ref: Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str installation_id: Enter the Installation ID located in the URL of the installed GitHub App.
        :param str installation_id_ref: Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_id_ref is not None:
            pulumi.set(__self__, "application_id_ref", application_id_ref)
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)
        if installation_id_ref is not None:
            pulumi.set(__self__, "installation_id_ref", installation_id_ref)

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> str:
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationIdRef")
    def application_id_ref(self) -> Optional[str]:
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "application_id_ref")

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[str]:
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        return pulumi.get(self, "installation_id")

    @property
    @pulumi.getter(name="installationIdRef")
    def installation_id_ref(self) -> Optional[str]:
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "installation_id_ref")


@pulumi.output_type
class GithubConnectorCredentials(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.GithubConnectorCredentialsHttp'] = None,
                 ssh: Optional['outputs.GithubConnectorCredentialsSsh'] = None):
        """
        :param 'GithubConnectorCredentialsHttpArgs' http: Authenticate using Username and password over http(s) for the connection.
        :param 'GithubConnectorCredentialsSshArgs' ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.GithubConnectorCredentialsHttp']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def ssh(self) -> Optional['outputs.GithubConnectorCredentialsSsh']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class GithubConnectorCredentialsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "githubApp":
            suggest = "github_app"
        elif key == "tokenRef":
            suggest = "token_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubConnectorCredentialsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubConnectorCredentialsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubConnectorCredentialsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anonymouses: Optional[Sequence['outputs.GithubConnectorCredentialsHttpAnonymouse']] = None,
                 github_app: Optional['outputs.GithubConnectorCredentialsHttpGithubApp'] = None,
                 token_ref: Optional[str] = None,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param Sequence['GithubConnectorCredentialsHttpAnonymouseArgs'] anonymouses: Configuration for using the http anonymous github for interacting with the github api.
        :param 'GithubConnectorCredentialsHttpGithubAppArgs' github_app: Configuration for using the github app for interacting with the github api.
        :param str token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if anonymouses is not None:
            pulumi.set(__self__, "anonymouses", anonymouses)
        if github_app is not None:
            pulumi.set(__self__, "github_app", github_app)
        if token_ref is not None:
            pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter
    def anonymouses(self) -> Optional[Sequence['outputs.GithubConnectorCredentialsHttpAnonymouse']]:
        """
        Configuration for using the http anonymous github for interacting with the github api.
        """
        return pulumi.get(self, "anonymouses")

    @property
    @pulumi.getter(name="githubApp")
    def github_app(self) -> Optional['outputs.GithubConnectorCredentialsHttpGithubApp']:
        """
        Configuration for using the github app for interacting with the github api.
        """
        return pulumi.get(self, "github_app")

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GithubConnectorCredentialsHttpAnonymouse(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GithubConnectorCredentialsHttpGithubApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKeyRef":
            suggest = "private_key_ref"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "applicationIdRef":
            suggest = "application_id_ref"
        elif key == "installationId":
            suggest = "installation_id"
        elif key == "installationIdRef":
            suggest = "installation_id_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubConnectorCredentialsHttpGithubApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubConnectorCredentialsHttpGithubApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubConnectorCredentialsHttpGithubApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key_ref: str,
                 application_id: Optional[str] = None,
                 application_id_ref: Optional[str] = None,
                 installation_id: Optional[str] = None,
                 installation_id_ref: Optional[str] = None):
        """
        :param str private_key_ref: Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str application_id: Enter the GitHub App ID from the GitHub App General tab.
        :param str application_id_ref: Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str installation_id: Enter the Installation ID located in the URL of the installed GitHub App.
        :param str installation_id_ref: Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if application_id_ref is not None:
            pulumi.set(__self__, "application_id_ref", application_id_ref)
        if installation_id is not None:
            pulumi.set(__self__, "installation_id", installation_id)
        if installation_id_ref is not None:
            pulumi.set(__self__, "installation_id_ref", installation_id_ref)

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> str:
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationIdRef")
    def application_id_ref(self) -> Optional[str]:
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "application_id_ref")

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> Optional[str]:
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        return pulumi.get(self, "installation_id")

    @property
    @pulumi.getter(name="installationIdRef")
    def installation_id_ref(self) -> Optional[str]:
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "installation_id_ref")


@pulumi.output_type
class GithubConnectorCredentialsSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeyRef":
            suggest = "ssh_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GithubConnectorCredentialsSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GithubConnectorCredentialsSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GithubConnectorCredentialsSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GitlabConnectorApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenRef":
            suggest = "token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitlabConnectorApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitlabConnectorApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitlabConnectorApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class GitlabConnectorCredentials(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.GitlabConnectorCredentialsHttp'] = None,
                 ssh: Optional['outputs.GitlabConnectorCredentialsSsh'] = None):
        """
        :param 'GitlabConnectorCredentialsHttpArgs' http: Authenticate using Username and password over http(s) for the connection.
        :param 'GitlabConnectorCredentialsSshArgs' ssh: Authenticate using SSH for the connection.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if ssh is not None:
            pulumi.set(__self__, "ssh", ssh)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.GitlabConnectorCredentialsHttp']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def ssh(self) -> Optional['outputs.GitlabConnectorCredentialsSsh']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "ssh")


@pulumi.output_type
class GitlabConnectorCredentialsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "tokenRef":
            suggest = "token_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitlabConnectorCredentialsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitlabConnectorCredentialsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitlabConnectorCredentialsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: Optional[str] = None,
                 token_ref: Optional[str] = None,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        if password_ref is not None:
            pulumi.set(__self__, "password_ref", password_ref)
        if token_ref is not None:
            pulumi.set(__self__, "token_ref", token_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GitlabConnectorCredentialsSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeyRef":
            suggest = "ssh_key_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitlabConnectorCredentialsSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitlabConnectorCredentialsSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitlabConnectorCredentialsSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GitopsAppProjectProject(dict):
    def __init__(__self__, *,
                 metadatas: Sequence['outputs.GitopsAppProjectProjectMetadata'],
                 specs: Sequence['outputs.GitopsAppProjectProjectSpec']):
        """
        :param Sequence['GitopsAppProjectProjectMetadataArgs'] metadatas: K8s object metadata for the Argo project.
        :param Sequence['GitopsAppProjectProjectSpecArgs'] specs: Specification details for the Argo project.
        """
        pulumi.set(__self__, "metadatas", metadatas)
        pulumi.set(__self__, "specs", specs)

    @property
    @pulumi.getter
    def metadatas(self) -> Sequence['outputs.GitopsAppProjectProjectMetadata']:
        """
        K8s object metadata for the Argo project.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GitopsAppProjectProjectSpec']:
        """
        Specification details for the Argo project.
        """
        return pulumi.get(self, "specs")


@pulumi.output_type
class GitopsAppProjectProjectMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "managedFields":
            suggest = "managed_fields"
        elif key == "resourceVersion":
            suggest = "resource_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitopsAppProjectProjectMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitopsAppProjectProjectMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitopsAppProjectProjectMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, str]] = None,
                 cluster_name: Optional[str] = None,
                 finalizers: Optional[Sequence[str]] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 managed_fields: Optional[Sequence['outputs.GitopsAppProjectProjectMetadataManagedField']] = None,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 resource_version: Optional[str] = None):
        """
        :param Mapping[str, str] annotations: Annotations associated with the GitOps project.
        :param str cluster_name: Name of the cluster associated with the GitOps project.
        :param Sequence[str] finalizers: Finalizers associated with the GitOps project.
        :param Mapping[str, str] labels: Labels associated with the GitOps project.
        :param Sequence['GitopsAppProjectProjectMetadataManagedFieldArgs'] managed_fields: Managed fields associated with the GitOps project.
        :param str name: Name of the GitOps project.
        :param str namespace: Namespace of the GitOps project. This must be the same as the namespace where the agent is installed
        :param str resource_version: Resource Version for the GitOps project
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if finalizers is not None:
            pulumi.set(__self__, "finalizers", finalizers)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if managed_fields is not None:
            pulumi.set(__self__, "managed_fields", managed_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_version is not None:
            pulumi.set(__self__, "resource_version", resource_version)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations associated with the GitOps project.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[str]:
        """
        Name of the cluster associated with the GitOps project.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def finalizers(self) -> Optional[Sequence[str]]:
        """
        Finalizers associated with the GitOps project.
        """
        return pulumi.get(self, "finalizers")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels associated with the GitOps project.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="managedFields")
    def managed_fields(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectMetadataManagedField']]:
        """
        Managed fields associated with the GitOps project.
        """
        return pulumi.get(self, "managed_fields")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the GitOps project.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace of the GitOps project. This must be the same as the namespace where the agent is installed
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="resourceVersion")
    def resource_version(self) -> Optional[str]:
        """
        Resource Version for the GitOps project
        """
        return pulumi.get(self, "resource_version")


@pulumi.output_type
class GitopsAppProjectProjectMetadataManagedField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"
        elif key == "fieldsType":
            suggest = "fields_type"
        elif key == "fieldsV1":
            suggest = "fields_v1"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitopsAppProjectProjectMetadataManagedField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitopsAppProjectProjectMetadataManagedField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitopsAppProjectProjectMetadataManagedField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 fields_type: Optional[str] = None,
                 fields_v1: Optional[Mapping[str, str]] = None,
                 manager: Optional[str] = None,
                 operation: Optional[str] = None,
                 subresource: Optional[str] = None,
                 time: Optional[Mapping[str, str]] = None):
        """
        :param str api_version: API version of the operation performed.
        :param str fields_type: Type of the fields in the GitOps project.
        :param Mapping[str, str] fields_v1: Raw fields associated with the GitOps project.
        :param str manager: Manager responsible for the operation.
        :param str operation: Operation type performed on the GitOps project.
        :param str subresource: Subresource associated with the GitOps project.
        :param Mapping[str, str] time: Timestamp of the operation.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if fields_type is not None:
            pulumi.set(__self__, "fields_type", fields_type)
        if fields_v1 is not None:
            pulumi.set(__self__, "fields_v1", fields_v1)
        if manager is not None:
            pulumi.set(__self__, "manager", manager)
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if subresource is not None:
            pulumi.set(__self__, "subresource", subresource)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        API version of the operation performed.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="fieldsType")
    def fields_type(self) -> Optional[str]:
        """
        Type of the fields in the GitOps project.
        """
        return pulumi.get(self, "fields_type")

    @property
    @pulumi.getter(name="fieldsV1")
    def fields_v1(self) -> Optional[Mapping[str, str]]:
        """
        Raw fields associated with the GitOps project.
        """
        return pulumi.get(self, "fields_v1")

    @property
    @pulumi.getter
    def manager(self) -> Optional[str]:
        """
        Manager responsible for the operation.
        """
        return pulumi.get(self, "manager")

    @property
    @pulumi.getter
    def operation(self) -> Optional[str]:
        """
        Operation type performed on the GitOps project.
        """
        return pulumi.get(self, "operation")

    @property
    @pulumi.getter
    def subresource(self) -> Optional[str]:
        """
        Subresource associated with the GitOps project.
        """
        return pulumi.get(self, "subresource")

    @property
    @pulumi.getter
    def time(self) -> Optional[Mapping[str, str]]:
        """
        Timestamp of the operation.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class GitopsAppProjectProjectSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterResourceBlacklists":
            suggest = "cluster_resource_blacklists"
        elif key == "clusterResourceWhitelists":
            suggest = "cluster_resource_whitelists"
        elif key == "namespaceResourceBlacklists":
            suggest = "namespace_resource_blacklists"
        elif key == "namespaceResourceWhitelists":
            suggest = "namespace_resource_whitelists"
        elif key == "orphanedResources":
            suggest = "orphaned_resources"
        elif key == "permitOnlyProjectScopedClusters":
            suggest = "permit_only_project_scoped_clusters"
        elif key == "signatureKeys":
            suggest = "signature_keys"
        elif key == "sourceNamespaces":
            suggest = "source_namespaces"
        elif key == "sourceRepos":
            suggest = "source_repos"
        elif key == "syncWindows":
            suggest = "sync_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitopsAppProjectProjectSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitopsAppProjectProjectSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitopsAppProjectProjectSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_resource_blacklists: Optional[Sequence['outputs.GitopsAppProjectProjectSpecClusterResourceBlacklist']] = None,
                 cluster_resource_whitelists: Optional[Sequence['outputs.GitopsAppProjectProjectSpecClusterResourceWhitelist']] = None,
                 description: Optional[str] = None,
                 destinations: Optional[Sequence['outputs.GitopsAppProjectProjectSpecDestination']] = None,
                 namespace_resource_blacklists: Optional[Sequence['outputs.GitopsAppProjectProjectSpecNamespaceResourceBlacklist']] = None,
                 namespace_resource_whitelists: Optional[Sequence['outputs.GitopsAppProjectProjectSpecNamespaceResourceWhitelist']] = None,
                 orphaned_resources: Optional[Sequence['outputs.GitopsAppProjectProjectSpecOrphanedResource']] = None,
                 permit_only_project_scoped_clusters: Optional[bool] = None,
                 roles: Optional[Sequence['outputs.GitopsAppProjectProjectSpecRole']] = None,
                 signature_keys: Optional[Sequence['outputs.GitopsAppProjectProjectSpecSignatureKey']] = None,
                 source_namespaces: Optional[Sequence[str]] = None,
                 source_repos: Optional[Sequence[str]] = None,
                 sync_windows: Optional[Sequence['outputs.GitopsAppProjectProjectSpecSyncWindow']] = None):
        """
        :param Sequence['GitopsAppProjectProjectSpecClusterResourceBlacklistArgs'] cluster_resource_blacklists: Cluster resource blacklist for the GitOps project.
        :param Sequence['GitopsAppProjectProjectSpecClusterResourceWhitelistArgs'] cluster_resource_whitelists: Cluster resource whitelist for the Argo project.
        :param str description: Description of the Argo project.
        :param Sequence['GitopsAppProjectProjectSpecDestinationArgs'] destinations: Allowed destinations for applications in this Argo project.
        :param Sequence['GitopsAppProjectProjectSpecNamespaceResourceBlacklistArgs'] namespace_resource_blacklists: Namespace resource blacklist for the Argo project.
        :param Sequence['GitopsAppProjectProjectSpecNamespaceResourceWhitelistArgs'] namespace_resource_whitelists: Namespace resource whitelist for the GitOps project.
        :param Sequence['GitopsAppProjectProjectSpecOrphanedResourceArgs'] orphaned_resources: OrphanedResources specifies if agent should monitor orphaned resources of apps in this project
        :param bool permit_only_project_scoped_clusters: This option determines whether destinations can only reference clusters which are argo project-scoped
        :param Sequence['GitopsAppProjectProjectSpecRoleArgs'] roles: Roles associated with the Argo project.
        :param Sequence['GitopsAppProjectProjectSpecSignatureKeyArgs'] signature_keys: Signature keys for the GitOps project.
        :param Sequence[str] source_namespaces: Source namespaces defines the namespaces application resources are allowed to be created in.
        :param Sequence[str] source_repos: Allowed Source repositories for the Argo project.
        :param Sequence['GitopsAppProjectProjectSpecSyncWindowArgs'] sync_windows: Synchronization windows for the GitOps project.
        """
        if cluster_resource_blacklists is not None:
            pulumi.set(__self__, "cluster_resource_blacklists", cluster_resource_blacklists)
        if cluster_resource_whitelists is not None:
            pulumi.set(__self__, "cluster_resource_whitelists", cluster_resource_whitelists)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if namespace_resource_blacklists is not None:
            pulumi.set(__self__, "namespace_resource_blacklists", namespace_resource_blacklists)
        if namespace_resource_whitelists is not None:
            pulumi.set(__self__, "namespace_resource_whitelists", namespace_resource_whitelists)
        if orphaned_resources is not None:
            pulumi.set(__self__, "orphaned_resources", orphaned_resources)
        if permit_only_project_scoped_clusters is not None:
            pulumi.set(__self__, "permit_only_project_scoped_clusters", permit_only_project_scoped_clusters)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if signature_keys is not None:
            pulumi.set(__self__, "signature_keys", signature_keys)
        if source_namespaces is not None:
            pulumi.set(__self__, "source_namespaces", source_namespaces)
        if source_repos is not None:
            pulumi.set(__self__, "source_repos", source_repos)
        if sync_windows is not None:
            pulumi.set(__self__, "sync_windows", sync_windows)

    @property
    @pulumi.getter(name="clusterResourceBlacklists")
    def cluster_resource_blacklists(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecClusterResourceBlacklist']]:
        """
        Cluster resource blacklist for the GitOps project.
        """
        return pulumi.get(self, "cluster_resource_blacklists")

    @property
    @pulumi.getter(name="clusterResourceWhitelists")
    def cluster_resource_whitelists(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecClusterResourceWhitelist']]:
        """
        Cluster resource whitelist for the Argo project.
        """
        return pulumi.get(self, "cluster_resource_whitelists")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the Argo project.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def destinations(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecDestination']]:
        """
        Allowed destinations for applications in this Argo project.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter(name="namespaceResourceBlacklists")
    def namespace_resource_blacklists(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecNamespaceResourceBlacklist']]:
        """
        Namespace resource blacklist for the Argo project.
        """
        return pulumi.get(self, "namespace_resource_blacklists")

    @property
    @pulumi.getter(name="namespaceResourceWhitelists")
    def namespace_resource_whitelists(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecNamespaceResourceWhitelist']]:
        """
        Namespace resource whitelist for the GitOps project.
        """
        return pulumi.get(self, "namespace_resource_whitelists")

    @property
    @pulumi.getter(name="orphanedResources")
    def orphaned_resources(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecOrphanedResource']]:
        """
        OrphanedResources specifies if agent should monitor orphaned resources of apps in this project
        """
        return pulumi.get(self, "orphaned_resources")

    @property
    @pulumi.getter(name="permitOnlyProjectScopedClusters")
    def permit_only_project_scoped_clusters(self) -> Optional[bool]:
        """
        This option determines whether destinations can only reference clusters which are argo project-scoped
        """
        return pulumi.get(self, "permit_only_project_scoped_clusters")

    @property
    @pulumi.getter
    def roles(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecRole']]:
        """
        Roles associated with the Argo project.
        """
        return pulumi.get(self, "roles")

    @property
    @pulumi.getter(name="signatureKeys")
    def signature_keys(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecSignatureKey']]:
        """
        Signature keys for the GitOps project.
        """
        return pulumi.get(self, "signature_keys")

    @property
    @pulumi.getter(name="sourceNamespaces")
    def source_namespaces(self) -> Optional[Sequence[str]]:
        """
        Source namespaces defines the namespaces application resources are allowed to be created in.
        """
        return pulumi.get(self, "source_namespaces")

    @property
    @pulumi.getter(name="sourceRepos")
    def source_repos(self) -> Optional[Sequence[str]]:
        """
        Allowed Source repositories for the Argo project.
        """
        return pulumi.get(self, "source_repos")

    @property
    @pulumi.getter(name="syncWindows")
    def sync_windows(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecSyncWindow']]:
        """
        Synchronization windows for the GitOps project.
        """
        return pulumi.get(self, "sync_windows")


@pulumi.output_type
class GitopsAppProjectProjectSpecClusterResourceBlacklist(dict):
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        :param str group: Group of the cluster resource blacklist.
        :param str kind: Kind of the cluster resource blacklist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the cluster resource blacklist.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the cluster resource blacklist.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GitopsAppProjectProjectSpecClusterResourceWhitelist(dict):
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        :param str group: Group of the cluster resource whitelist.
        :param str kind: Kind of the cluster resource whitelist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the cluster resource whitelist.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the cluster resource whitelist.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GitopsAppProjectProjectSpecDestination(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None,
                 server: Optional[str] = None):
        """
        :param str name: Name of the destination cluster.
        :param str namespace: Permitted Namespaces for deployment in the destination cluster.
        :param str server: Server URL of the destination cluster.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if server is not None:
            pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the destination cluster.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Permitted Namespaces for deployment in the destination cluster.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        Server URL of the destination cluster.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GitopsAppProjectProjectSpecNamespaceResourceBlacklist(dict):
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        :param str group: Group of the namespace resource blacklist.
        :param str kind: Kind of the namespace resource blacklist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the namespace resource blacklist.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the namespace resource blacklist.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GitopsAppProjectProjectSpecNamespaceResourceWhitelist(dict):
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None):
        """
        :param str group: Group of the namespace resource whitelist.
        :param str kind: Kind of the namespace resource whitelist.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the namespace resource whitelist.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the namespace resource whitelist.
        """
        return pulumi.get(self, "kind")


@pulumi.output_type
class GitopsAppProjectProjectSpecOrphanedResource(dict):
    def __init__(__self__, *,
                 ignores: Optional[Sequence['outputs.GitopsAppProjectProjectSpecOrphanedResourceIgnore']] = None,
                 warn: Optional[bool] = None):
        """
        :param Sequence['GitopsAppProjectProjectSpecOrphanedResourceIgnoreArgs'] ignores: List of ignored orphaned resources.
        :param bool warn: Whether to warn about orphaned resources.
        """
        if ignores is not None:
            pulumi.set(__self__, "ignores", ignores)
        if warn is not None:
            pulumi.set(__self__, "warn", warn)

    @property
    @pulumi.getter
    def ignores(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecOrphanedResourceIgnore']]:
        """
        List of ignored orphaned resources.
        """
        return pulumi.get(self, "ignores")

    @property
    @pulumi.getter
    def warn(self) -> Optional[bool]:
        """
        Whether to warn about orphaned resources.
        """
        return pulumi.get(self, "warn")


@pulumi.output_type
class GitopsAppProjectProjectSpecOrphanedResourceIgnore(dict):
    def __init__(__self__, *,
                 group: Optional[str] = None,
                 kind: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str group: Group of the ignored orphaned resource.
        :param str kind: Kind of the ignored orphaned resource.
        :param str name: Name of the ignored orphaned resource.
        """
        if group is not None:
            pulumi.set(__self__, "group", group)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        Group of the ignored orphaned resource.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of the ignored orphaned resource.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the ignored orphaned resource.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GitopsAppProjectProjectSpecRole(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jwtTokens":
            suggest = "jwt_tokens"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitopsAppProjectProjectSpecRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitopsAppProjectProjectSpecRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitopsAppProjectProjectSpecRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: str,
                 name: str,
                 groups: Optional[Sequence[str]] = None,
                 jwt_tokens: Optional[Sequence['outputs.GitopsAppProjectProjectSpecRoleJwtToken']] = None,
                 policies: Optional[Sequence[str]] = None):
        """
        :param str description: Description of the role.
        :param str name: Name of the role.
        :param Sequence[str] groups: Groups associated with the role.
        :param Sequence['GitopsAppProjectProjectSpecRoleJwtTokenArgs'] jwt_tokens: JWT tokens associated with the role.
        :param Sequence[str] policies: Policies associated with the role. These are argo RBAC policies and may not necessarily reflect in harness.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if jwt_tokens is not None:
            pulumi.set(__self__, "jwt_tokens", jwt_tokens)
        if policies is not None:
            pulumi.set(__self__, "policies", policies)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the role.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the role.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        Groups associated with the role.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="jwtTokens")
    def jwt_tokens(self) -> Optional[Sequence['outputs.GitopsAppProjectProjectSpecRoleJwtToken']]:
        """
        JWT tokens associated with the role.
        """
        return pulumi.get(self, "jwt_tokens")

    @property
    @pulumi.getter
    def policies(self) -> Optional[Sequence[str]]:
        """
        Policies associated with the role. These are argo RBAC policies and may not necessarily reflect in harness.
        """
        return pulumi.get(self, "policies")


@pulumi.output_type
class GitopsAppProjectProjectSpecRoleJwtToken(dict):
    def __init__(__self__, *,
                 exp: Optional[str] = None,
                 iat: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str exp: Expiration time of the JWT token.
        :param str iat: Issued At time of the JWT token.
        :param str id: ID of the JWT token.
        """
        if exp is not None:
            pulumi.set(__self__, "exp", exp)
        if iat is not None:
            pulumi.set(__self__, "iat", iat)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def exp(self) -> Optional[str]:
        """
        Expiration time of the JWT token.
        """
        return pulumi.get(self, "exp")

    @property
    @pulumi.getter
    def iat(self) -> Optional[str]:
        """
        Issued At time of the JWT token.
        """
        return pulumi.get(self, "iat")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the JWT token.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GitopsAppProjectProjectSpecSignatureKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyId":
            suggest = "key_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitopsAppProjectProjectSpecSignatureKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitopsAppProjectProjectSpecSignatureKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitopsAppProjectProjectSpecSignatureKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_id: Optional[str] = None):
        """
        :param str key_id: ID of the signature key.
        """
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        ID of the signature key.
        """
        return pulumi.get(self, "key_id")


@pulumi.output_type
class GitopsAppProjectProjectSpecSyncWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualSync":
            suggest = "manual_sync"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GitopsAppProjectProjectSpecSyncWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GitopsAppProjectProjectSpecSyncWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GitopsAppProjectProjectSpecSyncWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence[str]] = None,
                 clusters: Optional[Sequence[str]] = None,
                 duration: Optional[str] = None,
                 kind: Optional[str] = None,
                 manual_sync: Optional[bool] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 schedule: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param Sequence[str] applications: Applications associated with synchronization window.
        :param Sequence[str] clusters: Clusters associated with synchronization window.
        :param str duration: Duration of synchronization window.
        :param str kind: Kind of synchronization window.
        :param bool manual_sync: Whether manual synchronization is enabled.
        :param Sequence[str] namespaces: Namespaces associated with synchronization window.
        :param str schedule: Schedule of synchronization window.
        :param str time_zone: Time zone of synchronization window.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if manual_sync is not None:
            pulumi.set(__self__, "manual_sync", manual_sync)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence[str]]:
        """
        Applications associated with synchronization window.
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence[str]]:
        """
        Clusters associated with synchronization window.
        """
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of synchronization window.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def kind(self) -> Optional[str]:
        """
        Kind of synchronization window.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter(name="manualSync")
    def manual_sync(self) -> Optional[bool]:
        """
        Whether manual synchronization is enabled.
        """
        return pulumi.get(self, "manual_sync")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        Namespaces associated with synchronization window.
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def schedule(self) -> Optional[str]:
        """
        Schedule of synchronization window.
        """
        return pulumi.get(self, "schedule")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Time zone of synchronization window.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class HarRegistryConfig(dict):
    def __init__(__self__, *,
                 type: str,
                 auths: Optional[Sequence['outputs.HarRegistryConfigAuth']] = None,
                 source: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str type: Type of registry (VIRTUAL only supported)
        :param Sequence['HarRegistryConfigAuthArgs'] auths: Authentication configuration for UPSTREAM type
        :param str source: Source of the upstream
        :param str url: URL of the upstream
        """
        pulumi.set(__self__, "type", type)
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of registry (VIRTUAL only supported)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def auths(self) -> Optional[Sequence['outputs.HarRegistryConfigAuth']]:
        """
        Authentication configuration for UPSTREAM type
        """
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Source of the upstream
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        URL of the upstream
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class HarRegistryConfigAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "userPassword":
            suggest = "user_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HarRegistryConfigAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HarRegistryConfigAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HarRegistryConfigAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 user_password: Optional['outputs.HarRegistryConfigAuthUserPassword'] = None):
        """
        :param str auth_type: Type of authentication (UserPassword, Anonymous)
        :param 'HarRegistryConfigAuthUserPasswordArgs' user_password: User password authentication details
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Type of authentication (UserPassword, Anonymous)
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional['outputs.HarRegistryConfigAuthUserPassword']:
        """
        User password authentication details
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class HarRegistryConfigAuthUserPassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "secretIdentifier":
            suggest = "secret_identifier"
        elif key == "secretSpaceId":
            suggest = "secret_space_id"
        elif key == "secretSpacePath":
            suggest = "secret_space_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HarRegistryConfigAuthUserPassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HarRegistryConfigAuthUserPassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HarRegistryConfigAuthUserPassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_name: str,
                 secret_identifier: Optional[str] = None,
                 secret_space_id: Optional[int] = None,
                 secret_space_path: Optional[str] = None):
        """
        :param str user_name: User name
        :param str secret_identifier: Secret identifier
        :param int secret_space_id: Secret space ID
        :param str secret_space_path: Secret space path
        """
        pulumi.set(__self__, "user_name", user_name)
        if secret_identifier is not None:
            pulumi.set(__self__, "secret_identifier", secret_identifier)
        if secret_space_id is not None:
            pulumi.set(__self__, "secret_space_id", secret_space_id)
        if secret_space_path is not None:
            pulumi.set(__self__, "secret_space_path", secret_space_path)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        User name
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[str]:
        """
        Secret identifier
        """
        return pulumi.get(self, "secret_identifier")

    @property
    @pulumi.getter(name="secretSpaceId")
    def secret_space_id(self) -> Optional[int]:
        """
        Secret space ID
        """
        return pulumi.get(self, "secret_space_id")

    @property
    @pulumi.getter(name="secretSpacePath")
    def secret_space_path(self) -> Optional[str]:
        """
        Secret space path
        """
        return pulumi.get(self, "secret_space_path")


@pulumi.output_type
class HelmConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HelmConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HelmConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HelmConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class InfraVariableSetConnector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorRef":
            suggest = "connector_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfraVariableSetConnector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfraVariableSetConnector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfraVariableSetConnector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_ref: str,
                 type: str):
        """
        :param str connector_ref: Unique identifier of the connector.
        :param str type: Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> str:
        """
        Unique identifier of the connector.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class InfraVariableSetEnvironmentVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfraVariableSetEnvironmentVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfraVariableSetEnvironmentVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfraVariableSetEnvironmentVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable. Must be unique within the variable set.
        :param str value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param str value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable. Must be unique within the variable set.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class InfraVariableSetTerraformVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfraVariableSetTerraformVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfraVariableSetTerraformVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfraVariableSetTerraformVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable. Must be unique within the variable set.
        :param str value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param str value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable. Must be unique within the variable set.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class InfraVariableSetTerraformVariableFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryConnector":
            suggest = "repository_connector"
        elif key == "repositoryBranch":
            suggest = "repository_branch"
        elif key == "repositoryCommit":
            suggest = "repository_commit"
        elif key == "repositoryPath":
            suggest = "repository_path"
        elif key == "repositorySha":
            suggest = "repository_sha"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfraVariableSetTerraformVariableFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfraVariableSetTerraformVariableFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfraVariableSetTerraformVariableFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository: str,
                 repository_connector: str,
                 repository_branch: Optional[str] = None,
                 repository_commit: Optional[str] = None,
                 repository_path: Optional[str] = None,
                 repository_sha: Optional[str] = None):
        """
        :param str repository: Repository is the name of the repository to fetch the code from.
        :param str repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param str repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param str repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param str repository_path: Repository path is the path in which the variables reside.
        :param str repository_sha: Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_branch is not None:
            pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit is not None:
            pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_path is not None:
            pulumi.set(__self__, "repository_path", repository_path)
        if repository_sha is not None:
            pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> str:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> Optional[str]:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> Optional[str]:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> Optional[str]:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> Optional[str]:
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")


@pulumi.output_type
class InfrastructureGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "importFromGit":
            suggest = "import_from_git"
        elif key == "isForceImport":
            suggest = "is_force_import"
        elif key == "isHarnesscodeRepo":
            suggest = "is_harnesscode_repo"
        elif key == "isNewBranch":
            suggest = "is_new_branch"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "loadFromCache":
            suggest = "load_from_cache"
        elif key == "loadFromFallbackBranch":
            suggest = "load_from_fallback_branch"
        elif key == "parentEntityConnectorRef":
            suggest = "parent_entity_connector_ref"
        elif key == "parentEntityRepoName":
            suggest = "parent_entity_repo_name"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InfrastructureGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InfrastructureGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InfrastructureGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 import_from_git: Optional[bool] = None,
                 is_force_import: Optional[bool] = None,
                 is_harnesscode_repo: Optional[bool] = None,
                 is_new_branch: Optional[bool] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 load_from_cache: Optional[str] = None,
                 load_from_fallback_branch: Optional[bool] = None,
                 parent_entity_connector_ref: Optional[str] = None,
                 parent_entity_repo_name: Optional[str] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch: Name of the branch.
        :param str commit_message: message for the commit in Git Repo.
        :param str connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param bool import_from_git: Flag to set if importing from Git
        :param bool is_force_import: Flag to set if force importing from Git
        :param bool is_harnesscode_repo: If the gitProvider is HarnessCode
        :param bool is_new_branch: If a new branch creation is requested.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Infrastructures.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Infrastructures.
        :param str load_from_cache: If the Entity is to be fetched from cache
        :param bool load_from_fallback_branch: Whether the file has to be get from fallback_branch.
        :param str parent_entity_connector_ref: Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str parent_entity_repo_name: Name of the repository where parent entity lies.
        :param str repo_name: Name of the repository.
        :param str store_type: store type of the entity.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if import_from_git is not None:
            pulumi.set(__self__, "import_from_git", import_from_git)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if is_harnesscode_repo is not None:
            pulumi.set(__self__, "is_harnesscode_repo", is_harnesscode_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if parent_entity_connector_ref is not None:
            pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        if parent_entity_repo_name is not None:
            pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        message for the commit in Git Repo.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="importFromGit")
    def import_from_git(self) -> Optional[bool]:
        """
        Flag to set if importing from Git
        """
        return pulumi.get(self, "import_from_git")

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[bool]:
        """
        Flag to set if force importing from Git
        """
        return pulumi.get(self, "is_force_import")

    @property
    @pulumi.getter(name="isHarnesscodeRepo")
    def is_harnesscode_repo(self) -> Optional[bool]:
        """
        If the gitProvider is HarnessCode
        """
        return pulumi.get(self, "is_harnesscode_repo")

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[bool]:
        """
        If a new branch creation is requested.
        """
        return pulumi.get(self, "is_new_branch")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Infrastructures.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating Infrastructures.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[str]:
        """
        If the Entity is to be fetched from cache
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[bool]:
        """
        Whether the file has to be get from fallback_branch.
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Parent Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> Optional[str]:
        """
        Name of the repository where parent entity lies.
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        store type of the entity.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class InputSetGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "parentEntityConnectorRef":
            suggest = "parent_entity_connector_ref"
        elif key == "parentEntityRepoName":
            suggest = "parent_entity_repo_name"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputSetGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputSetGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputSetGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch_name: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 parent_entity_connector_ref: Optional[str] = None,
                 parent_entity_repo_name: Optional[str] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch_name: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param str parent_entity_connector_ref: Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str parent_entity_repo_name: Repository name for Parent Entity (Pipeline).
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if parent_entity_connector_ref is not None:
            pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        if parent_entity_repo_name is not None:
            pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> Optional[str]:
        """
        Connector reference for Parent Entity (Pipeline). To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> Optional[str]:
        """
        Repository name for Parent Entity (Pipeline).
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class InputSetGitImportInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchName":
            suggest = "branch_name"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "isForceImport":
            suggest = "is_force_import"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputSetGitImportInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputSetGitImportInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputSetGitImportInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_name: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 is_force_import: Optional[bool] = None,
                 repo_name: Optional[str] = None):
        """
        :param str branch_name: Name of the branch.
        :param str connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param str repo_name: Name of the repository.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[bool]:
        return pulumi.get(self, "is_force_import")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class InputSetInputSetImportRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inputSetDescription":
            suggest = "input_set_description"
        elif key == "inputSetName":
            suggest = "input_set_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InputSetInputSetImportRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InputSetInputSetImportRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InputSetInputSetImportRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 input_set_description: Optional[str] = None,
                 input_set_name: Optional[str] = None):
        """
        :param str input_set_description: Description of the input set.
        :param str input_set_name: Name of the input set.
        """
        if input_set_description is not None:
            pulumi.set(__self__, "input_set_description", input_set_description)
        if input_set_name is not None:
            pulumi.set(__self__, "input_set_name", input_set_name)

    @property
    @pulumi.getter(name="inputSetDescription")
    def input_set_description(self) -> Optional[str]:
        """
        Description of the input set.
        """
        return pulumi.get(self, "input_set_description")

    @property
    @pulumi.getter(name="inputSetName")
    def input_set_name(self) -> Optional[str]:
        """
        Name of the input set.
        """
        return pulumi.get(self, "input_set_name")


@pulumi.output_type
class JenkinsConnectorAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jenkinsBearerToken":
            suggest = "jenkins_bearer_token"
        elif key == "jenkinsUserNamePassword":
            suggest = "jenkins_user_name_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JenkinsConnectorAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JenkinsConnectorAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JenkinsConnectorAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 jenkins_bearer_token: Optional['outputs.JenkinsConnectorAuthJenkinsBearerToken'] = None,
                 jenkins_user_name_password: Optional['outputs.JenkinsConnectorAuthJenkinsUserNamePassword'] = None):
        """
        :param str type: Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
        :param 'JenkinsConnectorAuthJenkinsBearerTokenArgs' jenkins_bearer_token: Authenticate to App Dynamics using bearer token.
        :param 'JenkinsConnectorAuthJenkinsUserNamePasswordArgs' jenkins_user_name_password: Authenticate to App Dynamics using user name and password.
        """
        pulumi.set(__self__, "type", type)
        if jenkins_bearer_token is not None:
            pulumi.set(__self__, "jenkins_bearer_token", jenkins_bearer_token)
        if jenkins_user_name_password is not None:
            pulumi.set(__self__, "jenkins_user_name_password", jenkins_user_name_password)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be one of UsernamePassword, Anonymous, Bearer Token(HTTP Header)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="jenkinsBearerToken")
    def jenkins_bearer_token(self) -> Optional['outputs.JenkinsConnectorAuthJenkinsBearerToken']:
        """
        Authenticate to App Dynamics using bearer token.
        """
        return pulumi.get(self, "jenkins_bearer_token")

    @property
    @pulumi.getter(name="jenkinsUserNamePassword")
    def jenkins_user_name_password(self) -> Optional['outputs.JenkinsConnectorAuthJenkinsUserNamePassword']:
        """
        Authenticate to App Dynamics using user name and password.
        """
        return pulumi.get(self, "jenkins_user_name_password")


@pulumi.output_type
class JenkinsConnectorAuthJenkinsBearerToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tokenRef":
            suggest = "token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JenkinsConnectorAuthJenkinsBearerToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JenkinsConnectorAuthJenkinsBearerToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JenkinsConnectorAuthJenkinsBearerToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class JenkinsConnectorAuthJenkinsUserNamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JenkinsConnectorAuthJenkinsUserNamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JenkinsConnectorAuthJenkinsUserNamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JenkinsConnectorAuthJenkinsUserNamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.To reference a secret at the project scope, use directly without any prefix.
        :param str username: Username to use for authentication.
        :param str username_ref: Username reference to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.To reference a secret at the project scope, use directly without any prefix.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Username reference to use for authentication.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class JiraConnectorAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "personalAccessToken":
            suggest = "personal_access_token"
        elif key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JiraConnectorAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JiraConnectorAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JiraConnectorAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 personal_access_token: Optional['outputs.JiraConnectorAuthPersonalAccessToken'] = None,
                 username_password: Optional['outputs.JiraConnectorAuthUsernamePassword'] = None):
        """
        :param str auth_type: Authentication types for Jira connector
        :param 'JiraConnectorAuthPersonalAccessTokenArgs' personal_access_token: Authenticate using personal access token.
        :param 'JiraConnectorAuthUsernamePasswordArgs' username_password: Authenticate using username password.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if personal_access_token is not None:
            pulumi.set(__self__, "personal_access_token", personal_access_token)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication types for Jira connector
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="personalAccessToken")
    def personal_access_token(self) -> Optional['outputs.JiraConnectorAuthPersonalAccessToken']:
        """
        Authenticate using personal access token.
        """
        return pulumi.get(self, "personal_access_token")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.JiraConnectorAuthUsernamePassword']:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_password")


@pulumi.output_type
class JiraConnectorAuthPersonalAccessToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patRef":
            suggest = "pat_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JiraConnectorAuthPersonalAccessToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JiraConnectorAuthPersonalAccessToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JiraConnectorAuthPersonalAccessToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pat_ref: str):
        """
        :param str pat_ref: Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "pat_ref", pat_ref)

    @property
    @pulumi.getter(name="patRef")
    def pat_ref(self) -> str:
        """
        Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "pat_ref")


@pulumi.output_type
class JiraConnectorAuthUsernamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JiraConnectorAuthUsernamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JiraConnectorAuthUsernamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JiraConnectorAuthUsernamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class KubernetesConnectorClientKeyCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertRef":
            suggest = "client_cert_ref"
        elif key == "clientKeyAlgorithm":
            suggest = "client_key_algorithm"
        elif key == "clientKeyRef":
            suggest = "client_key_ref"
        elif key == "masterUrl":
            suggest = "master_url"
        elif key == "caCertRef":
            suggest = "ca_cert_ref"
        elif key == "clientKeyPassphraseRef":
            suggest = "client_key_passphrase_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConnectorClientKeyCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConnectorClientKeyCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConnectorClientKeyCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_cert_ref: str,
                 client_key_algorithm: str,
                 client_key_ref: str,
                 master_url: str,
                 ca_cert_ref: Optional[str] = None,
                 client_key_passphrase_ref: Optional[str] = None):
        """
        :param str client_cert_ref: Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_key_algorithm: The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        :param str client_key_ref: Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str master_url: The URL of the Kubernetes cluster.
        :param str ca_cert_ref: Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_key_passphrase_ref: Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_cert_ref", client_cert_ref)
        pulumi.set(__self__, "client_key_algorithm", client_key_algorithm)
        pulumi.set(__self__, "client_key_ref", client_key_ref)
        pulumi.set(__self__, "master_url", master_url)
        if ca_cert_ref is not None:
            pulumi.set(__self__, "ca_cert_ref", ca_cert_ref)
        if client_key_passphrase_ref is not None:
            pulumi.set(__self__, "client_key_passphrase_ref", client_key_passphrase_ref)

    @property
    @pulumi.getter(name="clientCertRef")
    def client_cert_ref(self) -> str:
        """
        Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_cert_ref")

    @property
    @pulumi.getter(name="clientKeyAlgorithm")
    def client_key_algorithm(self) -> str:
        """
        The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        """
        return pulumi.get(self, "client_key_algorithm")

    @property
    @pulumi.getter(name="clientKeyRef")
    def client_key_ref(self) -> str:
        """
        Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_key_ref")

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="caCertRef")
    def ca_cert_ref(self) -> Optional[str]:
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ca_cert_ref")

    @property
    @pulumi.getter(name="clientKeyPassphraseRef")
    def client_key_passphrase_ref(self) -> Optional[str]:
        """
        Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_key_passphrase_ref")


@pulumi.output_type
class KubernetesConnectorInheritFromDelegate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "delegateSelectors":
            suggest = "delegate_selectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConnectorInheritFromDelegate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConnectorInheritFromDelegate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConnectorInheritFromDelegate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delegate_selectors: Sequence[str]):
        """
        :param Sequence[str] delegate_selectors: Selectors to use for the delegate.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        Selectors to use for the delegate.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class KubernetesConnectorOpenidConnect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIdRef":
            suggest = "client_id_ref"
        elif key == "issuerUrl":
            suggest = "issuer_url"
        elif key == "masterUrl":
            suggest = "master_url"
        elif key == "passwordRef":
            suggest = "password_ref"
        elif key == "secretRef":
            suggest = "secret_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConnectorOpenidConnect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConnectorOpenidConnect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConnectorOpenidConnect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id_ref: str,
                 issuer_url: str,
                 master_url: str,
                 password_ref: str,
                 scopes: Optional[Sequence[str]] = None,
                 secret_ref: Optional[str] = None,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str client_id_ref: Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str issuer_url: The URL of the OpenID Connect issuer.
        :param str master_url: The URL of the Kubernetes cluster.
        :param str password_ref: Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] scopes: Scopes to request for the connector.
        :param str secret_ref: Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username for the connector.
        :param str username_ref: Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "password_ref", password_ref)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> str:
        """
        Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The URL of the OpenID Connect issuer.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        Scopes to request for the connector.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[str]:
        """
        Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for the connector.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class KubernetesConnectorServiceAccount(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterUrl":
            suggest = "master_url"
        elif key == "serviceAccountTokenRef":
            suggest = "service_account_token_ref"
        elif key == "caCertRef":
            suggest = "ca_cert_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConnectorServiceAccount. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConnectorServiceAccount.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConnectorServiceAccount.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_url: str,
                 service_account_token_ref: str,
                 ca_cert_ref: Optional[str] = None):
        """
        :param str master_url: The URL of the Kubernetes cluster.
        :param str service_account_token_ref: Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str ca_cert_ref: Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "service_account_token_ref", service_account_token_ref)
        if ca_cert_ref is not None:
            pulumi.set(__self__, "ca_cert_ref", ca_cert_ref)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="serviceAccountTokenRef")
    def service_account_token_ref(self) -> str:
        """
        Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "service_account_token_ref")

    @property
    @pulumi.getter(name="caCertRef")
    def ca_cert_ref(self) -> Optional[str]:
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ca_cert_ref")


@pulumi.output_type
class KubernetesConnectorUsernamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "masterUrl":
            suggest = "master_url"
        elif key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesConnectorUsernamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesConnectorUsernamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesConnectorUsernamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 master_url: str,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str master_url: The URL of the Kubernetes cluster.
        :param str password_ref: Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username for the connector.
        :param str username_ref: Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for the connector.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class ManualFreezeCurrentOrUpcomingWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManualFreezeCurrentOrUpcomingWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManualFreezeCurrentOrUpcomingWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManualFreezeCurrentOrUpcomingWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[int] = None,
                 start_time: Optional[int] = None):
        """
        :param int end_time: End time of the freeze
        :param int start_time: Start time of the freeze
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        """
        End time of the freeze
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Start time of the freeze
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ManualFreezeFreezeWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManualFreezeFreezeWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManualFreezeFreezeWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManualFreezeFreezeWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[str] = None,
                 end_time: Optional[str] = None,
                 recurrences: Optional[Sequence['outputs.ManualFreezeFreezeWindowRecurrence']] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None):
        """
        :param str duration: Duration of the freeze
        :param str end_time: End time of the freeze
        :param Sequence['ManualFreezeFreezeWindowRecurrenceArgs'] recurrences: Recurrence of the freeze window
        :param str start_time: Start time of the freeze
        :param str time_zone: Timezone
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of the freeze
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        End time of the freeze
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[Sequence['outputs.ManualFreezeFreezeWindowRecurrence']]:
        """
        Recurrence of the freeze window
        """
        return pulumi.get(self, "recurrences")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        Start time of the freeze
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Timezone
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class ManualFreezeFreezeWindowRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recurrenceSpecs":
            suggest = "recurrence_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManualFreezeFreezeWindowRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManualFreezeFreezeWindowRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManualFreezeFreezeWindowRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recurrence_specs: Optional[Sequence['outputs.ManualFreezeFreezeWindowRecurrenceRecurrenceSpec']] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['ManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs'] recurrence_specs: Used to filter resources on their attributes
        :param str type: Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
        if recurrence_specs is not None:
            pulumi.set(__self__, "recurrence_specs", recurrence_specs)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="recurrenceSpecs")
    def recurrence_specs(self) -> Optional[Sequence['outputs.ManualFreezeFreezeWindowRecurrenceRecurrenceSpec']]:
        """
        Used to filter resources on their attributes
        """
        return pulumi.get(self, "recurrence_specs")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ManualFreezeFreezeWindowRecurrenceRecurrenceSpec(dict):
    def __init__(__self__, *,
                 until: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str until: Recurrence until timestamp
        :param int value: Value of n, for n months recurrence
        """
        if until is not None:
            pulumi.set(__self__, "until", until)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def until(self) -> Optional[str]:
        """
        Recurrence until timestamp
        """
        return pulumi.get(self, "until")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Value of n, for n months recurrence
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class MonitoredServiceRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentRef":
            suggest = "environment_ref"
        elif key == "serviceRef":
            suggest = "service_ref"
        elif key == "changeSources":
            suggest = "change_sources"
        elif key == "environmentRefLists":
            suggest = "environment_ref_lists"
        elif key == "healthSources":
            suggest = "health_sources"
        elif key == "notificationRuleRefs":
            suggest = "notification_rule_refs"
        elif key == "templateRef":
            suggest = "template_ref"
        elif key == "versionLabel":
            suggest = "version_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoredServiceRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoredServiceRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoredServiceRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 environment_ref: str,
                 name: str,
                 service_ref: str,
                 type: str,
                 change_sources: Optional[Sequence['outputs.MonitoredServiceRequestChangeSource']] = None,
                 dependencies: Optional[Sequence['outputs.MonitoredServiceRequestDependency']] = None,
                 description: Optional[str] = None,
                 enabled: Optional[bool] = None,
                 environment_ref_lists: Optional[Sequence[str]] = None,
                 health_sources: Optional[Sequence['outputs.MonitoredServiceRequestHealthSource']] = None,
                 notification_rule_refs: Optional[Sequence['outputs.MonitoredServiceRequestNotificationRuleRef']] = None,
                 tags: Optional[Sequence[str]] = None,
                 template_ref: Optional[str] = None,
                 version_label: Optional[str] = None):
        """
        :param str environment_ref: Environment in which the service is deployed.
        :param str name: Name for the monitored service.
        :param str service_ref: Service reference for the monitored service.
        :param str type: Type of the monitored service.
        :param Sequence['MonitoredServiceRequestChangeSourceArgs'] change_sources: Set of change sources for the monitored service.
        :param Sequence['MonitoredServiceRequestDependencyArgs'] dependencies: Dependencies of the monitored service.
        :param str description: Description for the monitored service.
        :param bool enabled: Enable or disable the monitored service.
        :param Sequence[str] environment_ref_lists: Environment reference list for the monitored service.
        :param Sequence['MonitoredServiceRequestHealthSourceArgs'] health_sources: Set of health sources for the monitored service.
        :param Sequence['MonitoredServiceRequestNotificationRuleRefArgs'] notification_rule_refs: Notification rule references for the monitored service.
        :param Sequence[str] tags: Tags for the monitored service. comma-separated key value string pairs.
        :param str template_ref: Template reference for the monitored service.
        :param str version_label: Template version label for the monitored service.
        """
        pulumi.set(__self__, "environment_ref", environment_ref)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_ref", service_ref)
        pulumi.set(__self__, "type", type)
        if change_sources is not None:
            pulumi.set(__self__, "change_sources", change_sources)
        if dependencies is not None:
            pulumi.set(__self__, "dependencies", dependencies)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if environment_ref_lists is not None:
            pulumi.set(__self__, "environment_ref_lists", environment_ref_lists)
        if health_sources is not None:
            pulumi.set(__self__, "health_sources", health_sources)
        if notification_rule_refs is not None:
            pulumi.set(__self__, "notification_rule_refs", notification_rule_refs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if template_ref is not None:
            pulumi.set(__self__, "template_ref", template_ref)
        if version_label is not None:
            pulumi.set(__self__, "version_label", version_label)

    @property
    @pulumi.getter(name="environmentRef")
    def environment_ref(self) -> str:
        """
        Environment in which the service is deployed.
        """
        return pulumi.get(self, "environment_ref")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the monitored service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="serviceRef")
    def service_ref(self) -> str:
        """
        Service reference for the monitored service.
        """
        return pulumi.get(self, "service_ref")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the monitored service.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="changeSources")
    def change_sources(self) -> Optional[Sequence['outputs.MonitoredServiceRequestChangeSource']]:
        """
        Set of change sources for the monitored service.
        """
        return pulumi.get(self, "change_sources")

    @property
    @pulumi.getter
    def dependencies(self) -> Optional[Sequence['outputs.MonitoredServiceRequestDependency']]:
        """
        Dependencies of the monitored service.
        """
        return pulumi.get(self, "dependencies")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the monitored service.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    @_utilities.deprecated("""enabled field is deprecated""")
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable the monitored service.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="environmentRefLists")
    def environment_ref_lists(self) -> Optional[Sequence[str]]:
        """
        Environment reference list for the monitored service.
        """
        return pulumi.get(self, "environment_ref_lists")

    @property
    @pulumi.getter(name="healthSources")
    def health_sources(self) -> Optional[Sequence['outputs.MonitoredServiceRequestHealthSource']]:
        """
        Set of health sources for the monitored service.
        """
        return pulumi.get(self, "health_sources")

    @property
    @pulumi.getter(name="notificationRuleRefs")
    def notification_rule_refs(self) -> Optional[Sequence['outputs.MonitoredServiceRequestNotificationRuleRef']]:
        """
        Notification rule references for the monitored service.
        """
        return pulumi.get(self, "notification_rule_refs")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags for the monitored service. comma-separated key value string pairs.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="templateRef")
    def template_ref(self) -> Optional[str]:
        """
        Template reference for the monitored service.
        """
        return pulumi.get(self, "template_ref")

    @property
    @pulumi.getter(name="versionLabel")
    def version_label(self) -> Optional[str]:
        """
        Template version label for the monitored service.
        """
        return pulumi.get(self, "version_label")


@pulumi.output_type
class MonitoredServiceRequestChangeSource(dict):
    def __init__(__self__, *,
                 category: str,
                 identifier: str,
                 name: str,
                 type: str,
                 enabled: Optional[bool] = None,
                 spec: Optional[str] = None):
        """
        :param str category: Category of the change source.
        :param str identifier: Identifier of the change source.
        :param str name: Name of the change source.
        :param str type: Type of the change source.
        :param bool enabled: Enable or disable the change source.
        :param str spec: Specification of the change source. Depends on the type of the change source.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Category of the change source.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifier of the change source.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the change source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the change source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Enable or disable the change source.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def spec(self) -> Optional[str]:
        """
        Specification of the change source. Depends on the type of the change source.
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class MonitoredServiceRequestDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitoredServiceIdentifier":
            suggest = "monitored_service_identifier"
        elif key == "dependencyMetadata":
            suggest = "dependency_metadata"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoredServiceRequestDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoredServiceRequestDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoredServiceRequestDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitored_service_identifier: str,
                 type: str,
                 dependency_metadata: Optional[str] = None):
        """
        :param str monitored_service_identifier: Monitored service identifier of the dependency.
        :param str type: Type of the service dependency.
        :param str dependency_metadata: Dependency metadata for the monitored service.
        """
        pulumi.set(__self__, "monitored_service_identifier", monitored_service_identifier)
        pulumi.set(__self__, "type", type)
        if dependency_metadata is not None:
            pulumi.set(__self__, "dependency_metadata", dependency_metadata)

    @property
    @pulumi.getter(name="monitoredServiceIdentifier")
    def monitored_service_identifier(self) -> str:
        """
        Monitored service identifier of the dependency.
        """
        return pulumi.get(self, "monitored_service_identifier")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the service dependency.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="dependencyMetadata")
    def dependency_metadata(self) -> Optional[str]:
        """
        Dependency metadata for the monitored service.
        """
        return pulumi.get(self, "dependency_metadata")


@pulumi.output_type
class MonitoredServiceRequestHealthSource(dict):
    def __init__(__self__, *,
                 identifier: str,
                 name: str,
                 spec: str,
                 type: str,
                 version: Optional[str] = None):
        """
        :param str identifier: Identifier of the health source.
        :param str name: Name of the health source.
        :param str spec: Specification of the health source. Depends on the type of the health source.
        :param str type: Type of the health source.
        :param str version: Version of the health source.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "type", type)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifier of the health source.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the health source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def spec(self) -> str:
        """
        Specification of the health source. Depends on the type of the health source.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the health source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of the health source.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class MonitoredServiceRequestNotificationRuleRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationRuleRef":
            suggest = "notification_rule_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitoredServiceRequestNotificationRuleRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitoredServiceRequestNotificationRuleRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitoredServiceRequestNotificationRuleRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 notification_rule_ref: str):
        """
        :param bool enabled: Enable or disable notification rule reference for the monitored service.
        :param str notification_rule_ref: Notification rule reference for the monitored service.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "notification_rule_ref", notification_rule_ref)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable or disable notification rule reference for the monitored service.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="notificationRuleRef")
    def notification_rule_ref(self) -> str:
        """
        Notification rule reference for the monitored service.
        """
        return pulumi.get(self, "notification_rule_ref")


@pulumi.output_type
class NexusConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NexusConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NexusConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NexusConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}. To reference a secret at the project scope, use directly without any prefix.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class NotificationRuleRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationMethod":
            suggest = "notification_method"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in NotificationRuleRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        NotificationRuleRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        NotificationRuleRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Sequence['outputs.NotificationRuleRequestCondition'],
                 name: str,
                 notification_method: 'outputs.NotificationRuleRequestNotificationMethod',
                 type: str):
        """
        :param Sequence['NotificationRuleRequestConditionArgs'] conditions: Notification Rule conditions specification.
        :param str name: Name for the Notification Rule.
        :param 'NotificationRuleRequestNotificationMethodArgs' notification_method: Notification Method specifications.
        :param str type: Type of the Notification Rule.
        """
        pulumi.set(__self__, "conditions", conditions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "notification_method", notification_method)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def conditions(self) -> Sequence['outputs.NotificationRuleRequestCondition']:
        """
        Notification Rule conditions specification.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the Notification Rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notificationMethod")
    def notification_method(self) -> 'outputs.NotificationRuleRequestNotificationMethod':
        """
        Notification Method specifications.
        """
        return pulumi.get(self, "notification_method")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the Notification Rule.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class NotificationRuleRequestCondition(dict):
    def __init__(__self__, *,
                 type: str,
                 spec: Optional[str] = None):
        """
        :param str type: Type of the condition.
        :param str spec: Specification of the notification condition. Depends on the type of the notification condition.
        """
        pulumi.set(__self__, "type", type)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the condition.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def spec(self) -> Optional[str]:
        """
        Specification of the notification condition. Depends on the type of the notification condition.
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class NotificationRuleRequestNotificationMethod(dict):
    def __init__(__self__, *,
                 type: str,
                 spec: Optional[str] = None):
        """
        :param str type: Type of the Notification Method.
        :param str spec: Specification of the notification method. Depends on the type of the notification method.
        """
        pulumi.set(__self__, "type", type)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the Notification Method.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def spec(self) -> Optional[str]:
        """
        Specification of the notification method. Depends on the type of the notification method.
        """
        return pulumi.get(self, "spec")


@pulumi.output_type
class OciHelmConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OciHelmConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OciHelmConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OciHelmConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class OverridesGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "isHarnessCodeRepo":
            suggest = "is_harness_code_repo"
        elif key == "isNewBranch":
            suggest = "is_new_branch"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "loadFromCache":
            suggest = "load_from_cache"
        elif key == "loadFromFallbackBranch":
            suggest = "load_from_fallback_branch"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OverridesGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OverridesGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OverridesGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 is_harness_code_repo: Optional[bool] = None,
                 is_new_branch: Optional[bool] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 load_from_cache: Optional[bool] = None,
                 load_from_fallback_branch: Optional[bool] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param bool is_harness_code_repo: If the repo is in harness code
        :param bool is_new_branch: If the branch being created is new
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating override.
        :param bool load_from_cache: Load service yaml from catch
        :param bool load_from_fallback_branch: Load service yaml from fallback branch
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[bool]:
        """
        If the repo is in harness code
        """
        return pulumi.get(self, "is_harness_code_repo")

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[bool]:
        """
        If the branch being created is new
        """
        return pulumi.get(self, "is_new_branch")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[bool]:
        """
        Load service yaml from catch
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[bool]:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class PipelineFiltersFilterProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"
        elif key == "moduleProperties":
            suggest = "module_properties"
        elif key == "pipelineIdentifiers":
            suggest = "pipeline_identifiers"
        elif key == "pipelineName":
            suggest = "pipeline_name"
        elif key == "pipelineTags":
            suggest = "pipeline_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineFiltersFilterProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineFiltersFilterProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineFiltersFilterProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 description: Optional[str] = None,
                 module_properties: Optional['outputs.PipelineFiltersFilterPropertiesModuleProperties'] = None,
                 name: Optional[str] = None,
                 pipeline_identifiers: Optional[Sequence[str]] = None,
                 pipeline_name: Optional[str] = None,
                 pipeline_tags: Optional[Sequence[Mapping[str, str]]] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str filter_type: Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        :param str description: description of the pipline filter.
        :param 'PipelineFiltersFilterPropertiesModulePropertiesArgs' module_properties: module properties of the pipline filter.
        :param str name: Name of the pipeline filter.
        :param Sequence[str] pipeline_identifiers: Pipeline identifiers to filter on.
        :param str pipeline_name: Name of the pipeline execution filter.
        :param Sequence[Mapping[str, str]] pipeline_tags: Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if module_properties is not None:
            pulumi.set(__self__, "module_properties", module_properties)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pipeline_identifiers is not None:
            pulumi.set(__self__, "pipeline_identifiers", pipeline_identifiers)
        if pipeline_name is not None:
            pulumi.set(__self__, "pipeline_name", pipeline_name)
        if pipeline_tags is not None:
            pulumi.set(__self__, "pipeline_tags", pipeline_tags)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        description of the pipline filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="moduleProperties")
    def module_properties(self) -> Optional['outputs.PipelineFiltersFilterPropertiesModuleProperties']:
        """
        module properties of the pipline filter.
        """
        return pulumi.get(self, "module_properties")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the pipeline filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pipelineIdentifiers")
    def pipeline_identifiers(self) -> Optional[Sequence[str]]:
        """
        Pipeline identifiers to filter on.
        """
        return pulumi.get(self, "pipeline_identifiers")

    @property
    @pulumi.getter(name="pipelineName")
    def pipeline_name(self) -> Optional[str]:
        """
        Name of the pipeline execution filter.
        """
        return pulumi.get(self, "pipeline_name")

    @property
    @pulumi.getter(name="pipelineTags")
    def pipeline_tags(self) -> Optional[Sequence[Mapping[str, str]]]:
        """
        Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        """
        return pulumi.get(self, "pipeline_tags")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class PipelineFiltersFilterPropertiesModuleProperties(dict):
    def __init__(__self__, *,
                 cd: Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCd'] = None,
                 ci: Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCi'] = None):
        """
        :param 'PipelineFiltersFilterPropertiesModulePropertiesCdArgs' cd: CD related properties to be filtered on.
        :param 'PipelineFiltersFilterPropertiesModulePropertiesCiArgs' ci: CI related properties to be filtered on.
        """
        if cd is not None:
            pulumi.set(__self__, "cd", cd)
        if ci is not None:
            pulumi.set(__self__, "ci", ci)

    @property
    @pulumi.getter
    def cd(self) -> Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCd']:
        """
        CD related properties to be filtered on.
        """
        return pulumi.get(self, "cd")

    @property
    @pulumi.getter
    def ci(self) -> Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCi']:
        """
        CI related properties to be filtered on.
        """
        return pulumi.get(self, "ci")


@pulumi.output_type
class PipelineFiltersFilterPropertiesModulePropertiesCd(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "artifactDisplayNames":
            suggest = "artifact_display_names"
        elif key == "deploymentTypes":
            suggest = "deployment_types"
        elif key == "environmentIdentifiers":
            suggest = "environment_identifiers"
        elif key == "environmentNames":
            suggest = "environment_names"
        elif key == "serviceDefinitionTypes":
            suggest = "service_definition_types"
        elif key == "serviceIdentifiers":
            suggest = "service_identifiers"
        elif key == "serviceNames":
            suggest = "service_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineFiltersFilterPropertiesModulePropertiesCd. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCd.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCd.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 artifact_display_names: Optional[Sequence[str]] = None,
                 deployment_types: Optional[str] = None,
                 environment_identifiers: Optional[Sequence[str]] = None,
                 environment_names: Optional[Sequence[str]] = None,
                 service_definition_types: Optional[str] = None,
                 service_identifiers: Optional[Sequence[str]] = None,
                 service_names: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] artifact_display_names: Artifact display names of the CD pipeline.
        :param str deployment_types: Deployment type of the CD pipeline, eg. Kubernetes
        :param Sequence[str] environment_identifiers: Environment identifier of the CD pipeline.
        :param Sequence[str] environment_names: Environment names of the CD pipeline.
        :param str service_definition_types: Deployment type of the CD pipeline, eg. Kubernetes
        :param Sequence[str] service_identifiers: Service identifiers of the CD pipeline.
        :param Sequence[str] service_names: Service names of the CD pipeline.
        """
        if artifact_display_names is not None:
            pulumi.set(__self__, "artifact_display_names", artifact_display_names)
        if deployment_types is not None:
            pulumi.set(__self__, "deployment_types", deployment_types)
        if environment_identifiers is not None:
            pulumi.set(__self__, "environment_identifiers", environment_identifiers)
        if environment_names is not None:
            pulumi.set(__self__, "environment_names", environment_names)
        if service_definition_types is not None:
            pulumi.set(__self__, "service_definition_types", service_definition_types)
        if service_identifiers is not None:
            pulumi.set(__self__, "service_identifiers", service_identifiers)
        if service_names is not None:
            pulumi.set(__self__, "service_names", service_names)

    @property
    @pulumi.getter(name="artifactDisplayNames")
    def artifact_display_names(self) -> Optional[Sequence[str]]:
        """
        Artifact display names of the CD pipeline.
        """
        return pulumi.get(self, "artifact_display_names")

    @property
    @pulumi.getter(name="deploymentTypes")
    def deployment_types(self) -> Optional[str]:
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        return pulumi.get(self, "deployment_types")

    @property
    @pulumi.getter(name="environmentIdentifiers")
    def environment_identifiers(self) -> Optional[Sequence[str]]:
        """
        Environment identifier of the CD pipeline.
        """
        return pulumi.get(self, "environment_identifiers")

    @property
    @pulumi.getter(name="environmentNames")
    def environment_names(self) -> Optional[Sequence[str]]:
        """
        Environment names of the CD pipeline.
        """
        return pulumi.get(self, "environment_names")

    @property
    @pulumi.getter(name="serviceDefinitionTypes")
    def service_definition_types(self) -> Optional[str]:
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        return pulumi.get(self, "service_definition_types")

    @property
    @pulumi.getter(name="serviceIdentifiers")
    def service_identifiers(self) -> Optional[Sequence[str]]:
        """
        Service identifiers of the CD pipeline.
        """
        return pulumi.get(self, "service_identifiers")

    @property
    @pulumi.getter(name="serviceNames")
    def service_names(self) -> Optional[Sequence[str]]:
        """
        Service names of the CD pipeline.
        """
        return pulumi.get(self, "service_names")


@pulumi.output_type
class PipelineFiltersFilterPropertiesModulePropertiesCi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildType":
            suggest = "build_type"
        elif key == "ciExecutionInfo":
            suggest = "ci_execution_info"
        elif key == "repoNames":
            suggest = "repo_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineFiltersFilterPropertiesModulePropertiesCi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[str] = None,
                 build_type: Optional[str] = None,
                 ci_execution_info: Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo'] = None,
                 repo_names: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str branch: Branch which was used while building.
        :param str build_type: Build type of the pipeline. Possible values: branch.
        :param 'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoArgs' ci_execution_info: CI execution info for the pipeline.
        :param str repo_names: name of the repository used in the pipeline.
        :param str tag: Tags to associate with the CI pipeline resource.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if build_type is not None:
            pulumi.set(__self__, "build_type", build_type)
        if ci_execution_info is not None:
            pulumi.set(__self__, "ci_execution_info", ci_execution_info)
        if repo_names is not None:
            pulumi.set(__self__, "repo_names", repo_names)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Branch which was used while building.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> Optional[str]:
        """
        Build type of the pipeline. Possible values: branch.
        """
        return pulumi.get(self, "build_type")

    @property
    @pulumi.getter(name="ciExecutionInfo")
    def ci_execution_info(self) -> Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo']:
        """
        CI execution info for the pipeline.
        """
        return pulumi.get(self, "ci_execution_info")

    @property
    @pulumi.getter(name="repoNames")
    def repo_names(self) -> Optional[str]:
        """
        name of the repository used in the pipeline.
        """
        return pulumi.get(self, "repo_names")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        Tags to associate with the CI pipeline resource.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pullRequest":
            suggest = "pull_request"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event: Optional[str] = None,
                 pull_request: Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest'] = None):
        """
        :param str event: Event for the ci execution, Possible values: pullRequest.
        :param 'PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequestArgs' pull_request: The pull request details of the CI pipeline.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if pull_request is not None:
            pulumi.set(__self__, "pull_request", pull_request)

    @property
    @pulumi.getter
    def event(self) -> Optional[str]:
        """
        Event for the ci execution, Possible values: pullRequest.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="pullRequest")
    def pull_request(self) -> Optional['outputs.PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest']:
        """
        The pull request details of the CI pipeline.
        """
        return pulumi.get(self, "pull_request")


@pulumi.output_type
class PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceBranch":
            suggest = "source_branch"
        elif key == "targetBranch":
            suggest = "target_branch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineFiltersFilterPropertiesModulePropertiesCiCiExecutionInfoPullRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_branch: Optional[str] = None,
                 target_branch: Optional[str] = None):
        """
        :param str source_branch: Source branch of the pull request.
        :param str target_branch: Target branch of the pull request.
        """
        if source_branch is not None:
            pulumi.set(__self__, "source_branch", source_branch)
        if target_branch is not None:
            pulumi.set(__self__, "target_branch", target_branch)

    @property
    @pulumi.getter(name="sourceBranch")
    def source_branch(self) -> Optional[str]:
        """
        Source branch of the pull request.
        """
        return pulumi.get(self, "source_branch")

    @property
    @pulumi.getter(name="targetBranch")
    def target_branch(self) -> Optional[str]:
        """
        Target branch of the pull request.
        """
        return pulumi.get(self, "target_branch")


@pulumi.output_type
class PipelineGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch_name: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch_name: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class PipelineGitImportInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchName":
            suggest = "branch_name"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelineGitImportInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelineGitImportInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelineGitImportInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_name: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 repo_name: Optional[str] = None):
        """
        :param str branch_name: Name of the branch.
        :param str connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param str repo_name: Name of the repository.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class PipelinePipelineImportRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pipelineDescription":
            suggest = "pipeline_description"
        elif key == "pipelineName":
            suggest = "pipeline_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PipelinePipelineImportRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PipelinePipelineImportRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PipelinePipelineImportRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pipeline_description: Optional[str] = None,
                 pipeline_name: Optional[str] = None):
        """
        :param str pipeline_description: Description of the pipeline.
        :param str pipeline_name: Name of the pipeline.
        """
        if pipeline_description is not None:
            pulumi.set(__self__, "pipeline_description", pipeline_description)
        if pipeline_name is not None:
            pulumi.set(__self__, "pipeline_name", pipeline_name)

    @property
    @pulumi.getter(name="pipelineDescription")
    def pipeline_description(self) -> Optional[str]:
        """
        Description of the pipeline.
        """
        return pulumi.get(self, "pipeline_description")

    @property
    @pulumi.getter(name="pipelineName")
    def pipeline_name(self) -> Optional[str]:
        """
        Name of the pipeline.
        """
        return pulumi.get(self, "pipeline_name")


@pulumi.output_type
class PolicySetPolicy(dict):
    def __init__(__self__, *,
                 identifier: str,
                 severity: str):
        """
        :param str identifier: Account Identifier of the account
        :param str severity: Policy failure response - 'warning' for continuation, 'error' for exit
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        Policy failure response - 'warning' for continuation, 'error' for exit
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class PrometheusConnectorHeader(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "encryptedValueRef":
            suggest = "encrypted_value_ref"
        elif key == "valueEncrypted":
            suggest = "value_encrypted"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrometheusConnectorHeader. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrometheusConnectorHeader.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrometheusConnectorHeader.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 encrypted_value_ref: Optional[str] = None,
                 value: Optional[str] = None,
                 value_encrypted: Optional[bool] = None):
        """
        :param str key: Key.
        :param str encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str value: Value.
        :param bool value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "key", key)
        if encrypted_value_ref is not None:
            pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_encrypted is not None:
            pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> Optional[bool]:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")


@pulumi.output_type
class ProviderSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretRef":
            suggest = "client_secret_ref"
        elif key == "delegateSelectors":
            suggest = "delegate_selectors"
        elif key == "secretManagerRef":
            suggest = "secret_manager_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProviderSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProviderSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProviderSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 client_id: Optional[str] = None,
                 client_secret_ref: Optional[str] = None,
                 delegate_selectors: Optional[Sequence[str]] = None,
                 domain: Optional[str] = None,
                 secret_manager_ref: Optional[str] = None):
        """
        :param str type: The type of the provider entity.
        :param str client_id: Client Id of the OAuth app to connect
        :param str client_secret_ref: Client Secret Ref of the OAuth app to connect
        :param Sequence[str] delegate_selectors: Delegate selectors to fetch the access token
        :param str domain: Host domain of the provider.
        :param str secret_manager_ref: Secret Manager Ref to store the access/refresh tokens
        """
        pulumi.set(__self__, "type", type)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_ref is not None:
            pulumi.set(__self__, "client_secret_ref", client_secret_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if secret_manager_ref is not None:
            pulumi.set(__self__, "secret_manager_ref", secret_manager_ref)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the provider entity.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client Id of the OAuth app to connect
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> Optional[str]:
        """
        Client Secret Ref of the OAuth app to connect
        """
        return pulumi.get(self, "client_secret_ref")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        Delegate selectors to fetch the access token
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Host domain of the provider.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="secretManagerRef")
    def secret_manager_ref(self) -> Optional[str]:
        """
        Secret Manager Ref to store the access/refresh tokens
        """
        return pulumi.get(self, "secret_manager_ref")


@pulumi.output_type
class RepoRuleBranchBypass(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoOwners":
            suggest = "repo_owners"
        elif key == "userIds":
            suggest = "user_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepoRuleBranchBypass. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepoRuleBranchBypass.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepoRuleBranchBypass.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repo_owners: Optional[bool] = None,
                 user_ids: Optional[Sequence[str]] = None):
        """
        :param bool repo_owners: Allow users with repository edit permission to bypass.
        :param Sequence[str] user_ids: List of user ids with who can bypass.
        """
        if repo_owners is not None:
            pulumi.set(__self__, "repo_owners", repo_owners)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="repoOwners")
    def repo_owners(self) -> Optional[bool]:
        """
        Allow users with repository edit permission to bypass.
        """
        return pulumi.get(self, "repo_owners")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        """
        List of user ids with who can bypass.
        """
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class RepoRuleBranchPattern(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultBranch":
            suggest = "default_branch"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepoRuleBranchPattern. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepoRuleBranchPattern.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepoRuleBranchPattern.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_branch: Optional[bool] = None,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param bool default_branch: Should rule apply to default branch of the repository.
        :param Sequence[str] excludes: Globstar branch patterns on which rules will NOT be applied.
        :param Sequence[str] includes: Globstar branch patterns on which rules will be applied.
        """
        if default_branch is not None:
            pulumi.set(__self__, "default_branch", default_branch)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> Optional[bool]:
        """
        Should rule apply to default branch of the repository.
        """
        return pulumi.get(self, "default_branch")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Globstar branch patterns on which rules will NOT be applied.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Globstar branch patterns on which rules will be applied.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class RepoRuleBranchPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowMergeStrategies":
            suggest = "allow_merge_strategies"
        elif key == "blockBranchCreation":
            suggest = "block_branch_creation"
        elif key == "blockBranchDeletion":
            suggest = "block_branch_deletion"
        elif key == "deleteBranchOnMerge":
            suggest = "delete_branch_on_merge"
        elif key == "requireCodeOwners":
            suggest = "require_code_owners"
        elif key == "requireLatestCommitApproval":
            suggest = "require_latest_commit_approval"
        elif key == "requireMinimumApprovalCount":
            suggest = "require_minimum_approval_count"
        elif key == "requireNoChangeRequest":
            suggest = "require_no_change_request"
        elif key == "requirePullRequest":
            suggest = "require_pull_request"
        elif key == "requireResolveAllComments":
            suggest = "require_resolve_all_comments"
        elif key == "requireStatusChecks":
            suggest = "require_status_checks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RepoRuleBranchPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RepoRuleBranchPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RepoRuleBranchPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_merge_strategies: Optional[Sequence[str]] = None,
                 block_branch_creation: Optional[bool] = None,
                 block_branch_deletion: Optional[bool] = None,
                 delete_branch_on_merge: Optional[bool] = None,
                 require_code_owners: Optional[bool] = None,
                 require_latest_commit_approval: Optional[bool] = None,
                 require_minimum_approval_count: Optional[int] = None,
                 require_no_change_request: Optional[bool] = None,
                 require_pull_request: Optional[bool] = None,
                 require_resolve_all_comments: Optional[bool] = None,
                 require_status_checks: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allow_merge_strategies: Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        :param bool block_branch_creation: Only allow users with bypass permission to create matching branches.
        :param bool block_branch_deletion: Only allow users with bypass permission to delete matching branches.
        :param bool delete_branch_on_merge: Automatically delete the source branch of a pull request after it is merged.
        :param bool require_code_owners: Require approval on pull requests from one reviewer for each codeowner rule.
        :param bool require_latest_commit_approval: Require re-approval when there are new changes in the pull request.
        :param int require_minimum_approval_count: Require approval on pull requests from a minimum number of reviewers.
        :param bool require_no_change_request: Require all request for changes have been resolved.
        :param bool require_pull_request: Do not allow any changes to matching branches without a pull request.
        :param bool require_resolve_all_comments: All comments on a pull request must be resolved before it can be merged.
        :param Sequence[str] require_status_checks: Selected status checks must pass before a pull request can be merged.
        """
        if allow_merge_strategies is not None:
            pulumi.set(__self__, "allow_merge_strategies", allow_merge_strategies)
        if block_branch_creation is not None:
            pulumi.set(__self__, "block_branch_creation", block_branch_creation)
        if block_branch_deletion is not None:
            pulumi.set(__self__, "block_branch_deletion", block_branch_deletion)
        if delete_branch_on_merge is not None:
            pulumi.set(__self__, "delete_branch_on_merge", delete_branch_on_merge)
        if require_code_owners is not None:
            pulumi.set(__self__, "require_code_owners", require_code_owners)
        if require_latest_commit_approval is not None:
            pulumi.set(__self__, "require_latest_commit_approval", require_latest_commit_approval)
        if require_minimum_approval_count is not None:
            pulumi.set(__self__, "require_minimum_approval_count", require_minimum_approval_count)
        if require_no_change_request is not None:
            pulumi.set(__self__, "require_no_change_request", require_no_change_request)
        if require_pull_request is not None:
            pulumi.set(__self__, "require_pull_request", require_pull_request)
        if require_resolve_all_comments is not None:
            pulumi.set(__self__, "require_resolve_all_comments", require_resolve_all_comments)
        if require_status_checks is not None:
            pulumi.set(__self__, "require_status_checks", require_status_checks)

    @property
    @pulumi.getter(name="allowMergeStrategies")
    def allow_merge_strategies(self) -> Optional[Sequence[str]]:
        """
        Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        """
        return pulumi.get(self, "allow_merge_strategies")

    @property
    @pulumi.getter(name="blockBranchCreation")
    def block_branch_creation(self) -> Optional[bool]:
        """
        Only allow users with bypass permission to create matching branches.
        """
        return pulumi.get(self, "block_branch_creation")

    @property
    @pulumi.getter(name="blockBranchDeletion")
    def block_branch_deletion(self) -> Optional[bool]:
        """
        Only allow users with bypass permission to delete matching branches.
        """
        return pulumi.get(self, "block_branch_deletion")

    @property
    @pulumi.getter(name="deleteBranchOnMerge")
    def delete_branch_on_merge(self) -> Optional[bool]:
        """
        Automatically delete the source branch of a pull request after it is merged.
        """
        return pulumi.get(self, "delete_branch_on_merge")

    @property
    @pulumi.getter(name="requireCodeOwners")
    def require_code_owners(self) -> Optional[bool]:
        """
        Require approval on pull requests from one reviewer for each codeowner rule.
        """
        return pulumi.get(self, "require_code_owners")

    @property
    @pulumi.getter(name="requireLatestCommitApproval")
    def require_latest_commit_approval(self) -> Optional[bool]:
        """
        Require re-approval when there are new changes in the pull request.
        """
        return pulumi.get(self, "require_latest_commit_approval")

    @property
    @pulumi.getter(name="requireMinimumApprovalCount")
    def require_minimum_approval_count(self) -> Optional[int]:
        """
        Require approval on pull requests from a minimum number of reviewers.
        """
        return pulumi.get(self, "require_minimum_approval_count")

    @property
    @pulumi.getter(name="requireNoChangeRequest")
    def require_no_change_request(self) -> Optional[bool]:
        """
        Require all request for changes have been resolved.
        """
        return pulumi.get(self, "require_no_change_request")

    @property
    @pulumi.getter(name="requirePullRequest")
    def require_pull_request(self) -> Optional[bool]:
        """
        Do not allow any changes to matching branches without a pull request.
        """
        return pulumi.get(self, "require_pull_request")

    @property
    @pulumi.getter(name="requireResolveAllComments")
    def require_resolve_all_comments(self) -> Optional[bool]:
        """
        All comments on a pull request must be resolved before it can be merged.
        """
        return pulumi.get(self, "require_resolve_all_comments")

    @property
    @pulumi.getter(name="requireStatusChecks")
    def require_status_checks(self) -> Optional[Sequence[str]]:
        """
        Selected status checks must pass before a pull request can be merged.
        """
        return pulumi.get(self, "require_status_checks")


@pulumi.output_type
class RepoSource(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 repo: Optional[str] = None,
                 type: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str host: The host URL for the import source.
        :param str password: The password for authentication when importing.
        :param str repo: The full identifier of the repository on the SCM provider's platform.
        :param str type: The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        :param str username: The username for authentication when importing.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The host URL for the import source.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for authentication when importing.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        """
        The full identifier of the repository on the SCM provider's platform.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username for authentication when importing.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ResourceGroupIncludedScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "orgId":
            suggest = "org_id"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGroupIncludedScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGroupIncludedScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGroupIncludedScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter: str,
                 account_id: Optional[str] = None,
                 org_id: Optional[str] = None,
                 project_id: Optional[str] = None):
        """
        :param str filter: Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
        :param str account_id: Account Identifier of the account
        :param str org_id: Organization Identifier
        :param str project_id: Project Identifier
        """
        pulumi.set(__self__, "filter", filter)
        if account_id is not None:
            pulumi.set(__self__, "account_id", account_id)
        if org_id is not None:
            pulumi.set(__self__, "org_id", org_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        Can be one of these 2 EXCLUDING*CHILD*SCOPES or INCLUDING*CHILD*SCOPES
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> Optional[str]:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> Optional[str]:
        """
        Organization Identifier
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        Project Identifier
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class ResourceGroupResourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeAllResources":
            suggest = "include_all_resources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGroupResourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGroupResourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGroupResourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_all_resources: Optional[bool] = None,
                 resources: Optional[Sequence['outputs.ResourceGroupResourceFilterResource']] = None):
        """
        :param bool include_all_resources: Include all resource or not
        :param Sequence['ResourceGroupResourceFilterResourceArgs'] resources: Resources for a resource group
        """
        if include_all_resources is not None:
            pulumi.set(__self__, "include_all_resources", include_all_resources)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="includeAllResources")
    def include_all_resources(self) -> Optional[bool]:
        """
        Include all resource or not
        """
        return pulumi.get(self, "include_all_resources")

    @property
    @pulumi.getter
    def resources(self) -> Optional[Sequence['outputs.ResourceGroupResourceFilterResource']]:
        """
        Resources for a resource group
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class ResourceGroupResourceFilterResource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "attributeFilters":
            suggest = "attribute_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGroupResourceFilterResource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGroupResourceFilterResource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGroupResourceFilterResource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource_type: str,
                 attribute_filters: Optional[Sequence['outputs.ResourceGroupResourceFilterResourceAttributeFilter']] = None,
                 identifiers: Optional[Sequence[str]] = None):
        """
        :param str resource_type: Type of the resource
        :param Sequence['ResourceGroupResourceFilterResourceAttributeFilterArgs'] attribute_filters: Used to filter resources on their attributes
        :param Sequence[str] identifiers: List of the identifiers
        """
        pulumi.set(__self__, "resource_type", resource_type)
        if attribute_filters is not None:
            pulumi.set(__self__, "attribute_filters", attribute_filters)
        if identifiers is not None:
            pulumi.set(__self__, "identifiers", identifiers)

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of the resource
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter(name="attributeFilters")
    def attribute_filters(self) -> Optional[Sequence['outputs.ResourceGroupResourceFilterResourceAttributeFilter']]:
        """
        Used to filter resources on their attributes
        """
        return pulumi.get(self, "attribute_filters")

    @property
    @pulumi.getter
    def identifiers(self) -> Optional[Sequence[str]]:
        """
        List of the identifiers
        """
        return pulumi.get(self, "identifiers")


@pulumi.output_type
class ResourceGroupResourceFilterResourceAttributeFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeName":
            suggest = "attribute_name"
        elif key == "attributeValues":
            suggest = "attribute_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResourceGroupResourceFilterResourceAttributeFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResourceGroupResourceFilterResourceAttributeFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResourceGroupResourceFilterResourceAttributeFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_name: Optional[str] = None,
                 attribute_values: Optional[Sequence[str]] = None):
        """
        :param str attribute_name: Name of the attribute. Valid values are `category`, `type`, `labels`, `tag` or `tags`.
        :param Sequence[str] attribute_values: Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD*COST,CLOUD*PROVIDER,CODE*REPO,MONITORING,SECRET*MANAGER,TICKETING], for `type` are [Production,PreProduction], for `labels`, it can be using the syntax 'label:value', for `tag` or `tags` it can be any string.
        """
        if attribute_name is not None:
            pulumi.set(__self__, "attribute_name", attribute_name)
        if attribute_values is not None:
            pulumi.set(__self__, "attribute_values", attribute_values)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> Optional[str]:
        """
        Name of the attribute. Valid values are `category`, `type`, `labels`, `tag` or `tags`.
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValues")
    def attribute_values(self) -> Optional[Sequence[str]]:
        """
        Value of the attributes.Valid values for `category` are [ARTIFACTORY,CLOUD*COST,CLOUD*PROVIDER,CODE*REPO,MONITORING,SECRET*MANAGER,TICKETING], for `type` are [Production,PreProduction], for `labels`, it can be using the syntax 'label:value', for `tag` or `tags` it can be any string.
        """
        return pulumi.get(self, "attribute_values")


@pulumi.output_type
class RoleAssignmentsPrincipal(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scopeLevel":
            suggest = "scope_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleAssignmentsPrincipal. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleAssignmentsPrincipal.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleAssignmentsPrincipal.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 identifier: Optional[str] = None,
                 scope_level: Optional[str] = None):
        """
        :param str type: Type.
        :param str identifier: Identifier.
        :param str scope_level: Scope level.
        """
        pulumi.set(__self__, "type", type)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if scope_level is not None:
            pulumi.set(__self__, "scope_level", scope_level)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        Identifier.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="scopeLevel")
    def scope_level(self) -> Optional[str]:
        """
        Scope level.
        """
        return pulumi.get(self, "scope_level")


@pulumi.output_type
class SecretSshkeyKerberos(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tgtGenerationMethod":
            suggest = "tgt_generation_method"
        elif key == "tgtKeyTabFilePathSpec":
            suggest = "tgt_key_tab_file_path_spec"
        elif key == "tgtPasswordSpec":
            suggest = "tgt_password_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretSshkeyKerberos. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretSshkeyKerberos.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretSshkeyKerberos.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 principal: str,
                 realm: str,
                 tgt_generation_method: Optional[str] = None,
                 tgt_key_tab_file_path_spec: Optional['outputs.SecretSshkeyKerberosTgtKeyTabFilePathSpec'] = None,
                 tgt_password_spec: Optional['outputs.SecretSshkeyKerberosTgtPasswordSpec'] = None):
        """
        :param str principal: Username to use for authentication.
        :param str realm: Reference to a secret containing the password to use for authentication.
        :param str tgt_generation_method: Method to generate tgt
        :param 'SecretSshkeyKerberosTgtKeyTabFilePathSpecArgs' tgt_key_tab_file_path_spec: Authenticate to App Dynamics using username and password.
        :param 'SecretSshkeyKerberosTgtPasswordSpecArgs' tgt_password_spec: Authenticate to App Dynamics using username and password.
        """
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "realm", realm)
        if tgt_generation_method is not None:
            pulumi.set(__self__, "tgt_generation_method", tgt_generation_method)
        if tgt_key_tab_file_path_spec is not None:
            pulumi.set(__self__, "tgt_key_tab_file_path_spec", tgt_key_tab_file_path_spec)
        if tgt_password_spec is not None:
            pulumi.set(__self__, "tgt_password_spec", tgt_password_spec)

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        Reference to a secret containing the password to use for authentication.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="tgtGenerationMethod")
    def tgt_generation_method(self) -> Optional[str]:
        """
        Method to generate tgt
        """
        return pulumi.get(self, "tgt_generation_method")

    @property
    @pulumi.getter(name="tgtKeyTabFilePathSpec")
    def tgt_key_tab_file_path_spec(self) -> Optional['outputs.SecretSshkeyKerberosTgtKeyTabFilePathSpec']:
        """
        Authenticate to App Dynamics using username and password.
        """
        return pulumi.get(self, "tgt_key_tab_file_path_spec")

    @property
    @pulumi.getter(name="tgtPasswordSpec")
    def tgt_password_spec(self) -> Optional['outputs.SecretSshkeyKerberosTgtPasswordSpec']:
        """
        Authenticate to App Dynamics using username and password.
        """
        return pulumi.get(self, "tgt_password_spec")


@pulumi.output_type
class SecretSshkeyKerberosTgtKeyTabFilePathSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPath":
            suggest = "key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretSshkeyKerberosTgtKeyTabFilePathSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretSshkeyKerberosTgtKeyTabFilePathSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretSshkeyKerberosTgtKeyTabFilePathSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_path: Optional[str] = None):
        """
        :param str key_path: key path
        """
        if key_path is not None:
            pulumi.set(__self__, "key_path", key_path)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> Optional[str]:
        """
        key path
        """
        return pulumi.get(self, "key_path")


@pulumi.output_type
class SecretSshkeyKerberosTgtPasswordSpec(dict):
    def __init__(__self__, *,
                 password: Optional[str] = None):
        """
        :param str password: password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        if password is not None:
            pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class SecretSshkeySsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "credentialType":
            suggest = "credential_type"
        elif key == "sshPasswordCredential":
            suggest = "ssh_password_credential"
        elif key == "sshkeyPathCredential":
            suggest = "sshkey_path_credential"
        elif key == "sshkeyReferenceCredential":
            suggest = "sshkey_reference_credential"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretSshkeySsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretSshkeySsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretSshkeySsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 credential_type: str,
                 ssh_password_credential: Optional['outputs.SecretSshkeySshSshPasswordCredential'] = None,
                 sshkey_path_credential: Optional['outputs.SecretSshkeySshSshkeyPathCredential'] = None,
                 sshkey_reference_credential: Optional['outputs.SecretSshkeySshSshkeyReferenceCredential'] = None):
        """
        :param str credential_type: This specifies SSH credential type as Password, KeyPath or KeyReference
        :param 'SecretSshkeySshSshPasswordCredentialArgs' ssh_password_credential: SSH credential of type keyReference
        :param 'SecretSshkeySshSshkeyPathCredentialArgs' sshkey_path_credential: SSH credential of type keyPath
        :param 'SecretSshkeySshSshkeyReferenceCredentialArgs' sshkey_reference_credential: SSH credential of type keyReference
        """
        pulumi.set(__self__, "credential_type", credential_type)
        if ssh_password_credential is not None:
            pulumi.set(__self__, "ssh_password_credential", ssh_password_credential)
        if sshkey_path_credential is not None:
            pulumi.set(__self__, "sshkey_path_credential", sshkey_path_credential)
        if sshkey_reference_credential is not None:
            pulumi.set(__self__, "sshkey_reference_credential", sshkey_reference_credential)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> str:
        """
        This specifies SSH credential type as Password, KeyPath or KeyReference
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="sshPasswordCredential")
    def ssh_password_credential(self) -> Optional['outputs.SecretSshkeySshSshPasswordCredential']:
        """
        SSH credential of type keyReference
        """
        return pulumi.get(self, "ssh_password_credential")

    @property
    @pulumi.getter(name="sshkeyPathCredential")
    def sshkey_path_credential(self) -> Optional['outputs.SecretSshkeySshSshkeyPathCredential']:
        """
        SSH credential of type keyPath
        """
        return pulumi.get(self, "sshkey_path_credential")

    @property
    @pulumi.getter(name="sshkeyReferenceCredential")
    def sshkey_reference_credential(self) -> Optional['outputs.SecretSshkeySshSshkeyReferenceCredential']:
        """
        SSH credential of type keyReference
        """
        return pulumi.get(self, "sshkey_reference_credential")


@pulumi.output_type
class SecretSshkeySshSshPasswordCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretSshkeySshSshPasswordCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretSshkeySshSshPasswordCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretSshkeySshSshPasswordCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: str,
                 user_name: str):
        """
        :param str password: SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        :param str user_name: SSH Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        SSH Password. To reference a password at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a password at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class SecretSshkeySshSshkeyPathCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyPath":
            suggest = "key_path"
        elif key == "userName":
            suggest = "user_name"
        elif key == "encryptedPassphrase":
            suggest = "encrypted_passphrase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretSshkeySshSshkeyPathCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretSshkeySshSshkeyPathCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretSshkeySshSshkeyPathCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_path: str,
                 user_name: str,
                 encrypted_passphrase: Optional[str] = None):
        """
        :param str key_path: Path of the key file.
        :param str user_name: SSH Username.
        :param str encrypted_passphrase: Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        pulumi.set(__self__, "key_path", key_path)
        pulumi.set(__self__, "user_name", user_name)
        if encrypted_passphrase is not None:
            pulumi.set(__self__, "encrypted_passphrase", encrypted_passphrase)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> str:
        """
        Path of the key file.
        """
        return pulumi.get(self, "key_path")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="encryptedPassphrase")
    def encrypted_passphrase(self) -> Optional[str]:
        """
        Encrypted Passphrase . To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "encrypted_passphrase")


@pulumi.output_type
class SecretSshkeySshSshkeyReferenceCredential(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userName":
            suggest = "user_name"
        elif key == "encryptedPassphrase":
            suggest = "encrypted_passphrase"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecretSshkeySshSshkeyReferenceCredential. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecretSshkeySshSshkeyReferenceCredential.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecretSshkeySshSshkeyReferenceCredential.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 user_name: str,
                 encrypted_passphrase: Optional[str] = None):
        """
        :param str key: SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
        :param str user_name: SSH Username.
        :param str encrypted_passphrase: Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "user_name", user_name)
        if encrypted_passphrase is not None:
            pulumi.set(__self__, "encrypted_passphrase", encrypted_passphrase)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        SSH key. To reference a key at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a key at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="encryptedPassphrase")
    def encrypted_passphrase(self) -> Optional[str]:
        """
        Encrypted Passphrase. To reference a encryptedPassphrase at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a encryptedPassPhrase at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "encrypted_passphrase")


@pulumi.output_type
class SecretTextAdditionalMetadata(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.SecretTextAdditionalMetadataValue']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.SecretTextAdditionalMetadataValue']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SecretTextAdditionalMetadataValue(dict):
    def __init__(__self__, *,
                 version: Optional[str] = None):
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class ServiceGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "isHarnessCodeRepo":
            suggest = "is_harness_code_repo"
        elif key == "isNewBranch":
            suggest = "is_new_branch"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "loadFromCache":
            suggest = "load_from_cache"
        elif key == "loadFromFallbackBranch":
            suggest = "load_from_fallback_branch"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 is_harness_code_repo: Optional[bool] = None,
                 is_new_branch: Optional[bool] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 load_from_cache: Optional[bool] = None,
                 load_from_fallback_branch: Optional[bool] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param bool is_harness_code_repo: If the repo is in harness code
        :param bool is_new_branch: If the branch being created is new
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param bool load_from_cache: Load service yaml from catch
        :param bool load_from_fallback_branch: Load service yaml from fallback branch
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[bool]:
        """
        If the repo is in harness code
        """
        return pulumi.get(self, "is_harness_code_repo")

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[bool]:
        """
        If the branch being created is new
        """
        return pulumi.get(self, "is_new_branch")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[bool]:
        """
        Load service yaml from catch
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[bool]:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class ServiceNowConnectorAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "refreshToken":
            suggest = "refresh_token"
        elif key == "usernamePassword":
            suggest = "username_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNowConnectorAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNowConnectorAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNowConnectorAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: str,
                 adfs: Optional['outputs.ServiceNowConnectorAuthAdfs'] = None,
                 refresh_token: Optional['outputs.ServiceNowConnectorAuthRefreshToken'] = None,
                 username_password: Optional['outputs.ServiceNowConnectorAuthUsernamePassword'] = None):
        """
        :param str auth_type: Authentication types for Jira connector
        :param 'ServiceNowConnectorAuthAdfsArgs' adfs: Authenticate using adfs client credentials with certificate.
        :param 'ServiceNowConnectorAuthRefreshTokenArgs' refresh_token: Authenticate using refresh token grant type.
        :param 'ServiceNowConnectorAuthUsernamePasswordArgs' username_password: Authenticate using username password.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if adfs is not None:
            pulumi.set(__self__, "adfs", adfs)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)
        if username_password is not None:
            pulumi.set(__self__, "username_password", username_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication types for Jira connector
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter
    def adfs(self) -> Optional['outputs.ServiceNowConnectorAuthAdfs']:
        """
        Authenticate using adfs client credentials with certificate.
        """
        return pulumi.get(self, "adfs")

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional['outputs.ServiceNowConnectorAuthRefreshToken']:
        """
        Authenticate using refresh token grant type.
        """
        return pulumi.get(self, "refresh_token")

    @property
    @pulumi.getter(name="usernamePassword")
    def username_password(self) -> Optional['outputs.ServiceNowConnectorAuthUsernamePassword']:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_password")


@pulumi.output_type
class ServiceNowConnectorAuthAdfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adfsUrl":
            suggest = "adfs_url"
        elif key == "certificateRef":
            suggest = "certificate_ref"
        elif key == "clientIdRef":
            suggest = "client_id_ref"
        elif key == "privateKeyRef":
            suggest = "private_key_ref"
        elif key == "resourceIdRef":
            suggest = "resource_id_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNowConnectorAuthAdfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNowConnectorAuthAdfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNowConnectorAuthAdfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 adfs_url: str,
                 certificate_ref: str,
                 client_id_ref: str,
                 private_key_ref: str,
                 resource_id_ref: str):
        """
        :param str adfs_url: asdf URL.
        :param str certificate_ref: Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_id_ref: Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str private_key_ref: Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str resource_id_ref: Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "adfs_url", adfs_url)
        pulumi.set(__self__, "certificate_ref", certificate_ref)
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        pulumi.set(__self__, "resource_id_ref", resource_id_ref)

    @property
    @pulumi.getter(name="adfsUrl")
    def adfs_url(self) -> str:
        """
        asdf URL.
        """
        return pulumi.get(self, "adfs_url")

    @property
    @pulumi.getter(name="certificateRef")
    def certificate_ref(self) -> str:
        """
        Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "certificate_ref")

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> str:
        """
        Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> str:
        """
        Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @property
    @pulumi.getter(name="resourceIdRef")
    def resource_id_ref(self) -> str:
        """
        Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "resource_id_ref")


@pulumi.output_type
class ServiceNowConnectorAuthRefreshToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIdRef":
            suggest = "client_id_ref"
        elif key == "refreshTokenRef":
            suggest = "refresh_token_ref"
        elif key == "tokenUrl":
            suggest = "token_url"
        elif key == "clientSecretRef":
            suggest = "client_secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNowConnectorAuthRefreshToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNowConnectorAuthRefreshToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNowConnectorAuthRefreshToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id_ref: str,
                 refresh_token_ref: str,
                 token_url: str,
                 client_secret_ref: Optional[str] = None,
                 scope: Optional[str] = None):
        """
        :param str client_id_ref: Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str refresh_token_ref: Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str token_url: Token url to use for authentication.
        :param str client_secret_ref: Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str scope: Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "refresh_token_ref", refresh_token_ref)
        pulumi.set(__self__, "token_url", token_url)
        if client_secret_ref is not None:
            pulumi.set(__self__, "client_secret_ref", client_secret_ref)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> str:
        """
        Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @property
    @pulumi.getter(name="refreshTokenRef")
    def refresh_token_ref(self) -> str:
        """
        Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "refresh_token_ref")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        Token url to use for authentication.
        """
        return pulumi.get(self, "token_url")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class ServiceNowConnectorAuthUsernamePassword(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwordRef":
            suggest = "password_ref"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceNowConnectorAuthUsernamePassword. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceNowConnectorAuthUsernamePassword.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceNowConnectorAuthUsernamePassword.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password_ref: str,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class ServiceOverridesV2GitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "isHarnessCodeRepo":
            suggest = "is_harness_code_repo"
        elif key == "isNewBranch":
            suggest = "is_new_branch"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "loadFromCache":
            suggest = "load_from_cache"
        elif key == "loadFromFallbackBranch":
            suggest = "load_from_fallback_branch"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceOverridesV2GitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceOverridesV2GitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceOverridesV2GitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 is_harness_code_repo: Optional[bool] = None,
                 is_new_branch: Optional[bool] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 load_from_cache: Optional[bool] = None,
                 load_from_fallback_branch: Optional[bool] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param bool is_harness_code_repo: If the repo is in harness code
        :param bool is_new_branch: If the branch being created is new
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating override.
        :param bool load_from_cache: Load service yaml from catch
        :param bool load_from_fallback_branch: Load service yaml from fallback branch
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_harness_code_repo is not None:
            pulumi.set(__self__, "is_harness_code_repo", is_harness_code_repo)
        if is_new_branch is not None:
            pulumi.set(__self__, "is_new_branch", is_new_branch)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if load_from_cache is not None:
            pulumi.set(__self__, "load_from_cache", load_from_cache)
        if load_from_fallback_branch is not None:
            pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter
    def branch(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="isHarnessCodeRepo")
    def is_harness_code_repo(self) -> Optional[bool]:
        """
        If the repo is in harness code
        """
        return pulumi.get(self, "is_harness_code_repo")

    @property
    @pulumi.getter(name="isNewBranch")
    def is_new_branch(self) -> Optional[bool]:
        """
        If the branch being created is new
        """
        return pulumi.get(self, "is_new_branch")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating override.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> Optional[bool]:
        """
        Load service yaml from catch
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> Optional[bool]:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class SloRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloTarget":
            suggest = "slo_target"
        elif key == "userJourneyRefs":
            suggest = "user_journey_refs"
        elif key == "notificationRuleRefs":
            suggest = "notification_rule_refs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 slo_target: 'outputs.SloRequestSloTarget',
                 spec: str,
                 type: str,
                 user_journey_refs: Sequence[str],
                 description: Optional[str] = None,
                 notification_rule_refs: Optional[Sequence['outputs.SloRequestNotificationRuleRef']] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str name: Name for the SLO.
        :param 'SloRequestSloTargetArgs' slo_target: SLO Target specification.
        :param str spec: Specification of the SLO.
        :param str type: Type of the SLO.
        :param Sequence[str] user_journey_refs: User journey reference list for the SLO.
        :param str description: Description for the SLO.
        :param Sequence['SloRequestNotificationRuleRefArgs'] notification_rule_refs: Notification rule references for the SLO.
        :param Sequence[str] tags: Tags for the SLO. comma-separated key value string pairs.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "slo_target", slo_target)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "user_journey_refs", user_journey_refs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if notification_rule_refs is not None:
            pulumi.set(__self__, "notification_rule_refs", notification_rule_refs)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name for the SLO.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloTarget")
    def slo_target(self) -> 'outputs.SloRequestSloTarget':
        """
        SLO Target specification.
        """
        return pulumi.get(self, "slo_target")

    @property
    @pulumi.getter
    def spec(self) -> str:
        """
        Specification of the SLO.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the SLO.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="userJourneyRefs")
    def user_journey_refs(self) -> Sequence[str]:
        """
        User journey reference list for the SLO.
        """
        return pulumi.get(self, "user_journey_refs")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the SLO.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="notificationRuleRefs")
    def notification_rule_refs(self) -> Optional[Sequence['outputs.SloRequestNotificationRuleRef']]:
        """
        Notification rule references for the SLO.
        """
        return pulumi.get(self, "notification_rule_refs")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags for the SLO. comma-separated key value string pairs.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SloRequestNotificationRuleRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notificationRuleRef":
            suggest = "notification_rule_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloRequestNotificationRuleRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloRequestNotificationRuleRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloRequestNotificationRuleRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 notification_rule_ref: str):
        """
        :param bool enabled: Enable or disable notification rule reference for the SLO.
        :param str notification_rule_ref: Notification rule reference for the SLO.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "notification_rule_ref", notification_rule_ref)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Enable or disable notification rule reference for the SLO.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="notificationRuleRef")
    def notification_rule_ref(self) -> str:
        """
        Notification rule reference for the SLO.
        """
        return pulumi.get(self, "notification_rule_ref")


@pulumi.output_type
class SloRequestSloTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloTargetPercentage":
            suggest = "slo_target_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloRequestSloTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloRequestSloTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloRequestSloTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_target_percentage: float,
                 spec: str,
                 type: str):
        """
        :param float slo_target_percentage: Target percentage for the SLO.
        :param str spec: Specification of the SLO Target.
        :param str type: Type of the SLO target.
        """
        pulumi.set(__self__, "slo_target_percentage", slo_target_percentage)
        pulumi.set(__self__, "spec", spec)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="sloTargetPercentage")
    def slo_target_percentage(self) -> float:
        """
        Target percentage for the SLO.
        """
        return pulumi.get(self, "slo_target_percentage")

    @property
    @pulumi.getter
    def spec(self) -> str:
        """
        Specification of the SLO Target.
        """
        return pulumi.get(self, "spec")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the SLO target.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SpotConnectorPermanentToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiTokenRef":
            suggest = "api_token_ref"
        elif key == "delegateSelectors":
            suggest = "delegate_selectors"
        elif key == "executeOnDelegate":
            suggest = "execute_on_delegate"
        elif key == "spotAccountId":
            suggest = "spot_account_id"
        elif key == "spotAccountIdRef":
            suggest = "spot_account_id_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpotConnectorPermanentToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpotConnectorPermanentToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpotConnectorPermanentToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token_ref: str,
                 delegate_selectors: Optional[Sequence[str]] = None,
                 execute_on_delegate: Optional[bool] = None,
                 spot_account_id: Optional[str] = None,
                 spot_account_id_ref: Optional[str] = None):
        """
        :param str api_token_ref: Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: Connect only using delegates with these tags.
        :param bool execute_on_delegate: Execute on delegate or not.
        :param str spot_account_id: Spot account id.
        :param str spot_account_id_ref: Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "api_token_ref", api_token_ref)
        if delegate_selectors is not None:
            pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if execute_on_delegate is not None:
            pulumi.set(__self__, "execute_on_delegate", execute_on_delegate)
        if spot_account_id is not None:
            pulumi.set(__self__, "spot_account_id", spot_account_id)
        if spot_account_id_ref is not None:
            pulumi.set(__self__, "spot_account_id_ref", spot_account_id_ref)

    @property
    @pulumi.getter(name="apiTokenRef")
    def api_token_ref(self) -> str:
        """
        Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "api_token_ref")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Optional[Sequence[str]]:
        """
        Connect only using delegates with these tags.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="executeOnDelegate")
    def execute_on_delegate(self) -> Optional[bool]:
        """
        Execute on delegate or not.
        """
        return pulumi.get(self, "execute_on_delegate")

    @property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> Optional[str]:
        """
        Spot account id.
        """
        return pulumi.get(self, "spot_account_id")

    @property
    @pulumi.getter(name="spotAccountIdRef")
    def spot_account_id_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "spot_account_id_ref")


@pulumi.output_type
class TasConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tasManualDetails":
            suggest = "tas_manual_details"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TasConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TasConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TasConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tas_manual_details: 'outputs.TasConnectorCredentialsTasManualDetails',
                 type: str):
        """
        :param 'TasConnectorCredentialsTasManualDetailsArgs' tas_manual_details: Authenticate to Tas using manual details.
        :param str type: Type can be ManualConfig.
        """
        pulumi.set(__self__, "tas_manual_details", tas_manual_details)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="tasManualDetails")
    def tas_manual_details(self) -> 'outputs.TasConnectorCredentialsTasManualDetails':
        """
        Authenticate to Tas using manual details.
        """
        return pulumi.get(self, "tas_manual_details")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can be ManualConfig.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class TasConnectorCredentialsTasManualDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endpointUrl":
            suggest = "endpoint_url"
        elif key == "passwordRef":
            suggest = "password_ref"
        elif key == "referenceToken":
            suggest = "reference_token"
        elif key == "usernameRef":
            suggest = "username_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TasConnectorCredentialsTasManualDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TasConnectorCredentialsTasManualDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TasConnectorCredentialsTasManualDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint_url: str,
                 password_ref: str,
                 reference_token: Optional[str] = None,
                 username: Optional[str] = None,
                 username_ref: Optional[str] = None):
        """
        :param str endpoint_url: URL of the Tas server.
        :param str password_ref: Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str reference_token: Reference of the secret for the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "endpoint_url", endpoint_url)
        pulumi.set(__self__, "password_ref", password_ref)
        if reference_token is not None:
            pulumi.set(__self__, "reference_token", reference_token)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if username_ref is not None:
            pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> str:
        """
        URL of the Tas server.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference of the secret for the password. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter(name="referenceToken")
    def reference_token(self) -> Optional[str]:
        """
        Reference of the secret for the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}
        """
        return pulumi.get(self, "reference_token")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> Optional[str]:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class TemplateFiltersFilterProperties(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateFiltersFilterProperties. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateFiltersFilterProperties.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateFiltersFilterProperties.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 tags: Optional[Sequence[str]] = None):
        """
        :param str filter_type: Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filters. Currently supported types are {TemplateSetup, TemplateExecution, Template}.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class TemplateGitDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseBranch":
            suggest = "base_branch"
        elif key == "branchName":
            suggest = "branch_name"
        elif key == "commitMessage":
            suggest = "commit_message"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "lastCommitId":
            suggest = "last_commit_id"
        elif key == "lastObjectId":
            suggest = "last_object_id"
        elif key == "repoName":
            suggest = "repo_name"
        elif key == "storeType":
            suggest = "store_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGitDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGitDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGitDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_branch: Optional[str] = None,
                 branch_name: Optional[str] = None,
                 commit_message: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 last_commit_id: Optional[str] = None,
                 last_object_id: Optional[str] = None,
                 repo_name: Optional[str] = None,
                 store_type: Optional[str] = None):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch_name: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        if base_branch is not None:
            pulumi.set(__self__, "base_branch", base_branch)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if commit_message is not None:
            pulumi.set(__self__, "commit_message", commit_message)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if last_commit_id is not None:
            pulumi.set(__self__, "last_commit_id", last_commit_id)
        if last_object_id is not None:
            pulumi.set(__self__, "last_object_id", last_object_id)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if store_type is not None:
            pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> Optional[str]:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> Optional[str]:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity. To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> Optional[str]:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> Optional[str]:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> Optional[str]:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class TemplateGitImportDetails(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "branchName":
            suggest = "branch_name"
        elif key == "connectorRef":
            suggest = "connector_ref"
        elif key == "filePath":
            suggest = "file_path"
        elif key == "isForceImport":
            suggest = "is_force_import"
        elif key == "repoName":
            suggest = "repo_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateGitImportDetails. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateGitImportDetails.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateGitImportDetails.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch_name: Optional[str] = None,
                 connector_ref: Optional[str] = None,
                 file_path: Optional[str] = None,
                 is_force_import: Optional[bool] = None,
                 repo_name: Optional[str] = None):
        """
        :param str branch_name: Name of the branch.
        :param str connector_ref: Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str file_path: File path of the Entity in the repository.
        :param str repo_name: Name of the repository.
        """
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if connector_ref is not None:
            pulumi.set(__self__, "connector_ref", connector_ref)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if is_force_import is not None:
            pulumi.set(__self__, "is_force_import", is_force_import)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> Optional[str]:
        """
        Identifier of the Harness Connector used for importing entity from Git To reference a connector at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a connector at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="isForceImport")
    def is_force_import(self) -> Optional[bool]:
        return pulumi.get(self, "is_force_import")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class TemplateTemplateImportRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateDescription":
            suggest = "template_description"
        elif key == "templateName":
            suggest = "template_name"
        elif key == "templateVersion":
            suggest = "template_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TemplateTemplateImportRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TemplateTemplateImportRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TemplateTemplateImportRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 template_description: Optional[str] = None,
                 template_name: Optional[str] = None,
                 template_version: Optional[str] = None):
        """
        :param str template_description: Description of the template.
        :param str template_name: Name of the template.
        :param str template_version: Version of the template.
        """
        if template_description is not None:
            pulumi.set(__self__, "template_description", template_description)
        if template_name is not None:
            pulumi.set(__self__, "template_name", template_name)
        if template_version is not None:
            pulumi.set(__self__, "template_version", template_version)

    @property
    @pulumi.getter(name="templateDescription")
    def template_description(self) -> Optional[str]:
        """
        Description of the template.
        """
        return pulumi.get(self, "template_description")

    @property
    @pulumi.getter(name="templateName")
    def template_name(self) -> Optional[str]:
        """
        Name of the template.
        """
        return pulumi.get(self, "template_name")

    @property
    @pulumi.getter(name="templateVersion")
    def template_version(self) -> Optional[str]:
        """
        Version of the template.
        """
        return pulumi.get(self, "template_version")


@pulumi.output_type
class TerraformCloudConnectorCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiToken":
            suggest = "api_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TerraformCloudConnectorCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TerraformCloudConnectorCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TerraformCloudConnectorCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token: 'outputs.TerraformCloudConnectorCredentialsApiToken'):
        """
        :param 'TerraformCloudConnectorCredentialsApiTokenArgs' api_token: API token credentials to use for authentication.
        """
        pulumi.set(__self__, "api_token", api_token)

    @property
    @pulumi.getter(name="apiToken")
    def api_token(self) -> 'outputs.TerraformCloudConnectorCredentialsApiToken':
        """
        API token credentials to use for authentication.
        """
        return pulumi.get(self, "api_token")


@pulumi.output_type
class TerraformCloudConnectorCredentialsApiToken(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiTokenRef":
            suggest = "api_token_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TerraformCloudConnectorCredentialsApiToken. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TerraformCloudConnectorCredentialsApiToken.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TerraformCloudConnectorCredentialsApiToken.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_token_ref: str):
        """
        :param str api_token_ref: Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "api_token_ref", api_token_ref)

    @property
    @pulumi.getter(name="apiTokenRef")
    def api_token_ref(self) -> str:
        """
        Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "api_token_ref")


@pulumi.output_type
class UserRoleBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managedRole":
            suggest = "managed_role"
        elif key == "resourceGroupIdentifier":
            suggest = "resource_group_identifier"
        elif key == "resourceGroupName":
            suggest = "resource_group_name"
        elif key == "roleIdentifier":
            suggest = "role_identifier"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UserRoleBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UserRoleBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UserRoleBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 managed_role: Optional[bool] = None,
                 resource_group_identifier: Optional[str] = None,
                 resource_group_name: Optional[str] = None,
                 role_identifier: Optional[str] = None,
                 role_name: Optional[str] = None):
        """
        :param bool managed_role: Managed Role of the user.
        :param str resource_group_identifier: Resource Group Identifier of the user.
        :param str resource_group_name: Resource Group Name of the user.
        :param str role_identifier: Role Identifier of the user.
        :param str role_name: Role Name Identifier of the user.
        """
        if managed_role is not None:
            pulumi.set(__self__, "managed_role", managed_role)
        if resource_group_identifier is not None:
            pulumi.set(__self__, "resource_group_identifier", resource_group_identifier)
        if resource_group_name is not None:
            pulumi.set(__self__, "resource_group_name", resource_group_name)
        if role_identifier is not None:
            pulumi.set(__self__, "role_identifier", role_identifier)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="managedRole")
    def managed_role(self) -> Optional[bool]:
        """
        Managed Role of the user.
        """
        return pulumi.get(self, "managed_role")

    @property
    @pulumi.getter(name="resourceGroupIdentifier")
    def resource_group_identifier(self) -> Optional[str]:
        """
        Resource Group Identifier of the user.
        """
        return pulumi.get(self, "resource_group_identifier")

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> Optional[str]:
        """
        Resource Group Name of the user.
        """
        return pulumi.get(self, "resource_group_name")

    @property
    @pulumi.getter(name="roleIdentifier")
    def role_identifier(self) -> Optional[str]:
        """
        Role Identifier of the user.
        """
        return pulumi.get(self, "role_identifier")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[str]:
        """
        Role Name Identifier of the user.
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class UsergroupNotificationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupEmail":
            suggest = "group_email"
        elif key == "microsoftTeamsWebhookUrl":
            suggest = "microsoft_teams_webhook_url"
        elif key == "pagerDutyKey":
            suggest = "pager_duty_key"
        elif key == "sendEmailToAllUsers":
            suggest = "send_email_to_all_users"
        elif key == "slackWebhookUrl":
            suggest = "slack_webhook_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UsergroupNotificationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UsergroupNotificationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UsergroupNotificationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_email: Optional[str] = None,
                 microsoft_teams_webhook_url: Optional[str] = None,
                 pager_duty_key: Optional[str] = None,
                 send_email_to_all_users: Optional[bool] = None,
                 slack_webhook_url: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str group_email: Group email.
        :param str microsoft_teams_webhook_url: Url of Microsoft teams webhook.
        :param str pager_duty_key: Pager duty key.
        :param bool send_email_to_all_users: Send email to all the group members.
        :param str slack_webhook_url: Url of slack webhook.
        :param str type: Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        if group_email is not None:
            pulumi.set(__self__, "group_email", group_email)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if pager_duty_key is not None:
            pulumi.set(__self__, "pager_duty_key", pager_duty_key)
        if send_email_to_all_users is not None:
            pulumi.set(__self__, "send_email_to_all_users", send_email_to_all_users)
        if slack_webhook_url is not None:
            pulumi.set(__self__, "slack_webhook_url", slack_webhook_url)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupEmail")
    def group_email(self) -> Optional[str]:
        """
        Group email.
        """
        return pulumi.get(self, "group_email")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[str]:
        """
        Url of Microsoft teams webhook.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="pagerDutyKey")
    def pager_duty_key(self) -> Optional[str]:
        """
        Pager duty key.
        """
        return pulumi.get(self, "pager_duty_key")

    @property
    @pulumi.getter(name="sendEmailToAllUsers")
    def send_email_to_all_users(self) -> Optional[bool]:
        """
        Send email to all the group members.
        """
        return pulumi.get(self, "send_email_to_all_users")

    @property
    @pulumi.getter(name="slackWebhookUrl")
    def slack_webhook_url(self) -> Optional[str]:
        """
        Url of slack webhook.
        """
        return pulumi.get(self, "slack_webhook_url")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VariablesSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fixedValue":
            suggest = "fixed_value"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VariablesSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VariablesSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VariablesSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fixed_value: str,
                 value_type: str):
        """
        :param str fixed_value: FixedValue of the variable
        :param str value_type: Type of Value of the Variable. For now only FIXED is supported
        """
        pulumi.set(__self__, "fixed_value", fixed_value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> str:
        """
        FixedValue of the variable
        """
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Type of Value of the Variable. For now only FIXED is supported
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class WorkspaceEnvironmentVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceEnvironmentVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceEnvironmentVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceEnvironmentVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable. Must be unique within the workspace.
        :param str value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param str value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable. Must be unique within the workspace.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class WorkspaceTerraformVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceTerraformVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceTerraformVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceTerraformVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable. Must be unique within the workspace.
        :param str value: Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        :param str value_type: Value type indicates the value type of the variable. Currently we support string and secret.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable. Must be unique within the workspace.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value is the value of the variable. For string value types this field should contain the value of the variable. For secret value types this should contain a reference to a valid harness secret.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable. Currently we support string and secret.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class WorkspaceTerraformVariableFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repositoryConnector":
            suggest = "repository_connector"
        elif key == "repositoryBranch":
            suggest = "repository_branch"
        elif key == "repositoryCommit":
            suggest = "repository_commit"
        elif key == "repositoryPath":
            suggest = "repository_path"
        elif key == "repositorySha":
            suggest = "repository_sha"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkspaceTerraformVariableFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkspaceTerraformVariableFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkspaceTerraformVariableFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 repository: str,
                 repository_connector: str,
                 repository_branch: Optional[str] = None,
                 repository_commit: Optional[str] = None,
                 repository_path: Optional[str] = None,
                 repository_sha: Optional[str] = None):
        """
        :param str repository: Repository is the name of the repository to fetch the code from.
        :param str repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param str repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param str repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param str repository_path: Repository path is the path in which the variables reside.
        :param str repository_sha: Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_branch is not None:
            pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit is not None:
            pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_path is not None:
            pulumi.set(__self__, "repository_path", repository_path)
        if repository_sha is not None:
            pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> str:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> Optional[str]:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> Optional[str]:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> Optional[str]:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> Optional[str]:
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")


@pulumi.output_type
class GetAppDynamicsConnectorApiTokenResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_ref: str):
        """
        :param str client_id: The client id used for connecting to App Dynamics.
        :param str client_secret_ref: Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id used for connecting to App Dynamics.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> str:
        """
        Reference to the Harness secret containing the App Dynamics client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")


@pulumi.output_type
class GetAppDynamicsConnectorUsernamePasswordResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetArtifactoryConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetAwsCCConnectorCrossAccountAccessResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 role_arn: str):
        """
        :param str external_id: The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        :param str role_arn: The ARN of the role to use for cross-account access.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        The external id of the role to use for cross-account access. This is a random unique value to provide additional secure authentication.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role to use for cross-account access.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetAwsConnectorCrossAccountAccessResult(dict):
    def __init__(__self__, *,
                 external_id: str,
                 role_arn: str):
        """
        :param str external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        :param str role_arn: The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        """
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The Amazon Resource Name (ARN) of the role that you want to assume. This is an IAM role in the target AWS account.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetAwsConnectorEqualJitterBackoffStrategyResult(dict):
    def __init__(__self__, *,
                 base_delay: int,
                 max_backoff_time: int,
                 retry_count: int):
        """
        :param int base_delay: Base delay.
        :param int max_backoff_time: Max BackOff Time.
        :param int retry_count: Retry Count.
        """
        pulumi.set(__self__, "base_delay", base_delay)
        pulumi.set(__self__, "max_backoff_time", max_backoff_time)
        pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="baseDelay")
    def base_delay(self) -> int:
        """
        Base delay.
        """
        return pulumi.get(self, "base_delay")

    @property
    @pulumi.getter(name="maxBackoffTime")
    def max_backoff_time(self) -> int:
        """
        Max BackOff Time.
        """
        return pulumi.get(self, "max_backoff_time")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> int:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")


@pulumi.output_type
class GetAwsConnectorFixedDelayBackoffStrategyResult(dict):
    def __init__(__self__, *,
                 fixed_backoff: int,
                 retry_count: int):
        """
        :param int fixed_backoff: Fixed Backoff.
        :param int retry_count: Retry Count.
        """
        pulumi.set(__self__, "fixed_backoff", fixed_backoff)
        pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="fixedBackoff")
    def fixed_backoff(self) -> int:
        """
        Fixed Backoff.
        """
        return pulumi.get(self, "fixed_backoff")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> int:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")


@pulumi.output_type
class GetAwsConnectorFullJitterBackoffStrategyResult(dict):
    def __init__(__self__, *,
                 base_delay: int,
                 max_backoff_time: int,
                 retry_count: int):
        """
        :param int base_delay: Base delay.
        :param int max_backoff_time: Max BackOff Time.
        :param int retry_count: Retry Count.
        """
        pulumi.set(__self__, "base_delay", base_delay)
        pulumi.set(__self__, "max_backoff_time", max_backoff_time)
        pulumi.set(__self__, "retry_count", retry_count)

    @property
    @pulumi.getter(name="baseDelay")
    def base_delay(self) -> int:
        """
        Base delay.
        """
        return pulumi.get(self, "base_delay")

    @property
    @pulumi.getter(name="maxBackoffTime")
    def max_backoff_time(self) -> int:
        """
        Max BackOff Time.
        """
        return pulumi.get(self, "max_backoff_time")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> int:
        """
        Retry Count.
        """
        return pulumi.get(self, "retry_count")


@pulumi.output_type
class GetAwsConnectorInheritFromDelegateResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 region: Optional[str] = None):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str region: Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAwsConnectorIrsaResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 region: Optional[str] = None):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str region: Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAwsConnectorManualResult(dict):
    def __init__(__self__, *,
                 access_key: str,
                 access_key_ref: str,
                 delegate_selectors: Sequence[str],
                 secret_key_ref: str,
                 access_key_plain_text: Optional[str] = None,
                 region: Optional[str] = None,
                 session_token_ref: Optional[str] = None):
        """
        :param str access_key: AWS access key.
        :param str access_key_ref: Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: Connect only use delegates with these tags.
        :param str secret_key_ref: Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str access_key_plain_text: The plain text AWS access key.
        :param str region: Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str session_token_ref: Reference to the Harness secret containing the aws session token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "access_key_ref", access_key_ref)
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)
        if access_key_plain_text is not None:
            pulumi.set(__self__, "access_key_plain_text", access_key_plain_text)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if session_token_ref is not None:
            pulumi.set(__self__, "session_token_ref", session_token_ref)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> str:
        """
        AWS access key.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the aws access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        Connect only use delegates with these tags.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the aws secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")

    @property
    @pulumi.getter(name="accessKeyPlainText")
    def access_key_plain_text(self) -> Optional[str]:
        """
        The plain text AWS access key.
        """
        return pulumi.get(self, "access_key_plain_text")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="sessionTokenRef")
    def session_token_ref(self) -> Optional[str]:
        """
        Reference to the Harness secret containing the aws session token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "session_token_ref")


@pulumi.output_type
class GetAwsConnectorOidcAuthenticationResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 iam_role_arn: str,
                 region: Optional[str] = None):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str iam_role_arn: The IAM Role to assume the credentials from.
        :param str region: Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The IAM Role to assume the credentials from.
        """
        return pulumi.get(self, "iam_role_arn")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Test Region to perform Connection test of AWS Connector To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetAwsKmsConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 assume_roles: Sequence['outputs.GetAwsKmsConnectorCredentialAssumeRoleResult'],
                 inherit_from_delegate: bool,
                 manuals: Sequence['outputs.GetAwsKmsConnectorCredentialManualResult'],
                 oidc_authentications: Sequence['outputs.GetAwsKmsConnectorCredentialOidcAuthenticationResult']):
        """
        :param Sequence['GetAwsKmsConnectorCredentialAssumeRoleArgs'] assume_roles: Connect using STS assume role.
        :param bool inherit_from_delegate: Inherit the credentials from from the delegate.
        :param Sequence['GetAwsKmsConnectorCredentialManualArgs'] manuals: Specify the AWS key and secret used for authenticating.
        :param Sequence['GetAwsKmsConnectorCredentialOidcAuthenticationArgs'] oidc_authentications: Authentication using OIDC.
        """
        pulumi.set(__self__, "assume_roles", assume_roles)
        pulumi.set(__self__, "inherit_from_delegate", inherit_from_delegate)
        pulumi.set(__self__, "manuals", manuals)
        pulumi.set(__self__, "oidc_authentications", oidc_authentications)

    @property
    @pulumi.getter(name="assumeRoles")
    def assume_roles(self) -> Sequence['outputs.GetAwsKmsConnectorCredentialAssumeRoleResult']:
        """
        Connect using STS assume role.
        """
        return pulumi.get(self, "assume_roles")

    @property
    @pulumi.getter(name="inheritFromDelegate")
    def inherit_from_delegate(self) -> bool:
        """
        Inherit the credentials from from the delegate.
        """
        return pulumi.get(self, "inherit_from_delegate")

    @property
    @pulumi.getter
    def manuals(self) -> Sequence['outputs.GetAwsKmsConnectorCredentialManualResult']:
        """
        Specify the AWS key and secret used for authenticating.
        """
        return pulumi.get(self, "manuals")

    @property
    @pulumi.getter(name="oidcAuthentications")
    def oidc_authentications(self) -> Sequence['outputs.GetAwsKmsConnectorCredentialOidcAuthenticationResult']:
        """
        Authentication using OIDC.
        """
        return pulumi.get(self, "oidc_authentications")


@pulumi.output_type
class GetAwsKmsConnectorCredentialAssumeRoleResult(dict):
    def __init__(__self__, *,
                 duration: int,
                 external_id: str,
                 role_arn: str):
        """
        :param int duration: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        :param str external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        :param str role_arn: The ARN of the role to assume.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role to assume.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetAwsKmsConnectorCredentialManualResult(dict):
    def __init__(__self__, *,
                 access_key_ref: str,
                 secret_key_ref: str):
        """
        :param str access_key_ref: The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str secret_key_ref: The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "access_key_ref", access_key_ref)
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetAwsKmsConnectorCredentialOidcAuthenticationResult(dict):
    def __init__(__self__, *,
                 iam_role_arn: str):
        """
        :param str iam_role_arn: The IAM role ARN to assume.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The IAM role ARN to assume.
        """
        return pulumi.get(self, "iam_role_arn")


@pulumi.output_type
class GetAwsSecretManagerConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 assume_roles: Sequence['outputs.GetAwsSecretManagerConnectorCredentialAssumeRoleResult'],
                 inherit_from_delegate: bool,
                 manuals: Sequence['outputs.GetAwsSecretManagerConnectorCredentialManualResult'],
                 oidc_authentications: Sequence['outputs.GetAwsSecretManagerConnectorCredentialOidcAuthenticationResult']):
        """
        :param Sequence['GetAwsSecretManagerConnectorCredentialAssumeRoleArgs'] assume_roles: Connect using STS assume role.
        :param bool inherit_from_delegate: Inherit the credentials from from the delegate.
        :param Sequence['GetAwsSecretManagerConnectorCredentialManualArgs'] manuals: Specify the AWS key and secret used for authenticating.
        :param Sequence['GetAwsSecretManagerConnectorCredentialOidcAuthenticationArgs'] oidc_authentications: Authentication using OIDC.
        """
        pulumi.set(__self__, "assume_roles", assume_roles)
        pulumi.set(__self__, "inherit_from_delegate", inherit_from_delegate)
        pulumi.set(__self__, "manuals", manuals)
        pulumi.set(__self__, "oidc_authentications", oidc_authentications)

    @property
    @pulumi.getter(name="assumeRoles")
    def assume_roles(self) -> Sequence['outputs.GetAwsSecretManagerConnectorCredentialAssumeRoleResult']:
        """
        Connect using STS assume role.
        """
        return pulumi.get(self, "assume_roles")

    @property
    @pulumi.getter(name="inheritFromDelegate")
    def inherit_from_delegate(self) -> bool:
        """
        Inherit the credentials from from the delegate.
        """
        return pulumi.get(self, "inherit_from_delegate")

    @property
    @pulumi.getter
    def manuals(self) -> Sequence['outputs.GetAwsSecretManagerConnectorCredentialManualResult']:
        """
        Specify the AWS key and secret used for authenticating.
        """
        return pulumi.get(self, "manuals")

    @property
    @pulumi.getter(name="oidcAuthentications")
    def oidc_authentications(self) -> Sequence['outputs.GetAwsSecretManagerConnectorCredentialOidcAuthenticationResult']:
        """
        Authentication using OIDC.
        """
        return pulumi.get(self, "oidc_authentications")


@pulumi.output_type
class GetAwsSecretManagerConnectorCredentialAssumeRoleResult(dict):
    def __init__(__self__, *,
                 duration: int,
                 external_id: str,
                 role_arn: str):
        """
        :param int duration: The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        :param str external_id: If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        :param str role_arn: The ARN of the role to assume.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)

    @property
    @pulumi.getter
    def duration(self) -> int:
        """
        The duration, in seconds, of the role session. The value can range from 900 seconds (15 minutes) to 3600 seconds (1 hour). By default, the value is set to 3600 seconds. An expiration can also be specified in the client request body. The minimum value is 1 hour.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> str:
        """
        If the administrator of the account to which the role belongs provided you with an external ID, then enter that value.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> str:
        """
        The ARN of the role to assume.
        """
        return pulumi.get(self, "role_arn")


@pulumi.output_type
class GetAwsSecretManagerConnectorCredentialManualResult(dict):
    def __init__(__self__, *,
                 access_key_ref: str,
                 secret_key_ref: str):
        """
        :param str access_key_ref: The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str secret_key_ref: The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "access_key_ref", access_key_ref)
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="accessKeyRef")
    def access_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS access key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "access_key_ref")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        The reference to the Harness secret containing the AWS secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetAwsSecretManagerConnectorCredentialOidcAuthenticationResult(dict):
    def __init__(__self__, *,
                 iam_role_arn: str):
        """
        :param str iam_role_arn: The IAM role ARN to assume.
        """
        pulumi.set(__self__, "iam_role_arn", iam_role_arn)

    @property
    @pulumi.getter(name="iamRoleArn")
    def iam_role_arn(self) -> str:
        """
        The IAM role ARN to assume.
        """
        return pulumi.get(self, "iam_role_arn")


@pulumi.output_type
class GetAzureCloudCostConnectorBillingExportSpecResult(dict):
    def __init__(__self__, *,
                 container_name: str,
                 directory_name: str,
                 report_name: str,
                 storage_account_name: str,
                 subscription_id: str):
        """
        :param str container_name: Name of the container.
        :param str directory_name: Name of the directory.
        :param str report_name: Name of the report.
        :param str storage_account_name: Name of the storage account.
        :param str subscription_id: Subsription Id.
        """
        pulumi.set(__self__, "container_name", container_name)
        pulumi.set(__self__, "directory_name", directory_name)
        pulumi.set(__self__, "report_name", report_name)
        pulumi.set(__self__, "storage_account_name", storage_account_name)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="containerName")
    def container_name(self) -> str:
        """
        Name of the container.
        """
        return pulumi.get(self, "container_name")

    @property
    @pulumi.getter(name="directoryName")
    def directory_name(self) -> str:
        """
        Name of the directory.
        """
        return pulumi.get(self, "directory_name")

    @property
    @pulumi.getter(name="reportName")
    def report_name(self) -> str:
        """
        Name of the report.
        """
        return pulumi.get(self, "report_name")

    @property
    @pulumi.getter(name="storageAccountName")
    def storage_account_name(self) -> str:
        """
        Name of the storage account.
        """
        return pulumi.get(self, "storage_account_name")

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> str:
        """
        Subsription Id.
        """
        return pulumi.get(self, "subscription_id")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 azure_inherit_from_delegate_details: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailResult'],
                 azure_manual_details: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailResult'],
                 type: str):
        """
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailArgs'] azure_inherit_from_delegate_details: Authenticate to Azure Cloud Provider using details inheriting from delegate.
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureManualDetailArgs'] azure_manual_details: Authenticate to Azure Cloud Provider using manual details.
        :param str type: Type can either be InheritFromDelegate or ManualConfig.
        """
        pulumi.set(__self__, "azure_inherit_from_delegate_details", azure_inherit_from_delegate_details)
        pulumi.set(__self__, "azure_manual_details", azure_manual_details)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="azureInheritFromDelegateDetails")
    def azure_inherit_from_delegate_details(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailResult']:
        """
        Authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        return pulumi.get(self, "azure_inherit_from_delegate_details")

    @property
    @pulumi.getter(name="azureManualDetails")
    def azure_manual_details(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailResult']:
        """
        Authenticate to Azure Cloud Provider using manual details.
        """
        return pulumi.get(self, "azure_manual_details")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can either be InheritFromDelegate or ManualConfig.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailResult(dict):
    def __init__(__self__, *,
                 auths: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthResult']):
        """
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthArgs'] auths: Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        pulumi.set(__self__, "auths", auths)

    @property
    @pulumi.getter
    def auths(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthResult']:
        """
        Auth to authenticate to Azure Cloud Provider using details inheriting from delegate.
        """
        return pulumi.get(self, "auths")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthResult(dict):
    def __init__(__self__, *,
                 azure_msi_auth_uas: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUaResult'],
                 type: str):
        """
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUaArgs'] azure_msi_auth_uas: Azure UserAssigned MSI auth details.
        :param str type: Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        """
        pulumi.set(__self__, "azure_msi_auth_uas", azure_msi_auth_uas)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="azureMsiAuthUas")
    def azure_msi_auth_uas(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUaResult']:
        """
        Azure UserAssigned MSI auth details.
        """
        return pulumi.get(self, "azure_msi_auth_uas")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can either be SystemAssignedManagedIdentity or UserAssignedManagedIdentity.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureInheritFromDelegateDetailAuthAzureMsiAuthUaResult(dict):
    def __init__(__self__, *,
                 client_id: str):
        """
        :param str client_id: Client Id of the ManagedIdentity resource.
        """
        pulumi.set(__self__, "client_id", client_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Client Id of the ManagedIdentity resource.
        """
        return pulumi.get(self, "client_id")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureManualDetailResult(dict):
    def __init__(__self__, *,
                 application_id: str,
                 auths: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthResult'],
                 tenant_id: str):
        """
        :param str application_id: Application ID of the Azure App.
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthArgs'] auths: Contains Azure auth details.
        :param str tenant_id: The Azure Active Directory (AAD) directory ID where you created your application.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "auths", auths)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        Application ID of the Azure App.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter
    def auths(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthResult']:
        """
        Contains Azure auth details.
        """
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        The Azure Active Directory (AAD) directory ID where you created your application.
        """
        return pulumi.get(self, "tenant_id")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthResult(dict):
    def __init__(__self__, *,
                 azure_client_key_certs: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCertResult'],
                 azure_client_secret_keys: Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKeyResult'],
                 type: str):
        """
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCertArgs'] azure_client_key_certs: Azure client key certificate details.
        :param Sequence['GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKeyArgs'] azure_client_secret_keys: Azure Client Secret Key details.
        :param str type: Type can either be Certificate or Secret.
        """
        pulumi.set(__self__, "azure_client_key_certs", azure_client_key_certs)
        pulumi.set(__self__, "azure_client_secret_keys", azure_client_secret_keys)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="azureClientKeyCerts")
    def azure_client_key_certs(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCertResult']:
        """
        Azure client key certificate details.
        """
        return pulumi.get(self, "azure_client_key_certs")

    @property
    @pulumi.getter(name="azureClientSecretKeys")
    def azure_client_secret_keys(self) -> Sequence['outputs.GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKeyResult']:
        """
        Azure Client Secret Key details.
        """
        return pulumi.get(self, "azure_client_secret_keys")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can either be Certificate or Secret.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientKeyCertResult(dict):
    def __init__(__self__, *,
                 certificate_ref: str):
        """
        :param str certificate_ref: Reference of the secret for the certificate.
        """
        pulumi.set(__self__, "certificate_ref", certificate_ref)

    @property
    @pulumi.getter(name="certificateRef")
    def certificate_ref(self) -> str:
        """
        Reference of the secret for the certificate.
        """
        return pulumi.get(self, "certificate_ref")


@pulumi.output_type
class GetAzureCloudProviderConnectorCredentialAzureManualDetailAuthAzureClientSecretKeyResult(dict):
    def __init__(__self__, *,
                 secret_ref: str):
        """
        :param str secret_ref: Reference of the secret for the secret key.
        """
        pulumi.set(__self__, "secret_ref", secret_ref)

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> str:
        """
        Reference of the secret for the secret key.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class GetBitbucketConnectorApiAuthenticationResult(dict):
    def __init__(__self__, *,
                 token_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str token_ref: Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: The username used for connecting to the api.
        :param str username_ref: The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Personal access token for interacting with the BitBucket api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username used for connecting to the api.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        The name of the Harness secret containing the username. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetBitbucketConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 https: Sequence['outputs.GetBitbucketConnectorCredentialHttpResult'],
                 sshes: Sequence['outputs.GetBitbucketConnectorCredentialSshResult']):
        """
        :param Sequence['GetBitbucketConnectorCredentialHttpArgs'] https: Authenticate using Username and password over http(s) for the connection.
        :param Sequence['GetBitbucketConnectorCredentialSshArgs'] sshes: Authenticate using SSH for the connection.
        """
        pulumi.set(__self__, "https", https)
        pulumi.set(__self__, "sshes", sshes)

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetBitbucketConnectorCredentialHttpResult']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def sshes(self) -> Sequence['outputs.GetBitbucketConnectorCredentialSshResult']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "sshes")


@pulumi.output_type
class GetBitbucketConnectorCredentialHttpResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetBitbucketConnectorCredentialSshResult(dict):
    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GetCcmFiltersFilterPropertyResult(dict):
    def __init__(__self__, *,
                 filter_type: str,
                 tags: Sequence[str]):
        """
        :param str filter_type: Corresponding Entity of the filters.
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filters.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetConnectorCustomSecretManagerTemplateInputResult(dict):
    def __init__(__self__, *,
                 environment_variables: Sequence['outputs.GetConnectorCustomSecretManagerTemplateInputEnvironmentVariableResult']):
        pulumi.set(__self__, "environment_variables", environment_variables)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Sequence['outputs.GetConnectorCustomSecretManagerTemplateInputEnvironmentVariableResult']:
        return pulumi.get(self, "environment_variables")


@pulumi.output_type
class GetConnectorCustomSecretManagerTemplateInputEnvironmentVariableResult(dict):
    def __init__(__self__, *,
                 default: bool,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: : Name of the resource.
        :param str type: : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        pulumi.set(__self__, "default", default)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def default(self) -> bool:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        : Name of the resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        : Type of the custom secrets manager, typically set to `CustomSecretManager`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetConnectorCustomhealthsourceHeaderResult(dict):
    def __init__(__self__, *,
                 encrypted_value_ref: str,
                 key: str,
                 value: str,
                 value_encrypted: bool):
        """
        :param str encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str key: Key.
        :param str value: Value.
        :param bool value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> str:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> bool:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")


@pulumi.output_type
class GetConnectorCustomhealthsourceParamResult(dict):
    def __init__(__self__, *,
                 encrypted_value_ref: str,
                 key: str,
                 value: str,
                 value_encrypted: bool):
        """
        :param str encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str key: Key.
        :param str value: Value.
        :param bool value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> str:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> bool:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")


@pulumi.output_type
class GetConnectorGcpKmsManualResult(dict):
    def __init__(__self__, *,
                 credentials: str,
                 delegate_selectors: Sequence[str]):
        """
        :param str credentials: Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: The delegates to connect with.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter
    def credentials(self) -> str:
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "credentials")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to connect with.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class GetConnectorGcpKmsOidcAuthenticationResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 gcp_project_id: str,
                 provider_id: str,
                 service_account_email: str,
                 workload_pool_id: str):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str gcp_project_id: The project number of the GCP project that is used to create the workload identity..
        :param str provider_id: The OIDC provider ID value configured in GCP.
        :param str service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param str workload_pool_id: The workload pool ID value created in GCP.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The project number of the GCP project that is used to create the workload identity..
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> str:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")


@pulumi.output_type
class GetConnectorJdbcCredentialResult(dict):
    def __init__(__self__, *,
                 auth_type: str,
                 password_ref: str,
                 service_accounts: Sequence['outputs.GetConnectorJdbcCredentialServiceAccountResult'],
                 username: str,
                 username_passwords: Sequence['outputs.GetConnectorJdbcCredentialUsernamePasswordResult'],
                 username_ref: str):
        """
        :param str auth_type: Authentication types for JDBC connector
        :param str password_ref: The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence['GetConnectorJdbcCredentialServiceAccountArgs'] service_accounts: Authenticate using service account.
        :param str username: The username to use for the database server.
        :param Sequence['GetConnectorJdbcCredentialUsernamePasswordArgs'] username_passwords: Authenticate using username password.
        :param str username_ref: The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "service_accounts", service_accounts)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_passwords", username_passwords)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication types for JDBC connector
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        The reference to the Harness secret containing the password to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter(name="serviceAccounts")
    def service_accounts(self) -> Sequence['outputs.GetConnectorJdbcCredentialServiceAccountResult']:
        """
        Authenticate using service account.
        """
        return pulumi.get(self, "service_accounts")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for the database server.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernamePasswords")
    def username_passwords(self) -> Sequence['outputs.GetConnectorJdbcCredentialUsernamePasswordResult']:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_passwords")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        The reference to the Harness secret containing the username to use for the database server. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetConnectorJdbcCredentialServiceAccountResult(dict):
    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference to a secret containing the token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class GetConnectorJdbcCredentialUsernamePasswordResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetConnectorPdcHostResult(dict):
    def __init__(__self__, *,
                 hostname: str,
                 attributes: Optional[Mapping[str, str]] = None):
        """
        :param str hostname: Hostname e.g. 87.23.66.11:80
        :param Mapping[str, str] attributes: Host attributes with values. e.g. type, region, name, ip, etc.
        """
        pulumi.set(__self__, "hostname", hostname)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter
    def hostname(self) -> str:
        """
        Hostname e.g. 87.23.66.11:80
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def attributes(self) -> Optional[Mapping[str, str]]:
        """
        Host attributes with values. e.g. type, region, name, ip, etc.
        """
        return pulumi.get(self, "attributes")


@pulumi.output_type
class GetConnectorRancherBearerTokenResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 rancher_url: str):
        """
        :param str password_ref: Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str rancher_url: The URL of the Rancher cluster.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "rancher_url", rancher_url)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to the secret containing the bearer token for the rancher cluster. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter(name="rancherUrl")
    def rancher_url(self) -> str:
        """
        The URL of the Rancher cluster.
        """
        return pulumi.get(self, "rancher_url")


@pulumi.output_type
class GetDbSchemaSchemaSourceResult(dict):
    def __init__(__self__, *,
                 archive_path: str,
                 connector: str,
                 location: str,
                 repo: str):
        """
        :param str archive_path: If connector type is artifactory, path to the archive file which contains the changeLog
        :param str connector: Connector to repository at which to find details about the database schema
        :param str location: The path within the specified repository at which to find details about the database schema
        :param str repo: If connector url is of account, which repository to connect to using the connector
        """
        pulumi.set(__self__, "archive_path", archive_path)
        pulumi.set(__self__, "connector", connector)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter(name="archivePath")
    def archive_path(self) -> str:
        """
        If connector type is artifactory, path to the archive file which contains the changeLog
        """
        return pulumi.get(self, "archive_path")

    @property
    @pulumi.getter
    def connector(self) -> str:
        """
        Connector to repository at which to find details about the database schema
        """
        return pulumi.get(self, "connector")

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        The path within the specified repository at which to find details about the database schema
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def repo(self) -> str:
        """
        If connector url is of account, which repository to connect to using the connector
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetDockerConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 execute_on_delegate: bool,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param bool execute_on_delegate: Execute on delegate or not.
        :param str password_ref: The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: The username to use for the docker registry.
        :param str username_ref: The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "execute_on_delegate", execute_on_delegate)
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="executeOnDelegate")
    def execute_on_delegate(self) -> bool:
        """
        Execute on delegate or not.
        """
        return pulumi.get(self, "execute_on_delegate")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        The reference to the Harness secret containing the password to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username to use for the docker registry.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        The reference to the Harness secret containing the username to use for the docker registry. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetElasticsearchConnectorApiTokenResult(dict):
    def __init__(__self__, *,
                 client_id: str,
                 client_secret_ref: str):
        """
        :param str client_id: The client id used for connecting to ElasticSearch.
        :param str client_secret_ref: Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        The client id used for connecting to ElasticSearch.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> str:
        """
        Reference to the Harness secret containing the ElasticSearch client secret. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")


@pulumi.output_type
class GetElasticsearchConnectorUsernamePasswordResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetEnvironmentClustersMappingClusterResult(dict):
    def __init__(__self__, *,
                 agent_identifier: Optional[str] = None,
                 identifier: Optional[str] = None,
                 name: Optional[str] = None,
                 scope: Optional[str] = None):
        """
        :param str agent_identifier: agent identifier of the cluster (include scope prefix)
        :param str identifier: identifier of the cluster
        :param str name: name of the cluster
        :param str scope: scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        if agent_identifier is not None:
            pulumi.set(__self__, "agent_identifier", agent_identifier)
        if identifier is not None:
            pulumi.set(__self__, "identifier", identifier)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @property
    @pulumi.getter(name="agentIdentifier")
    def agent_identifier(self) -> Optional[str]:
        """
        agent identifier of the cluster (include scope prefix)
        """
        return pulumi.get(self, "agent_identifier")

    @property
    @pulumi.getter
    def identifier(self) -> Optional[str]:
        """
        identifier of the cluster
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        name of the cluster
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        scope at which the cluster exists in harness gitops, one of "ACCOUNT", "ORGANIZATION", "PROJECT". Scope of environment to which clusters are being mapped must be lower or equal to in hierarchy than the scope of the cluster
        """
        return pulumi.get(self, "scope")


@pulumi.output_type
class GetEnvironmentGitDetailsResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 load_from_fallback_branch: bool,
                 repo_name: str):
        """
        :param str branch: Name of the branch.
        :param bool load_from_fallback_branch: Load environment yaml from fallback branch
        :param str repo_name: Repo name of remote environment
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> bool:
        """
        Load environment yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Repo name of remote environment
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetEnvironmentListEnvironmentResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 name: str):
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFileStoreFileCreatedByResult(dict):
    def __init__(__self__, *,
                 email: str,
                 name: str):
        """
        :param str email: User email
        :param str name: User name
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFileStoreFileLastModifiedByResult(dict):
    def __init__(__self__, *,
                 email: str,
                 name: str):
        """
        :param str email: User email
        :param str name: User name
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFileStoreFolderCreatedByResult(dict):
    def __init__(__self__, *,
                 email: str,
                 name: str):
        """
        :param str email: User email
        :param str name: User name
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFileStoreFolderLastModifiedByResult(dict):
    def __init__(__self__, *,
                 email: str,
                 name: str):
        """
        :param str email: User email
        :param str name: User name
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        User email
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        User name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetFiltersFilterPropertyResult(dict):
    def __init__(__self__, *,
                 filter_type: str,
                 tags: Sequence[str]):
        """
        :param str filter_type: Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filter. Currently supported types are {Connector, DelegateProfile, Delegate, EnvironmentGroup, FileStore, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetGcpCloudCostConnectorBillingExportSpecResult(dict):
    def __init__(__self__, *,
                 data_set_id: str,
                 table_id: str):
        """
        :param str data_set_id: Data Set Id.
        :param str table_id: Table Id.
        """
        pulumi.set(__self__, "data_set_id", data_set_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="dataSetId")
    def data_set_id(self) -> str:
        """
        Data Set Id.
        """
        return pulumi.get(self, "data_set_id")

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> str:
        """
        Table Id.
        """
        return pulumi.get(self, "table_id")


@pulumi.output_type
class GetGcpConnectorInheritFromDelegateResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str]):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class GetGcpConnectorManualResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 secret_key_ref: str):
        """
        :param Sequence[str] delegate_selectors: The delegates to connect with.
        :param str secret_key_ref: Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "secret_key_ref", secret_key_ref)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to connect with.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="secretKeyRef")
    def secret_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the secret key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_key_ref")


@pulumi.output_type
class GetGcpConnectorOidcAuthenticationResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str],
                 gcp_project_id: str,
                 provider_id: str,
                 service_account_email: str,
                 workload_pool_id: str):
        """
        :param Sequence[str] delegate_selectors: The delegates to inherit the credentials from.
        :param str gcp_project_id: The project number of the GCP project that is used to create the workload identity..
        :param str provider_id: The OIDC provider ID value configured in GCP.
        :param str service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param str workload_pool_id: The workload pool ID value created in GCP.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        The delegates to inherit the credentials from.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The project number of the GCP project that is used to create the workload identity..
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> str:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")


@pulumi.output_type
class GetGcpSecretManagerConnectorOidcAuthenticationResult(dict):
    def __init__(__self__, *,
                 gcp_project_id: str,
                 provider_id: str,
                 service_account_email: str,
                 workload_pool_id: str):
        """
        :param str gcp_project_id: The project number of the GCP project that is used to create the workload identity..
        :param str provider_id: The OIDC provider ID value configured in GCP.
        :param str service_account_email: The service account linked to workload identity pool while setting GCP workload identity provider.
        :param str workload_pool_id: The workload pool ID value created in GCP.
        """
        pulumi.set(__self__, "gcp_project_id", gcp_project_id)
        pulumi.set(__self__, "provider_id", provider_id)
        pulumi.set(__self__, "service_account_email", service_account_email)
        pulumi.set(__self__, "workload_pool_id", workload_pool_id)

    @property
    @pulumi.getter(name="gcpProjectId")
    def gcp_project_id(self) -> str:
        """
        The project number of the GCP project that is used to create the workload identity..
        """
        return pulumi.get(self, "gcp_project_id")

    @property
    @pulumi.getter(name="providerId")
    def provider_id(self) -> str:
        """
        The OIDC provider ID value configured in GCP.
        """
        return pulumi.get(self, "provider_id")

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> str:
        """
        The service account linked to workload identity pool while setting GCP workload identity provider.
        """
        return pulumi.get(self, "service_account_email")

    @property
    @pulumi.getter(name="workloadPoolId")
    def workload_pool_id(self) -> str:
        """
        The workload pool ID value created in GCP.
        """
        return pulumi.get(self, "workload_pool_id")


@pulumi.output_type
class GetGitConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 https: Sequence['outputs.GetGitConnectorCredentialHttpResult'],
                 sshes: Sequence['outputs.GetGitConnectorCredentialSshResult']):
        """
        :param Sequence['GetGitConnectorCredentialHttpArgs'] https: Authenticate using Username and password over http(s) for the connection.
        :param Sequence['GetGitConnectorCredentialSshArgs'] sshes: Authenticate using SSH for the connection.
        """
        pulumi.set(__self__, "https", https)
        pulumi.set(__self__, "sshes", sshes)

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetGitConnectorCredentialHttpResult']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def sshes(self) -> Sequence['outputs.GetGitConnectorCredentialSshResult']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "sshes")


@pulumi.output_type
class GetGitConnectorCredentialHttpResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetGitConnectorCredentialSshResult(dict):
    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GetGithubConnectorApiAuthenticationResult(dict):
    def __init__(__self__, *,
                 github_apps: Sequence['outputs.GetGithubConnectorApiAuthenticationGithubAppResult'],
                 token_ref: str):
        """
        :param Sequence['GetGithubConnectorApiAuthenticationGithubAppArgs'] github_apps: Configuration for using the github app for interacting with the github api.
        :param str token_ref: Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "github_apps", github_apps)
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="githubApps")
    def github_apps(self) -> Sequence['outputs.GetGithubConnectorApiAuthenticationGithubAppResult']:
        """
        Configuration for using the github app for interacting with the github api.
        """
        return pulumi.get(self, "github_apps")

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Personal access token for interacting with the github api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class GetGithubConnectorApiAuthenticationGithubAppResult(dict):
    def __init__(__self__, *,
                 application_id: str,
                 application_id_ref: str,
                 installation_id: str,
                 installation_id_ref: str,
                 private_key_ref: str):
        """
        :param str application_id: Enter the GitHub App ID from the GitHub App General tab.
        :param str application_id_ref: Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str installation_id: Enter the Installation ID located in the URL of the installed GitHub App.
        :param str installation_id_ref: Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str private_key_ref: Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "application_id_ref", application_id_ref)
        pulumi.set(__self__, "installation_id", installation_id)
        pulumi.set(__self__, "installation_id_ref", installation_id_ref)
        pulumi.set(__self__, "private_key_ref", private_key_ref)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationIdRef")
    def application_id_ref(self) -> str:
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "application_id_ref")

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> str:
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        return pulumi.get(self, "installation_id")

    @property
    @pulumi.getter(name="installationIdRef")
    def installation_id_ref(self) -> str:
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "installation_id_ref")

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> str:
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")


@pulumi.output_type
class GetGithubConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 https: Sequence['outputs.GetGithubConnectorCredentialHttpResult'],
                 sshes: Sequence['outputs.GetGithubConnectorCredentialSshResult']):
        """
        :param Sequence['GetGithubConnectorCredentialHttpArgs'] https: Authenticate using Username and password over http(s) for the connection.
        :param Sequence['GetGithubConnectorCredentialSshArgs'] sshes: Authenticate using SSH for the connection.
        """
        pulumi.set(__self__, "https", https)
        pulumi.set(__self__, "sshes", sshes)

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetGithubConnectorCredentialHttpResult']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def sshes(self) -> Sequence['outputs.GetGithubConnectorCredentialSshResult']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "sshes")


@pulumi.output_type
class GetGithubConnectorCredentialHttpResult(dict):
    def __init__(__self__, *,
                 anonymouses: Sequence['outputs.GetGithubConnectorCredentialHttpAnonymouseResult'],
                 github_apps: Sequence['outputs.GetGithubConnectorCredentialHttpGithubAppResult'],
                 token_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param Sequence['GetGithubConnectorCredentialHttpAnonymouseArgs'] anonymouses: Configuration for using the github http anonymous for interacting with the github api.
        :param Sequence['GetGithubConnectorCredentialHttpGithubAppArgs'] github_apps: Configuration for using the github app for interacting with the github api.
        :param str token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "anonymouses", anonymouses)
        pulumi.set(__self__, "github_apps", github_apps)
        pulumi.set(__self__, "token_ref", token_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter
    def anonymouses(self) -> Sequence['outputs.GetGithubConnectorCredentialHttpAnonymouseResult']:
        """
        Configuration for using the github http anonymous for interacting with the github api.
        """
        return pulumi.get(self, "anonymouses")

    @property
    @pulumi.getter(name="githubApps")
    def github_apps(self) -> Sequence['outputs.GetGithubConnectorCredentialHttpGithubAppResult']:
        """
        Configuration for using the github app for interacting with the github api.
        """
        return pulumi.get(self, "github_apps")

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetGithubConnectorCredentialHttpAnonymouseResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetGithubConnectorCredentialHttpGithubAppResult(dict):
    def __init__(__self__, *,
                 application_id: str,
                 application_id_ref: str,
                 installation_id: str,
                 installation_id_ref: str,
                 private_key_ref: str):
        """
        :param str application_id: Enter the GitHub App ID from the GitHub App General tab.
        :param str application_id_ref: Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str installation_id: Enter the Installation ID located in the URL of the installed GitHub App.
        :param str installation_id_ref: Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str private_key_ref: Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "application_id_ref", application_id_ref)
        pulumi.set(__self__, "installation_id", installation_id)
        pulumi.set(__self__, "installation_id_ref", installation_id_ref)
        pulumi.set(__self__, "private_key_ref", private_key_ref)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        """
        Enter the GitHub App ID from the GitHub App General tab.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="applicationIdRef")
    def application_id_ref(self) -> str:
        """
        Reference to the secret containing application id To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "application_id_ref")

    @property
    @pulumi.getter(name="installationId")
    def installation_id(self) -> str:
        """
        Enter the Installation ID located in the URL of the installed GitHub App.
        """
        return pulumi.get(self, "installation_id")

    @property
    @pulumi.getter(name="installationIdRef")
    def installation_id_ref(self) -> str:
        """
        Reference to the secret containing installation id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "installation_id_ref")

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> str:
        """
        Reference to the secret containing the private key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")


@pulumi.output_type
class GetGithubConnectorCredentialSshResult(dict):
    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GetGitlabConnectorApiAuthenticationResult(dict):
    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Personal access token for interacting with the gitlab api. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class GetGitlabConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 https: Sequence['outputs.GetGitlabConnectorCredentialHttpResult'],
                 sshes: Sequence['outputs.GetGitlabConnectorCredentialSshResult']):
        """
        :param Sequence['GetGitlabConnectorCredentialHttpArgs'] https: Authenticate using Username and password over http(s) for the connection.
        :param Sequence['GetGitlabConnectorCredentialSshArgs'] sshes: Authenticate using SSH for the connection.
        """
        pulumi.set(__self__, "https", https)
        pulumi.set(__self__, "sshes", sshes)

    @property
    @pulumi.getter
    def https(self) -> Sequence['outputs.GetGitlabConnectorCredentialHttpResult']:
        """
        Authenticate using Username and password over http(s) for the connection.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def sshes(self) -> Sequence['outputs.GetGitlabConnectorCredentialSshResult']:
        """
        Authenticate using SSH for the connection.
        """
        return pulumi.get(self, "sshes")


@pulumi.output_type
class GetGitlabConnectorCredentialHttpResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 token_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str token_ref: Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "token_ref", token_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference to a secret containing the personal access to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetGitlabConnectorCredentialSshResult(dict):
    def __init__(__self__, *,
                 ssh_key_ref: str):
        """
        :param str ssh_key_ref: Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "ssh_key_ref", ssh_key_ref)

    @property
    @pulumi.getter(name="sshKeyRef")
    def ssh_key_ref(self) -> str:
        """
        Reference to the Harness secret containing the ssh key. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ssh_key_ref")


@pulumi.output_type
class GetGitopsAgentDeployYamlProxyResult(dict):
    def __init__(__self__, *,
                 http: Optional[str] = None,
                 https: Optional[str] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str http: HTTP proxy settings for the GitOps agent.
        :param str https: HTTPS proxy settings for the GitOps agent.
        :param str password: Password for the proxy.
        :param str username: Username for the proxy.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def http(self) -> Optional[str]:
        """
        HTTP proxy settings for the GitOps agent.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def https(self) -> Optional[str]:
        """
        HTTPS proxy settings for the GitOps agent.
        """
        return pulumi.get(self, "https")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for the proxy.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for the proxy.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGitopsAgentMetadataResult(dict):
    def __init__(__self__, *,
                 high_availability: bool,
                 namespace: str,
                 is_namespaced: Optional[bool] = None):
        """
        :param bool high_availability: Indicates if the agent is deployed in HA mode.
        :param str namespace: The kubernetes namespace where the agent should be installed.
        :param bool is_namespaced: Indicates if the agent is namespaced.
        """
        pulumi.set(__self__, "high_availability", high_availability)
        pulumi.set(__self__, "namespace", namespace)
        if is_namespaced is not None:
            pulumi.set(__self__, "is_namespaced", is_namespaced)

    @property
    @pulumi.getter(name="highAvailability")
    def high_availability(self) -> bool:
        """
        Indicates if the agent is deployed in HA mode.
        """
        return pulumi.get(self, "high_availability")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        The kubernetes namespace where the agent should be installed.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="isNamespaced")
    def is_namespaced(self) -> Optional[bool]:
        """
        Indicates if the agent is namespaced.
        """
        return pulumi.get(self, "is_namespaced")


@pulumi.output_type
class GetGitopsApplicationsApplicationResult(dict):
    def __init__(__self__, *,
                 specs: Sequence['outputs.GetGitopsApplicationsApplicationSpecResult'],
                 metadatas: Optional[Sequence['outputs.GetGitopsApplicationsApplicationMetadataResult']] = None):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecArgs'] specs: Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        :param Sequence['GetGitopsApplicationsApplicationMetadataArgs'] metadatas: Metadata corresponding to the resources. This includes all the objects a user must create.
        """
        pulumi.set(__self__, "specs", specs)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)

    @property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecResult']:
        """
        Specifications of the GitOps application. This includes the repository URL, application definition, source, destination and sync policy.
        """
        return pulumi.get(self, "specs")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationMetadataResult']]:
        """
        Metadata corresponding to the resources. This includes all the objects a user must create.
        """
        return pulumi.get(self, "metadatas")


@pulumi.output_type
class GetGitopsApplicationsApplicationMetadataResult(dict):
    def __init__(__self__, *,
                 annotations: Mapping[str, str],
                 cluster_name: str,
                 finalizers: Sequence[str],
                 generate_name: str,
                 generation: str,
                 labels: Mapping[str, str],
                 name: str,
                 namespace: str,
                 owner_references: Sequence['outputs.GetGitopsApplicationsApplicationMetadataOwnerReferenceResult'],
                 uid: str):
        """
        :param Mapping[str, str] annotations: Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        :param str cluster_name: Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        :param Sequence[str] finalizers: Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        :param str generate_name: An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        :param str generation: A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        :param Mapping[str, str] labels: Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        :param str name: Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        :param str namespace: Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        :param Sequence['GetGitopsApplicationsApplicationMetadataOwnerReferenceArgs'] owner_references: List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        :param str uid: UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
        pulumi.set(__self__, "annotations", annotations)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "finalizers", finalizers)
        pulumi.set(__self__, "generate_name", generate_name)
        pulumi.set(__self__, "generation", generation)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "owner_references", owner_references)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def annotations(self) -> Mapping[str, str]:
        """
        Annotations are unstructured key value pairs corresponding to a resource. External tools set these to store and retrieve arbitrary metadata.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> str:
        """
        Name of the cluster corresponding to the object. API server ignores this if set in any create or update request.
        """
        return pulumi.get(self, "cluster_name")

    @property
    @pulumi.getter
    def finalizers(self) -> Sequence[str]:
        """
        Before the object is removed from the register, it must be empty. Each element serves as a unique identifier for the component that is accountable for removing that entry from the list. Entries in this list can only be removed if the object's deletionTimestamp is not null. The processing and removal of finalizers can happen in any sequence. No order is enforced as it may block the finalizers. Finalizers is a shared field that can be reordered by any actor with authority. If the finalizer list is processed in order, this could result in a scenario where the component in charge of the list's first finalizer is waiting for a signal (generated by a field value, an external system, or another) produced by a component in charge of the list's later finalizer.
        """
        return pulumi.get(self, "finalizers")

    @property
    @pulumi.getter(name="generateName")
    def generate_name(self) -> str:
        """
        An optional prefix that the server will only apply if the Name field is empty to create a unique name. The name returned to the client will differ from the name passed if this field is used. A unique suffix will be added to this value as well. The supplied value must adhere to the same validation guidelines as the Name field and may be reduced by the suffix length necessary to ensure that it is unique on the server. The server will NOT return a 409 if this field is supplied and the created name already exists; instead, it will either return 201 Created or 500 with Reason ServerTimeout, indicating that a unique name could not be found in the allotted time and the client should try again later.
        """
        return pulumi.get(self, "generate_name")

    @property
    @pulumi.getter
    def generation(self) -> str:
        """
        A sequence number representing a specific generation of the desired state. This is a read-only value populated by the system.
        """
        return pulumi.get(self, "generation")

    @property
    @pulumi.getter
    def labels(self) -> Mapping[str, str]:
        """
        Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name must be unique within a namespace. It is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Name cannot be updated.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Namespace of the GitOps application. An empty namespace is equivalent to the namespace of the GitOps agent.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="ownerReferences")
    def owner_references(self) -> Sequence['outputs.GetGitopsApplicationsApplicationMetadataOwnerReferenceResult']:
        """
        List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
        """
        return pulumi.get(self, "owner_references")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        UID is the unique identifier in time and space value for this object. It is generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetGitopsApplicationsApplicationMetadataOwnerReferenceResult(dict):
    def __init__(__self__, *,
                 api_version: str,
                 block_owner_deletion: bool,
                 controller: bool,
                 kind: str,
                 name: str,
                 uid: str):
        """
        :param str api_version: API version of the referent.
        :param bool block_owner_deletion: If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        :param bool controller: Indicates if the reference points to the managing controller.
        :param str kind: Kind of the referent.
        :param str name: Name of the referent.
        :param str uid: UID of the referent.
        """
        pulumi.set(__self__, "api_version", api_version)
        pulumi.set(__self__, "block_owner_deletion", block_owner_deletion)
        pulumi.set(__self__, "controller", controller)
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> str:
        """
        API version of the referent.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter(name="blockOwnerDeletion")
    def block_owner_deletion(self) -> bool:
        """
        If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
        """
        return pulumi.get(self, "block_owner_deletion")

    @property
    @pulumi.getter
    def controller(self) -> bool:
        """
        Indicates if the reference points to the managing controller.
        """
        return pulumi.get(self, "controller")

    @property
    @pulumi.getter
    def kind(self) -> str:
        """
        Kind of the referent.
        """
        return pulumi.get(self, "kind")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the referent.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def uid(self) -> str:
        """
        UID of the referent.
        """
        return pulumi.get(self, "uid")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecResult(dict):
    def __init__(__self__, *,
                 destinations: Sequence['outputs.GetGitopsApplicationsApplicationSpecDestinationResult'],
                 sources: Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceResult'],
                 sync_policies: Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyResult'],
                 project: Optional[str] = None,
                 source: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceResult']] = None):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecDestinationArgs'] destinations: Information about the GitOps application's destination.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceArgs'] sources: List of sources for the GitOps application. Multi Source support
        :param Sequence['GetGitopsApplicationsApplicationSpecSyncPolicyArgs'] sync_policies: Controls when a sync will be performed in response to updates in git.
        :param str project: The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceArgs'] source: Contains all information about the source of a GitOps application.
        """
        pulumi.set(__self__, "destinations", destinations)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "sync_policies", sync_policies)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if source is not None:
            pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter
    def destinations(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecDestinationResult']:
        """
        Information about the GitOps application's destination.
        """
        return pulumi.get(self, "destinations")

    @property
    @pulumi.getter
    def sources(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceResult']:
        """
        List of sources for the GitOps application. Multi Source support
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="syncPolicies")
    def sync_policies(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyResult']:
        """
        Controls when a sync will be performed in response to updates in git.
        """
        return pulumi.get(self, "sync_policies")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The ArgoCD project name corresponding to this GitOps application. Value must match mappings of ArgoCD projects to harness project.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def source(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceResult']]:
        """
        Contains all information about the source of a GitOps application.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecDestinationResult(dict):
    def __init__(__self__, *,
                 name: str,
                 namespace: str,
                 server: str):
        """
        :param str name: URL of the target cluster and must be set to the kubernetes control plane API.
        :param str namespace: Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        :param str server: URL of the target cluster server for the GitOps application.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "server", server)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        URL of the target cluster and must be set to the kubernetes control plane API.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> str:
        """
        Target namespace of the GitOps application's resources. The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def server(self) -> str:
        """
        URL of the target cluster server for the GitOps application.
        """
        return pulumi.get(self, "server")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceResult(dict):
    def __init__(__self__, *,
                 chart: str,
                 directories: Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryResult'],
                 helms: Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceHelmResult'],
                 ksonnets: Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceKsonnetResult'],
                 kustomizes: Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceKustomizeResult'],
                 path: str,
                 plugins: Sequence['outputs.GetGitopsApplicationsApplicationSpecSourcePluginResult'],
                 ref: str,
                 repo_url: str,
                 target_revision: str):
        """
        :param str chart: Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceDirectoryArgs'] directories: Options for applications of type plain YAML or Jsonnet.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceHelmArgs'] helms: Holds helm specific options.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceKsonnetArgs'] ksonnets: Ksonnet specific options.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceKustomizeArgs'] kustomizes: Options specific to a GitOps application source specific to Kustomize.
        :param str path: Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourcePluginArgs'] plugins: Options specific to config management plugins.
        :param str ref: Reference name to be used in other source spec, used for multi-source applications.
        :param str repo_url: URL to the repository (git or helm) that contains the GitOps application manifests.
        :param str target_revision: Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        """
        pulumi.set(__self__, "chart", chart)
        pulumi.set(__self__, "directories", directories)
        pulumi.set(__self__, "helms", helms)
        pulumi.set(__self__, "ksonnets", ksonnets)
        pulumi.set(__self__, "kustomizes", kustomizes)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "plugins", plugins)
        pulumi.set(__self__, "ref", ref)
        pulumi.set(__self__, "repo_url", repo_url)
        pulumi.set(__self__, "target_revision", target_revision)

    @property
    @pulumi.getter
    def chart(self) -> str:
        """
        Helm chart name, and must be specified for the GitOps applications sourced from a helm repo.
        """
        return pulumi.get(self, "chart")

    @property
    @pulumi.getter
    def directories(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryResult']:
        """
        Options for applications of type plain YAML or Jsonnet.
        """
        return pulumi.get(self, "directories")

    @property
    @pulumi.getter
    def helms(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceHelmResult']:
        """
        Holds helm specific options.
        """
        return pulumi.get(self, "helms")

    @property
    @pulumi.getter
    def ksonnets(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceKsonnetResult']:
        """
        Ksonnet specific options.
        """
        return pulumi.get(self, "ksonnets")

    @property
    @pulumi.getter
    def kustomizes(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceKustomizeResult']:
        """
        Options specific to a GitOps application source specific to Kustomize.
        """
        return pulumi.get(self, "kustomizes")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Directory path within the git repository, and is only valid for the GitOps applications sourced from git.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def plugins(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSourcePluginResult']:
        """
        Options specific to config management plugins.
        """
        return pulumi.get(self, "plugins")

    @property
    @pulumi.getter
    def ref(self) -> str:
        """
        Reference name to be used in other source spec, used for multi-source applications.
        """
        return pulumi.get(self, "ref")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> str:
        """
        URL to the repository (git or helm) that contains the GitOps application manifests.
        """
        return pulumi.get(self, "repo_url")

    @property
    @pulumi.getter(name="targetRevision")
    def target_revision(self) -> str:
        """
        Revision of the source to sync the GitOps application to. In case of git, this can be commit, tag, or branch. If omitted, will equal to HEAD. In case of Helm, this is a semver tag of the chart's version.
        """
        return pulumi.get(self, "target_revision")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceDirectoryResult(dict):
    def __init__(__self__, *,
                 exclude: Optional[str] = None,
                 include: Optional[str] = None,
                 jsonnets: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetResult']] = None,
                 recurse: Optional[bool] = None):
        """
        :param str exclude: Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        :param str include: Glob pattern to match paths against that should be explicitly included during manifest generation.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetArgs'] jsonnets: Options specific to applications of type Jsonnet.
        :param bool recurse: Indicates to scan a directory recursively for manifests.
        """
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if jsonnets is not None:
            pulumi.set(__self__, "jsonnets", jsonnets)
        if recurse is not None:
            pulumi.set(__self__, "recurse", recurse)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[str]:
        """
        Glob pattern to match paths against that should be explicitly excluded from being used during manifest generation.
        """
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter
    def include(self) -> Optional[str]:
        """
        Glob pattern to match paths against that should be explicitly included during manifest generation.
        """
        return pulumi.get(self, "include")

    @property
    @pulumi.getter
    def jsonnets(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetResult']]:
        """
        Options specific to applications of type Jsonnet.
        """
        return pulumi.get(self, "jsonnets")

    @property
    @pulumi.getter
    def recurse(self) -> Optional[bool]:
        """
        Indicates to scan a directory recursively for manifests.
        """
        return pulumi.get(self, "recurse")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetResult(dict):
    def __init__(__self__, *,
                 ext_vars: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarResult']] = None,
                 libs: Optional[Sequence[str]] = None,
                 tlas: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaResult']] = None):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarArgs'] ext_vars: List of jsonnet external variables.
        :param Sequence[str] libs: Additional library search dirs.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaArgs'] tlas: List of jsonnet top-level arguments(TLAS).
        """
        if ext_vars is not None:
            pulumi.set(__self__, "ext_vars", ext_vars)
        if libs is not None:
            pulumi.set(__self__, "libs", libs)
        if tlas is not None:
            pulumi.set(__self__, "tlas", tlas)

    @property
    @pulumi.getter(name="extVars")
    def ext_vars(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarResult']]:
        """
        List of jsonnet external variables.
        """
        return pulumi.get(self, "ext_vars")

    @property
    @pulumi.getter
    def libs(self) -> Optional[Sequence[str]]:
        """
        Additional library search dirs.
        """
        return pulumi.get(self, "libs")

    @property
    @pulumi.getter
    def tlas(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaResult']]:
        """
        List of jsonnet top-level arguments(TLAS).
        """
        return pulumi.get(self, "tlas")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetExtVarResult(dict):
    def __init__(__self__, *,
                 code: Optional[bool] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool code: Code of the external variables of jsonnet application.
        :param str name: Name of the external variables of jsonnet application.
        :param str value: Value of the external variables of jsonnet application.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[bool]:
        """
        Code of the external variables of jsonnet application.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the external variables of jsonnet application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the external variables of jsonnet application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceDirectoryJsonnetTlaResult(dict):
    def __init__(__self__, *,
                 code: Optional[bool] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool code: Code of the TLAS of the jsonnet application.
        :param str name: Name of the TLAS of the jsonnet application.
        :param str value: Value of the TLAS of the jsonnet application.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def code(self) -> Optional[bool]:
        """
        Code of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the TLAS of the jsonnet application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceHelmResult(dict):
    def __init__(__self__, *,
                 file_parameters: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceHelmFileParameterResult']] = None,
                 parameters: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceHelmParameterResult']] = None,
                 pass_credentials: Optional[bool] = None,
                 release_name: Optional[str] = None,
                 value_files: Optional[Sequence[str]] = None,
                 values: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceHelmFileParameterArgs'] file_parameters: File parameters to the helm template.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceHelmParameterArgs'] parameters: List of helm parameters which are passed to the helm template command upon manifest generation.
        :param bool pass_credentials: Indicates if to pass credentials to all domains (helm's --pass-credentials)
        :param str release_name: Helm release name to use. If omitted it will use the GitOps application name.
        :param Sequence[str] value_files: List of helm value files to use when generating a template.
        :param str values: Helm values to be passed to helm template, typically defined as a block.
        :param str version: Helm version to use for templating (either "2" or "3")
        """
        if file_parameters is not None:
            pulumi.set(__self__, "file_parameters", file_parameters)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if pass_credentials is not None:
            pulumi.set(__self__, "pass_credentials", pass_credentials)
        if release_name is not None:
            pulumi.set(__self__, "release_name", release_name)
        if value_files is not None:
            pulumi.set(__self__, "value_files", value_files)
        if values is not None:
            pulumi.set(__self__, "values", values)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="fileParameters")
    def file_parameters(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceHelmFileParameterResult']]:
        """
        File parameters to the helm template.
        """
        return pulumi.get(self, "file_parameters")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceHelmParameterResult']]:
        """
        List of helm parameters which are passed to the helm template command upon manifest generation.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter(name="passCredentials")
    def pass_credentials(self) -> Optional[bool]:
        """
        Indicates if to pass credentials to all domains (helm's --pass-credentials)
        """
        return pulumi.get(self, "pass_credentials")

    @property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> Optional[str]:
        """
        Helm release name to use. If omitted it will use the GitOps application name.
        """
        return pulumi.get(self, "release_name")

    @property
    @pulumi.getter(name="valueFiles")
    def value_files(self) -> Optional[Sequence[str]]:
        """
        List of helm value files to use when generating a template.
        """
        return pulumi.get(self, "value_files")

    @property
    @pulumi.getter
    def values(self) -> Optional[str]:
        """
        Helm values to be passed to helm template, typically defined as a block.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Helm version to use for templating (either "2" or "3")
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceHelmFileParameterResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 path: Optional[str] = None):
        """
        :param str name: Name of the helm parameter.
        :param str path: Path to the file containing the values of the helm parameter.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the helm parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to the file containing the values of the helm parameter.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceHelmParameterResult(dict):
    def __init__(__self__, *,
                 force_string: Optional[bool] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param bool force_string: Indicates if helm should interpret booleans and numbers as strings.
        :param str name: Name of the helm parameter.
        :param str value: Value of the Helm parameter.
        """
        if force_string is not None:
            pulumi.set(__self__, "force_string", force_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="forceString")
    def force_string(self) -> Optional[bool]:
        """
        Indicates if helm should interpret booleans and numbers as strings.
        """
        return pulumi.get(self, "force_string")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the helm parameter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the Helm parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceKsonnetResult(dict):
    def __init__(__self__, *,
                 environment: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceKsonnetParameterResult']] = None):
        """
        :param str environment: Ksonnet application environment name.
        :param Sequence['GetGitopsApplicationsApplicationSpecSourceKsonnetParameterArgs'] parameters: List of ksonnet component parameter override values.
        """
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def environment(self) -> Optional[str]:
        """
        Ksonnet application environment name.
        """
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourceKsonnetParameterResult']]:
        """
        List of ksonnet component parameter override values.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceKsonnetParameterResult(dict):
    def __init__(__self__, *,
                 component: Optional[str] = None,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str component: Component of the parameter of the ksonnet application.
        :param str name: Name of the parameter of the ksonnet application.
        :param str value: Value of the parameter of the ksonnet application.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def component(self) -> Optional[str]:
        """
        Component of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "component")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the parameter of the ksonnet application.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourceKustomizeResult(dict):
    def __init__(__self__, *,
                 common_annotations: Optional[Mapping[str, str]] = None,
                 common_labels: Optional[Mapping[str, str]] = None,
                 force_common_annotations: Optional[bool] = None,
                 force_common_labels: Optional[bool] = None,
                 images: Optional[Sequence[str]] = None,
                 name_prefix: Optional[str] = None,
                 name_suffix: Optional[str] = None,
                 version: Optional[str] = None):
        """
        :param Mapping[str, str] common_annotations: List of additional annotations to add to rendered manifests.
        :param Mapping[str, str] common_labels: List of additional labels to add to rendered manifests.
        :param bool force_common_annotations: Indicates if to force applying common annotations to resources for kustomize apps.
        :param bool force_common_labels: Indicates if to force apply common labels to resources for kustomize apps.
        :param Sequence[str] images: List of kustomize image override specifications.
        :param str name_prefix: Prefix prepended to resources for kustomize apps.
        :param str name_suffix: Suffix appended to resources for kustomize apps.
        :param str version: Version of kustomize to use for rendering manifests.
        """
        if common_annotations is not None:
            pulumi.set(__self__, "common_annotations", common_annotations)
        if common_labels is not None:
            pulumi.set(__self__, "common_labels", common_labels)
        if force_common_annotations is not None:
            pulumi.set(__self__, "force_common_annotations", force_common_annotations)
        if force_common_labels is not None:
            pulumi.set(__self__, "force_common_labels", force_common_labels)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if name_prefix is not None:
            pulumi.set(__self__, "name_prefix", name_prefix)
        if name_suffix is not None:
            pulumi.set(__self__, "name_suffix", name_suffix)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="commonAnnotations")
    def common_annotations(self) -> Optional[Mapping[str, str]]:
        """
        List of additional annotations to add to rendered manifests.
        """
        return pulumi.get(self, "common_annotations")

    @property
    @pulumi.getter(name="commonLabels")
    def common_labels(self) -> Optional[Mapping[str, str]]:
        """
        List of additional labels to add to rendered manifests.
        """
        return pulumi.get(self, "common_labels")

    @property
    @pulumi.getter(name="forceCommonAnnotations")
    def force_common_annotations(self) -> Optional[bool]:
        """
        Indicates if to force applying common annotations to resources for kustomize apps.
        """
        return pulumi.get(self, "force_common_annotations")

    @property
    @pulumi.getter(name="forceCommonLabels")
    def force_common_labels(self) -> Optional[bool]:
        """
        Indicates if to force apply common labels to resources for kustomize apps.
        """
        return pulumi.get(self, "force_common_labels")

    @property
    @pulumi.getter
    def images(self) -> Optional[Sequence[str]]:
        """
        List of kustomize image override specifications.
        """
        return pulumi.get(self, "images")

    @property
    @pulumi.getter(name="namePrefix")
    def name_prefix(self) -> Optional[str]:
        """
        Prefix prepended to resources for kustomize apps.
        """
        return pulumi.get(self, "name_prefix")

    @property
    @pulumi.getter(name="nameSuffix")
    def name_suffix(self) -> Optional[str]:
        """
        Suffix appended to resources for kustomize apps.
        """
        return pulumi.get(self, "name_suffix")

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        """
        Version of kustomize to use for rendering manifests.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourcePluginResult(dict):
    def __init__(__self__, *,
                 envs: Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourcePluginEnvResult']] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecSourcePluginEnvArgs'] envs: Entry in the GitOps application's environment.
        :param str name: Name of the plugin.
        """
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetGitopsApplicationsApplicationSpecSourcePluginEnvResult']]:
        """
        Entry in the GitOps application's environment.
        """
        return pulumi.get(self, "envs")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the plugin.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSourcePluginEnvResult(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name of the variable, usually expressed in uppercase.
        :param str value: Value of the variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the variable, usually expressed in uppercase.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSyncPolicyResult(dict):
    def __init__(__self__, *,
                 automateds: Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedResult'],
                 retries: Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyRetryResult'],
                 sync_options: Sequence[str]):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedArgs'] automateds: Controls the behavior of an automated sync.
        :param Sequence['GetGitopsApplicationsApplicationSpecSyncPolicyRetryArgs'] retries: Contains information about the strategy to apply when a sync failed.
        :param Sequence[str] sync_options: Options allow you to specify whole app sync-options.
        """
        pulumi.set(__self__, "automateds", automateds)
        pulumi.set(__self__, "retries", retries)
        pulumi.set(__self__, "sync_options", sync_options)

    @property
    @pulumi.getter
    def automateds(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedResult']:
        """
        Controls the behavior of an automated sync.
        """
        return pulumi.get(self, "automateds")

    @property
    @pulumi.getter
    def retries(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyRetryResult']:
        """
        Contains information about the strategy to apply when a sync failed.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter(name="syncOptions")
    def sync_options(self) -> Sequence[str]:
        """
        Options allow you to specify whole app sync-options.
        """
        return pulumi.get(self, "sync_options")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSyncPolicyAutomatedResult(dict):
    def __init__(__self__, *,
                 allow_empty: bool,
                 prune: bool,
                 self_heal: bool):
        """
        :param bool allow_empty: Indicates to allows apps to have zero live resources (default: false).
        :param bool prune: Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        :param bool self_heal: Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
        pulumi.set(__self__, "allow_empty", allow_empty)
        pulumi.set(__self__, "prune", prune)
        pulumi.set(__self__, "self_heal", self_heal)

    @property
    @pulumi.getter(name="allowEmpty")
    def allow_empty(self) -> bool:
        """
        Indicates to allows apps to have zero live resources (default: false).
        """
        return pulumi.get(self, "allow_empty")

    @property
    @pulumi.getter
    def prune(self) -> bool:
        """
        Indicates whether to delete resources from the cluster that are not found in the sources anymore as part of automated sync (default: false).
        """
        return pulumi.get(self, "prune")

    @property
    @pulumi.getter(name="selfHeal")
    def self_heal(self) -> bool:
        """
        Indicates whether to revert resources back to their desired state upon modification in the cluster (default: false).
        """
        return pulumi.get(self, "self_heal")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSyncPolicyRetryResult(dict):
    def __init__(__self__, *,
                 backoffs: Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffResult'],
                 limit: str):
        """
        :param Sequence['GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffArgs'] backoffs: Backoff strategy to use on subsequent retries for failing syncs.
        :param str limit: Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
        pulumi.set(__self__, "backoffs", backoffs)
        pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def backoffs(self) -> Sequence['outputs.GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffResult']:
        """
        Backoff strategy to use on subsequent retries for failing syncs.
        """
        return pulumi.get(self, "backoffs")

    @property
    @pulumi.getter
    def limit(self) -> str:
        """
        Limit is the maximum number of attempts for retrying a failed sync. If set to 0, no retries will be performed.
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class GetGitopsApplicationsApplicationSpecSyncPolicyRetryBackoffResult(dict):
    def __init__(__self__, *,
                 duration: str,
                 factor: str,
                 max_duration: str):
        """
        :param str duration: Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        :param str factor: Factor to multiply the base duration after each failed retry.
        :param str max_duration: Maximum amount of time allowed of the backoff strategy.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "factor", factor)
        pulumi.set(__self__, "max_duration", max_duration)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        Amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h").
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def factor(self) -> str:
        """
        Factor to multiply the base duration after each failed retry.
        """
        return pulumi.get(self, "factor")

    @property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> str:
        """
        Maximum amount of time allowed of the backoff strategy.
        """
        return pulumi.get(self, "max_duration")


@pulumi.output_type
class GetGitopsClusterRequestResult(dict):
    def __init__(__self__, *,
                 tags: Sequence[str],
                 clusters: Optional[Sequence['outputs.GetGitopsClusterRequestClusterResult']] = None,
                 updated_fields: Optional[Sequence[str]] = None,
                 upsert: Optional[bool] = None):
        """
        :param Sequence[str] tags: Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        :param Sequence['GetGitopsClusterRequestClusterArgs'] clusters: GitOps cluster details.
        :param Sequence[str] updated_fields: Fields which are updated.
        :param bool upsert: Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
        pulumi.set(__self__, "tags", tags)
        if clusters is not None:
            pulumi.set(__self__, "clusters", clusters)
        if updated_fields is not None:
            pulumi.set(__self__, "updated_fields", updated_fields)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Tags for the GitOps cluster. These can be used to search or filter the GitOps agents.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def clusters(self) -> Optional[Sequence['outputs.GetGitopsClusterRequestClusterResult']]:
        """
        GitOps cluster details.
        """
        return pulumi.get(self, "clusters")

    @property
    @pulumi.getter(name="updatedFields")
    def updated_fields(self) -> Optional[Sequence[str]]:
        """
        Fields which are updated.
        """
        return pulumi.get(self, "updated_fields")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        Indicates if the GitOps cluster should be updated if existing and inserted if not.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class GetGitopsClusterRequestClusterResult(dict):
    def __init__(__self__, *,
                 infos: Sequence['outputs.GetGitopsClusterRequestClusterInfoResult'],
                 annotations: Optional[Mapping[str, str]] = None,
                 cluster_resources: Optional[bool] = None,
                 configs: Optional[Sequence['outputs.GetGitopsClusterRequestClusterConfigResult']] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 namespaces: Optional[Sequence[str]] = None,
                 project: Optional[str] = None,
                 refresh_requested_ats: Optional[Sequence['outputs.GetGitopsClusterRequestClusterRefreshRequestedAtResult']] = None,
                 server: Optional[str] = None,
                 shard: Optional[str] = None):
        """
        :param Sequence['GetGitopsClusterRequestClusterInfoArgs'] infos: Information about cluster cache and state.
        :param Mapping[str, str] annotations: Annotations for cluster secret metadata.
        :param bool cluster_resources: Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        :param Sequence['GetGitopsClusterRequestClusterConfigArgs'] configs: GitOps cluster config.
        :param Mapping[str, str] labels: Labels for cluster secret metadata.
        :param str name: Name of the cluster. If omitted, the server address will be used.
        :param Sequence[str] namespaces: List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        :param str project: The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        :param Sequence['GetGitopsClusterRequestClusterRefreshRequestedAtArgs'] refresh_requested_ats: Time when cluster cache refresh has been requested.
        :param str server: API server URL of the kubernetes cluster.
        :param str shard: Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
        pulumi.set(__self__, "infos", infos)
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if cluster_resources is not None:
            pulumi.set(__self__, "cluster_resources", cluster_resources)
        if configs is not None:
            pulumi.set(__self__, "configs", configs)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespaces is not None:
            pulumi.set(__self__, "namespaces", namespaces)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if refresh_requested_ats is not None:
            pulumi.set(__self__, "refresh_requested_ats", refresh_requested_ats)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if shard is not None:
            pulumi.set(__self__, "shard", shard)

    @property
    @pulumi.getter
    def infos(self) -> Sequence['outputs.GetGitopsClusterRequestClusterInfoResult']:
        """
        Information about cluster cache and state.
        """
        return pulumi.get(self, "infos")

    @property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, str]]:
        """
        Annotations for cluster secret metadata.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter(name="clusterResources")
    def cluster_resources(self) -> Optional[bool]:
        """
        Indicates if cluster level resources should be managed. This setting is used only if cluster is connected in a namespaced mode.
        """
        return pulumi.get(self, "cluster_resources")

    @property
    @pulumi.getter
    def configs(self) -> Optional[Sequence['outputs.GetGitopsClusterRequestClusterConfigResult']]:
        """
        GitOps cluster config.
        """
        return pulumi.get(self, "configs")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        Labels for cluster secret metadata.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the cluster. If omitted, the server address will be used.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespaces(self) -> Optional[Sequence[str]]:
        """
        List of namespaces which are accessible in that cluster. Cluster level resources will be ignored if namespace list is not empty.
        """
        return pulumi.get(self, "namespaces")

    @property
    @pulumi.getter
    def project(self) -> Optional[str]:
        """
        The ArgoCD project name corresponding to this GitOps cluster. An empty string means that the GitOps cluster belongs to the default project created by Harness.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter(name="refreshRequestedAts")
    def refresh_requested_ats(self) -> Optional[Sequence['outputs.GetGitopsClusterRequestClusterRefreshRequestedAtResult']]:
        """
        Time when cluster cache refresh has been requested.
        """
        return pulumi.get(self, "refresh_requested_ats")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        API server URL of the kubernetes cluster.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def shard(self) -> Optional[str]:
        """
        Shard number to be managed by a specific application controller pod. Calculated on the fly by the application controller if not specified.
        """
        return pulumi.get(self, "shard")


@pulumi.output_type
class GetGitopsClusterRequestClusterConfigResult(dict):
    def __init__(__self__, *,
                 aws_cluster_name: Optional[str] = None,
                 bearer_token: Optional[str] = None,
                 cluster_connection_type: Optional[str] = None,
                 disable_compression: Optional[bool] = None,
                 exec_provider_configs: Optional[Sequence['outputs.GetGitopsClusterRequestClusterConfigExecProviderConfigResult']] = None,
                 password: Optional[str] = None,
                 proxy_url: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 tls_client_configs: Optional[Sequence['outputs.GetGitopsClusterRequestClusterConfigTlsClientConfigResult']] = None,
                 username: Optional[str] = None):
        """
        :param str aws_cluster_name: AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        :param str bearer_token: Bearer authentication token the cluster.
        :param str cluster_connection_type: Identifies the authentication method used to connect to the cluster.
        :param bool disable_compression: DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        :param Sequence['GetGitopsClusterRequestClusterConfigExecProviderConfigArgs'] exec_provider_configs: Configuration for an exec provider.
        :param str password: Password of the server of the cluster.
        :param str proxy_url: The URL to the proxy to be used for all requests send to the cluster's API server
        :param str role_arn: Optional role ARN. If set then used for AWS IAM Authenticator.
        :param Sequence['GetGitopsClusterRequestClusterConfigTlsClientConfigArgs'] tls_client_configs: Settings to enable transport layer security.
        :param str username: Username of the server of the cluster.
        """
        if aws_cluster_name is not None:
            pulumi.set(__self__, "aws_cluster_name", aws_cluster_name)
        if bearer_token is not None:
            pulumi.set(__self__, "bearer_token", bearer_token)
        if cluster_connection_type is not None:
            pulumi.set(__self__, "cluster_connection_type", cluster_connection_type)
        if disable_compression is not None:
            pulumi.set(__self__, "disable_compression", disable_compression)
        if exec_provider_configs is not None:
            pulumi.set(__self__, "exec_provider_configs", exec_provider_configs)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if proxy_url is not None:
            pulumi.set(__self__, "proxy_url", proxy_url)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if tls_client_configs is not None:
            pulumi.set(__self__, "tls_client_configs", tls_client_configs)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="awsClusterName")
    def aws_cluster_name(self) -> Optional[str]:
        """
        AWS Cluster name. If set then AWS CLI EKS token command will be used to access cluster.
        """
        return pulumi.get(self, "aws_cluster_name")

    @property
    @pulumi.getter(name="bearerToken")
    def bearer_token(self) -> Optional[str]:
        """
        Bearer authentication token the cluster.
        """
        return pulumi.get(self, "bearer_token")

    @property
    @pulumi.getter(name="clusterConnectionType")
    def cluster_connection_type(self) -> Optional[str]:
        """
        Identifies the authentication method used to connect to the cluster.
        """
        return pulumi.get(self, "cluster_connection_type")

    @property
    @pulumi.getter(name="disableCompression")
    def disable_compression(self) -> Optional[bool]:
        """
        DisableCompression bypasses automatic GZip compression requests to to the cluster's API server. Corresponds to running kubectl with --disable-compression
        """
        return pulumi.get(self, "disable_compression")

    @property
    @pulumi.getter(name="execProviderConfigs")
    def exec_provider_configs(self) -> Optional[Sequence['outputs.GetGitopsClusterRequestClusterConfigExecProviderConfigResult']]:
        """
        Configuration for an exec provider.
        """
        return pulumi.get(self, "exec_provider_configs")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password of the server of the cluster.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="proxyUrl")
    def proxy_url(self) -> Optional[str]:
        """
        The URL to the proxy to be used for all requests send to the cluster's API server
        """
        return pulumi.get(self, "proxy_url")

    @property
    @pulumi.getter(name="roleARN")
    def role_arn(self) -> Optional[str]:
        """
        Optional role ARN. If set then used for AWS IAM Authenticator.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="tlsClientConfigs")
    def tls_client_configs(self) -> Optional[Sequence['outputs.GetGitopsClusterRequestClusterConfigTlsClientConfigResult']]:
        """
        Settings to enable transport layer security.
        """
        return pulumi.get(self, "tls_client_configs")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username of the server of the cluster.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGitopsClusterRequestClusterConfigExecProviderConfigResult(dict):
    def __init__(__self__, *,
                 api_version: Optional[str] = None,
                 args: Optional[Sequence[str]] = None,
                 command: Optional[str] = None,
                 env: Optional[Mapping[str, str]] = None,
                 install_hint: Optional[str] = None):
        """
        :param str api_version: Preferred input version of the ExecInfo.
        :param Sequence[str] args: Arguments to pass to the command when executing it.
        :param str command: Command to execute.
        :param Mapping[str, str] env: Additional environment variables to expose to the process.
        :param str install_hint: Message displayed when the executable is not found.
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", api_version)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if install_hint is not None:
            pulumi.set(__self__, "install_hint", install_hint)

    @property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[str]:
        """
        Preferred input version of the ExecInfo.
        """
        return pulumi.get(self, "api_version")

    @property
    @pulumi.getter
    def args(self) -> Optional[Sequence[str]]:
        """
        Arguments to pass to the command when executing it.
        """
        return pulumi.get(self, "args")

    @property
    @pulumi.getter
    def command(self) -> Optional[str]:
        """
        Command to execute.
        """
        return pulumi.get(self, "command")

    @property
    @pulumi.getter
    def env(self) -> Optional[Mapping[str, str]]:
        """
        Additional environment variables to expose to the process.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="installHint")
    def install_hint(self) -> Optional[str]:
        """
        Message displayed when the executable is not found.
        """
        return pulumi.get(self, "install_hint")


@pulumi.output_type
class GetGitopsClusterRequestClusterConfigTlsClientConfigResult(dict):
    def __init__(__self__, *,
                 ca_data: Optional[str] = None,
                 cert_data: Optional[str] = None,
                 insecure: Optional[bool] = None,
                 key_data: Optional[str] = None,
                 server_name: Optional[str] = None):
        """
        :param str ca_data: CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        :param str cert_data: Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        :param bool insecure: Indicates if the TLS connection to the cluster should be insecure.
        :param str key_data: Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        :param str server_name: Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
        if ca_data is not None:
            pulumi.set(__self__, "ca_data", ca_data)
        if cert_data is not None:
            pulumi.set(__self__, "cert_data", cert_data)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if server_name is not None:
            pulumi.set(__self__, "server_name", server_name)

    @property
    @pulumi.getter(name="caData")
    def ca_data(self) -> Optional[str]:
        """
        CA data holds PEM-encoded bytes (typically read from a root certificates bundle). Use this if you are using self-signed certificates. CAData takes precedence over CAFile. The value should be base64 encoded.
        """
        return pulumi.get(self, "ca_data")

    @property
    @pulumi.getter(name="certData")
    def cert_data(self) -> Optional[str]:
        """
        Certificate data holds PEM-encoded bytes (typically read from a client certificate file). CertData takes precedence over CertFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "cert_data")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Indicates if the TLS connection to the cluster should be insecure.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[str]:
        """
        Key data holds PEM-encoded bytes (typically read from a client certificate key file). KeyData takes precedence over KeyFile. Use this if you are using mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "key_data")

    @property
    @pulumi.getter(name="serverName")
    def server_name(self) -> Optional[str]:
        """
        Server name for SNI in the client to check server certificates against. If ServerName is empty, the hostname used to contact the server is used.
        """
        return pulumi.get(self, "server_name")


@pulumi.output_type
class GetGitopsClusterRequestClusterInfoResult(dict):
    def __init__(__self__, *,
                 cache_infos: Sequence['outputs.GetGitopsClusterRequestClusterInfoCacheInfoResult'],
                 connection_states: Sequence['outputs.GetGitopsClusterRequestClusterInfoConnectionStateResult'],
                 server_version: str,
                 api_versions: Optional[Sequence[str]] = None,
                 applications_count: Optional[str] = None):
        """
        :param Sequence['GetGitopsClusterRequestClusterInfoCacheInfoArgs'] cache_infos: Information about the cluster cache.
        :param Sequence['GetGitopsClusterRequestClusterInfoConnectionStateArgs'] connection_states: Information about the connection to the cluster.
        :param str server_version: Kubernetes version of the cluster.
        :param Sequence[str] api_versions: List of API versions supported by the cluster.
        :param str applications_count: Number of applications managed by Argo CD on the cluster.
        """
        pulumi.set(__self__, "cache_infos", cache_infos)
        pulumi.set(__self__, "connection_states", connection_states)
        pulumi.set(__self__, "server_version", server_version)
        if api_versions is not None:
            pulumi.set(__self__, "api_versions", api_versions)
        if applications_count is not None:
            pulumi.set(__self__, "applications_count", applications_count)

    @property
    @pulumi.getter(name="cacheInfos")
    def cache_infos(self) -> Sequence['outputs.GetGitopsClusterRequestClusterInfoCacheInfoResult']:
        """
        Information about the cluster cache.
        """
        return pulumi.get(self, "cache_infos")

    @property
    @pulumi.getter(name="connectionStates")
    def connection_states(self) -> Sequence['outputs.GetGitopsClusterRequestClusterInfoConnectionStateResult']:
        """
        Information about the connection to the cluster.
        """
        return pulumi.get(self, "connection_states")

    @property
    @pulumi.getter(name="serverVersion")
    def server_version(self) -> str:
        """
        Kubernetes version of the cluster.
        """
        return pulumi.get(self, "server_version")

    @property
    @pulumi.getter(name="apiVersions")
    def api_versions(self) -> Optional[Sequence[str]]:
        """
        List of API versions supported by the cluster.
        """
        return pulumi.get(self, "api_versions")

    @property
    @pulumi.getter(name="applicationsCount")
    def applications_count(self) -> Optional[str]:
        """
        Number of applications managed by Argo CD on the cluster.
        """
        return pulumi.get(self, "applications_count")


@pulumi.output_type
class GetGitopsClusterRequestClusterInfoCacheInfoResult(dict):
    def __init__(__self__, *,
                 apis_count: Optional[str] = None,
                 last_cache_sync_time: Optional[str] = None,
                 resources_count: Optional[str] = None):
        """
        :param str apis_count: Number of observed kubernetes API count.
        :param str last_cache_sync_time: Time of most recent cache synchronization.
        :param str resources_count: Number of observed kubernetes resources.
        """
        if apis_count is not None:
            pulumi.set(__self__, "apis_count", apis_count)
        if last_cache_sync_time is not None:
            pulumi.set(__self__, "last_cache_sync_time", last_cache_sync_time)
        if resources_count is not None:
            pulumi.set(__self__, "resources_count", resources_count)

    @property
    @pulumi.getter(name="apisCount")
    def apis_count(self) -> Optional[str]:
        """
        Number of observed kubernetes API count.
        """
        return pulumi.get(self, "apis_count")

    @property
    @pulumi.getter(name="lastCacheSyncTime")
    def last_cache_sync_time(self) -> Optional[str]:
        """
        Time of most recent cache synchronization.
        """
        return pulumi.get(self, "last_cache_sync_time")

    @property
    @pulumi.getter(name="resourcesCount")
    def resources_count(self) -> Optional[str]:
        """
        Number of observed kubernetes resources.
        """
        return pulumi.get(self, "resources_count")


@pulumi.output_type
class GetGitopsClusterRequestClusterInfoConnectionStateResult(dict):
    def __init__(__self__, *,
                 message: str,
                 status: str,
                 attempted_ats: Optional[Sequence['outputs.GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtResult']] = None):
        """
        :param str message: Information about the connection status.
        :param str status: Current status indicator of the connection.
        :param Sequence['GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtArgs'] attempted_ats: Time when cluster cache refresh has been requested.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "status", status)
        if attempted_ats is not None:
            pulumi.set(__self__, "attempted_ats", attempted_ats)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Information about the connection status.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Current status indicator of the connection.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="attemptedAts")
    def attempted_ats(self) -> Optional[Sequence['outputs.GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtResult']]:
        """
        Time when cluster cache refresh has been requested.
        """
        return pulumi.get(self, "attempted_ats")


@pulumi.output_type
class GetGitopsClusterRequestClusterInfoConnectionStateAttemptedAtResult(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        :param str seconds: Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetGitopsClusterRequestClusterRefreshRequestedAtResult(dict):
    def __init__(__self__, *,
                 nanos: Optional[int] = None,
                 seconds: Optional[str] = None):
        """
        :param int nanos: Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        :param str seconds: Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[int]:
        """
        Non-negative fractions of a second at nanosecond resolution. Negative second values with fractions must still have non-negative nanos values that count forward in time. Must be from 0 to 999,999,999 inclusive. This field may be limited in precision depending on context.
        """
        return pulumi.get(self, "nanos")

    @property
    @pulumi.getter
    def seconds(self) -> Optional[str]:
        """
        Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
        """
        return pulumi.get(self, "seconds")


@pulumi.output_type
class GetGitopsGnupgRequestResult(dict):
    def __init__(__self__, *,
                 publickeys: Optional[Sequence['outputs.GetGitopsGnupgRequestPublickeyResult']] = None,
                 upsert: Optional[bool] = None):
        """
        :param Sequence['GetGitopsGnupgRequestPublickeyArgs'] publickeys: Public key details.
        :param bool upsert: Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        if publickeys is not None:
            pulumi.set(__self__, "publickeys", publickeys)
        if upsert is not None:
            pulumi.set(__self__, "upsert", upsert)

    @property
    @pulumi.getter
    def publickeys(self) -> Optional[Sequence['outputs.GetGitopsGnupgRequestPublickeyResult']]:
        """
        Public key details.
        """
        return pulumi.get(self, "publickeys")

    @property
    @pulumi.getter
    def upsert(self) -> Optional[bool]:
        """
        Indicates if the GnuPG Key should be inserted if not present or updated if present.
        """
        return pulumi.get(self, "upsert")


@pulumi.output_type
class GetGitopsGnupgRequestPublickeyResult(dict):
    def __init__(__self__, *,
                 fingerprint: Optional[str] = None,
                 key_data: Optional[str] = None,
                 key_id: Optional[str] = None,
                 owner: Optional[str] = None,
                 sub_type: Optional[str] = None,
                 trust: Optional[str] = None):
        """
        :param str fingerprint: Fingerprint is the fingerprint of the key
        :param str key_data: KeyData holds the raw key data, in base64 encoded format.
        :param str key_id: KeyID specifies the key ID, in hexadecimal string format.
        :param str owner: Owner holds the owner identification, e.g. a name and e-mail address
        :param str sub_type: SubType holds the key's sub type
        :param str trust: Trust holds the level of trust assigned to this key
        """
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if key_data is not None:
            pulumi.set(__self__, "key_data", key_data)
        if key_id is not None:
            pulumi.set(__self__, "key_id", key_id)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)
        if trust is not None:
            pulumi.set(__self__, "trust", trust)

    @property
    @pulumi.getter
    def fingerprint(self) -> Optional[str]:
        """
        Fingerprint is the fingerprint of the key
        """
        return pulumi.get(self, "fingerprint")

    @property
    @pulumi.getter(name="keyData")
    def key_data(self) -> Optional[str]:
        """
        KeyData holds the raw key data, in base64 encoded format.
        """
        return pulumi.get(self, "key_data")

    @property
    @pulumi.getter(name="keyId")
    def key_id(self) -> Optional[str]:
        """
        KeyID specifies the key ID, in hexadecimal string format.
        """
        return pulumi.get(self, "key_id")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner holds the owner identification, e.g. a name and e-mail address
        """
        return pulumi.get(self, "owner")

    @property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[str]:
        """
        SubType holds the key's sub type
        """
        return pulumi.get(self, "sub_type")

    @property
    @pulumi.getter
    def trust(self) -> Optional[str]:
        """
        Trust holds the level of trust assigned to this key
        """
        return pulumi.get(self, "trust")


@pulumi.output_type
class GetGitopsRepoCredCredResult(dict):
    def __init__(__self__, *,
                 enable_oci: bool,
                 github_app_enterprise_base_url: str,
                 github_app_id: str,
                 github_app_installation_id: str,
                 github_app_private_key: str,
                 password: str,
                 ssh_private_key: str,
                 tls_client_cert_data: str,
                 tls_client_cert_key: str,
                 type: str,
                 url: str,
                 username: str):
        """
        :param bool enable_oci: Specifies whether helm-oci support should be enabled for this repo.
        :param str github_app_enterprise_base_url: Specifies the GitHub API URL for GitHub app authentication.
        :param str github_app_id: Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        :param str github_app_installation_id: Specifies the ID of the installed GitHub App for GitHub app authentication.
        :param str github_app_private_key: github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        :param str password: Password or PAT to be used for authenticating the remote repository.
        :param str ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param str tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        :param str tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        :param str type: Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        :param str url: URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        :param str username: Username to be used for authenticating the remote repository.
        """
        pulumi.set(__self__, "enable_oci", enable_oci)
        pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        pulumi.set(__self__, "github_app_id", github_app_id)
        pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> bool:
        """
        Specifies whether helm-oci support should be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> str:
        """
        Specifies the GitHub API URL for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> str:
        """
        Specifies the Github App ID of the app used to access the repo for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_id")

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> str:
        """
        Specifies the ID of the installed GitHub App for GitHub app authentication.
        """
        return pulumi.get(self, "github_app_installation_id")

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> str:
        """
        github*app*private_key specifies the private key PEM data for authentication via GitHub app.
        """
        return pulumi.get(self, "github_app_private_key")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> str:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> str:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> str:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type specifies the type of the repoCreds.Can be either 'git' or 'helm. 'git' is assumed if empty or absent
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the remote repository. Make sure you pass at least an org, this will not work if you just provide the host, for eg. "https://github.com"
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetGitopsRepositoryRepoResult(dict):
    def __init__(__self__, *,
                 connection_type: str,
                 enable_lfs: bool,
                 enable_oci: bool,
                 github_app_enterprise_base_url: str,
                 github_app_id: str,
                 github_app_installation_id: str,
                 github_app_private_key: str,
                 inherited_creds: bool,
                 insecure: bool,
                 insecure_ignore_host_key: bool,
                 name: str,
                 password: str,
                 project: str,
                 proxy: str,
                 repo: str,
                 ssh_private_key: str,
                 tls_client_cert_data: str,
                 tls_client_cert_key: str,
                 type_: str,
                 username: str):
        """
        :param str connection_type: Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS_ANONYMOUS_CONNECTION_TYPE"
        :param bool enable_lfs: Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        :param bool enable_oci: Indicates if helm-oci support must be enabled for this repo.
        :param str github_app_enterprise_base_url: Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        :param str github_app_id: Id of the GitHub app used to access the repo.
        :param str github_app_installation_id: Installation id of the GitHub app used to access the repo.
        :param str github_app_private_key: GitHub app private key PEM data.
        :param bool inherited_creds: Indicates if the credentials were inherited from a repository credential.
        :param bool insecure: Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        :param bool insecure_ignore_host_key: Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        :param str name: Name to be used for this repo. Only used with Helm repos.
        :param str password: Password or PAT to be used for authenticating the remote repository.
        :param str project: The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        :param str proxy: The HTTP/HTTPS proxy used to access the repo.
        :param str repo: URL to the remote repository.
        :param str ssh_private_key: SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        :param str tls_client_cert_data: Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        :param str tls_client_cert_key: Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        :param str type_: Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        :param str username: Username to be used for authenticating the remote repository.
        """
        pulumi.set(__self__, "connection_type", connection_type)
        pulumi.set(__self__, "enable_lfs", enable_lfs)
        pulumi.set(__self__, "enable_oci", enable_oci)
        pulumi.set(__self__, "github_app_enterprise_base_url", github_app_enterprise_base_url)
        pulumi.set(__self__, "github_app_id", github_app_id)
        pulumi.set(__self__, "github_app_installation_id", github_app_installation_id)
        pulumi.set(__self__, "github_app_private_key", github_app_private_key)
        pulumi.set(__self__, "inherited_creds", inherited_creds)
        pulumi.set(__self__, "insecure", insecure)
        pulumi.set(__self__, "insecure_ignore_host_key", insecure_ignore_host_key)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "project", project)
        pulumi.set(__self__, "proxy", proxy)
        pulumi.set(__self__, "repo", repo)
        pulumi.set(__self__, "ssh_private_key", ssh_private_key)
        pulumi.set(__self__, "tls_client_cert_data", tls_client_cert_data)
        pulumi.set(__self__, "tls_client_cert_key", tls_client_cert_key)
        pulumi.set(__self__, "type_", type_)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> str:
        """
        Identifies the authentication method used to connect to the repository. Possible values: "HTTPS" "SSH" "GITHUB" "HTTPS_ANONYMOUS_CONNECTION_TYPE"
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="enableLfs")
    def enable_lfs(self) -> bool:
        """
        Indicates if git-lfs support must be enabled for this repo. This is valid only for Git repositories.
        """
        return pulumi.get(self, "enable_lfs")

    @property
    @pulumi.getter(name="enableOci")
    def enable_oci(self) -> bool:
        """
        Indicates if helm-oci support must be enabled for this repo.
        """
        return pulumi.get(self, "enable_oci")

    @property
    @pulumi.getter(name="githubAppEnterpriseBaseUrl")
    def github_app_enterprise_base_url(self) -> str:
        """
        Base URL of GitHub Enterprise installation. If left empty, this defaults to https://api.github.com.
        """
        return pulumi.get(self, "github_app_enterprise_base_url")

    @property
    @pulumi.getter(name="githubAppId")
    def github_app_id(self) -> str:
        """
        Id of the GitHub app used to access the repo.
        """
        return pulumi.get(self, "github_app_id")

    @property
    @pulumi.getter(name="githubAppInstallationId")
    def github_app_installation_id(self) -> str:
        """
        Installation id of the GitHub app used to access the repo.
        """
        return pulumi.get(self, "github_app_installation_id")

    @property
    @pulumi.getter(name="githubAppPrivateKey")
    def github_app_private_key(self) -> str:
        """
        GitHub app private key PEM data.
        """
        return pulumi.get(self, "github_app_private_key")

    @property
    @pulumi.getter(name="inheritedCreds")
    def inherited_creds(self) -> bool:
        """
        Indicates if the credentials were inherited from a repository credential.
        """
        return pulumi.get(self, "inherited_creds")

    @property
    @pulumi.getter
    def insecure(self) -> bool:
        """
        Indicates if the connection to the repository ignores any errors when verifying TLS certificates or SSH host keys.
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter(name="insecureIgnoreHostKey")
    def insecure_ignore_host_key(self) -> bool:
        """
        Indicates if InsecureIgnoreHostKey should be used. Insecure is favored used only for git repos. Deprecated.
        """
        return pulumi.get(self, "insecure_ignore_host_key")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name to be used for this repo. Only used with Helm repos.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password or PAT to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def project(self) -> str:
        """
        The ArgoCD project name corresponding to this GitOps repository. An empty string means that the GitOps repository belongs to the default project created by Harness.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def proxy(self) -> str:
        """
        The HTTP/HTTPS proxy used to access the repo.
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def repo(self) -> str:
        """
        URL to the remote repository.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter(name="sshPrivateKey")
    def ssh_private_key(self) -> str:
        """
        SSH Key in PEM format for authenticating the repository. Used only for Git repository.
        """
        return pulumi.get(self, "ssh_private_key")

    @property
    @pulumi.getter(name="tlsClientCertData")
    def tls_client_cert_data(self) -> str:
        """
        Certificate in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "tls_client_cert_data")

    @property
    @pulumi.getter(name="tlsClientCertKey")
    def tls_client_cert_key(self) -> str:
        """
        Private key in PEM format for authenticating at the repo server. This is used for mTLS. The value should be base64 encoded.
        """
        return pulumi.get(self, "tls_client_cert_key")

    @property
    @pulumi.getter
    def type_(self) -> str:
        """
        Type specifies the type of the repo. Can be either "git" or "helm. "git" is assumed if empty or absent.
        """
        return pulumi.get(self, "type_")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to be used for authenticating the remote repository.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetHarRegistryConfigResult(dict):
    def __init__(__self__, *,
                 type: str,
                 auths: Optional[Sequence['outputs.GetHarRegistryConfigAuthResult']] = None,
                 source: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param str type: Type of registry (VIRTUAL, UPSTREAM)
        :param Sequence['GetHarRegistryConfigAuthArgs'] auths: Authentication configuration for UPSTREAM type
        :param str source: Source of the upstream
        :param str url: URL of the upstream
        """
        pulumi.set(__self__, "type", type)
        if auths is not None:
            pulumi.set(__self__, "auths", auths)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of registry (VIRTUAL, UPSTREAM)
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def auths(self) -> Optional[Sequence['outputs.GetHarRegistryConfigAuthResult']]:
        """
        Authentication configuration for UPSTREAM type
        """
        return pulumi.get(self, "auths")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Source of the upstream
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        URL of the upstream
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetHarRegistryConfigAuthResult(dict):
    def __init__(__self__, *,
                 auth_type: str,
                 user_password: Optional['outputs.GetHarRegistryConfigAuthUserPasswordResult'] = None):
        """
        :param str auth_type: Type of authentication (UserPassword, Anonymous)
        :param 'GetHarRegistryConfigAuthUserPasswordArgs' user_password: User password authentication details
        """
        pulumi.set(__self__, "auth_type", auth_type)
        if user_password is not None:
            pulumi.set(__self__, "user_password", user_password)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Type of authentication (UserPassword, Anonymous)
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="userPassword")
    def user_password(self) -> Optional['outputs.GetHarRegistryConfigAuthUserPasswordResult']:
        """
        User password authentication details
        """
        return pulumi.get(self, "user_password")


@pulumi.output_type
class GetHarRegistryConfigAuthUserPasswordResult(dict):
    def __init__(__self__, *,
                 user_name: str,
                 secret_identifier: Optional[str] = None,
                 secret_space_id: Optional[int] = None,
                 secret_space_path: Optional[str] = None):
        """
        :param str user_name: User name
        :param str secret_identifier: Secret identifier
        :param int secret_space_id: Secret space ID
        :param str secret_space_path: Secret space path
        """
        pulumi.set(__self__, "user_name", user_name)
        if secret_identifier is not None:
            pulumi.set(__self__, "secret_identifier", secret_identifier)
        if secret_space_id is not None:
            pulumi.set(__self__, "secret_space_id", secret_space_id)
        if secret_space_path is not None:
            pulumi.set(__self__, "secret_space_path", secret_space_path)

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        User name
        """
        return pulumi.get(self, "user_name")

    @property
    @pulumi.getter(name="secretIdentifier")
    def secret_identifier(self) -> Optional[str]:
        """
        Secret identifier
        """
        return pulumi.get(self, "secret_identifier")

    @property
    @pulumi.getter(name="secretSpaceId")
    def secret_space_id(self) -> Optional[int]:
        """
        Secret space ID
        """
        return pulumi.get(self, "secret_space_id")

    @property
    @pulumi.getter(name="secretSpacePath")
    def secret_space_path(self) -> Optional[str]:
        """
        Secret space path
        """
        return pulumi.get(self, "secret_space_path")


@pulumi.output_type
class GetHelmConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetInfraVariableSetConnectorResult(dict):
    def __init__(__self__, *,
                 connector_ref: str,
                 type: str):
        """
        :param str connector_ref: Unique identifier of the connector.
        :param str type: Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> str:
        """
        Unique identifier of the connector.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type indicates the type of the connector. Currently we support aws, azure, gcp.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetInfraVariableSetEnvironmentVariableResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable`
        :param str value: value is the value of the variable
        :param str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetInfraVariableSetTerraformVariableResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable`
        :param str value: value is the value of the variable
        :param str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetInfraVariableSetTerraformVariableFileResult(dict):
    def __init__(__self__, *,
                 repository: str,
                 repository_connector: str,
                 repository_branch: Optional[str] = None,
                 repository_commit: Optional[str] = None,
                 repository_path: Optional[str] = None,
                 repository_sha: Optional[str] = None):
        """
        :param str repository: Repository is the name of the repository to fetch the code from.
        :param str repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param str repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param str repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param str repository_path: Repository path is the path in which the variables reside.
        :param str repository_sha: Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_connector", repository_connector)
        if repository_branch is not None:
            pulumi.set(__self__, "repository_branch", repository_branch)
        if repository_commit is not None:
            pulumi.set(__self__, "repository_commit", repository_commit)
        if repository_path is not None:
            pulumi.set(__self__, "repository_path", repository_path)
        if repository_sha is not None:
            pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> str:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> Optional[str]:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> Optional[str]:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> Optional[str]:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> Optional[str]:
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")


@pulumi.output_type
class GetInfrastructureGitDetailsResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 load_from_cache: str,
                 load_from_fallback_branch: bool,
                 repo_name: str):
        """
        :param str branch: Name of the branch.
        :param str load_from_cache: If the Entity is to be fetched from cache
        :param bool load_from_fallback_branch: Load Infrastructure yaml from fallback branch
        :param str repo_name: Repo name of remote Infrastructure
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_cache", load_from_cache)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> str:
        """
        If the Entity is to be fetched from cache
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> bool:
        """
        Load Infrastructure yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Repo name of remote Infrastructure
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetInputSetGitDetailsResult(dict):
    def __init__(__self__, *,
                 base_branch: str,
                 branch_name: str,
                 commit_message: str,
                 connector_ref: str,
                 file_path: str,
                 last_commit_id: str,
                 last_object_id: str,
                 parent_entity_connector_ref: str,
                 parent_entity_repo_name: str,
                 repo_name: str,
                 store_type: str):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch_name: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity.
        :param str file_path: File path of the Entity in the repository.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param str parent_entity_connector_ref: Connector reference for Parent Entity (Pipeline).
        :param str parent_entity_repo_name: Repository name for Parent Entity (Pipeline).
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        pulumi.set(__self__, "base_branch", base_branch)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "commit_message", commit_message)
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "file_path", file_path)
        pulumi.set(__self__, "last_commit_id", last_commit_id)
        pulumi.set(__self__, "last_object_id", last_object_id)
        pulumi.set(__self__, "parent_entity_connector_ref", parent_entity_connector_ref)
        pulumi.set(__self__, "parent_entity_repo_name", parent_entity_repo_name)
        pulumi.set(__self__, "repo_name", repo_name)
        pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> str:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> str:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> str:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> str:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> str:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> str:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="parentEntityConnectorRef")
    def parent_entity_connector_ref(self) -> str:
        """
        Connector reference for Parent Entity (Pipeline).
        """
        return pulumi.get(self, "parent_entity_connector_ref")

    @property
    @pulumi.getter(name="parentEntityRepoName")
    def parent_entity_repo_name(self) -> str:
        """
        Repository name for Parent Entity (Pipeline).
        """
        return pulumi.get(self, "parent_entity_repo_name")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> str:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class GetJenkinsConnectorAuthResult(dict):
    def __init__(__self__, *,
                 jenkins_bearer_tokens: Sequence['outputs.GetJenkinsConnectorAuthJenkinsBearerTokenResult'],
                 jenkins_user_name_passwords: Sequence['outputs.GetJenkinsConnectorAuthJenkinsUserNamePasswordResult'],
                 type: str):
        """
        :param Sequence['GetJenkinsConnectorAuthJenkinsBearerTokenArgs'] jenkins_bearer_tokens: Authenticate to App Dynamics using bearer token.
        :param Sequence['GetJenkinsConnectorAuthJenkinsUserNamePasswordArgs'] jenkins_user_name_passwords: Authenticate to App Dynamics using user name and password.
        :param str type: Can be one of UsernamePassword, Anonymous, BearerToken
        """
        pulumi.set(__self__, "jenkins_bearer_tokens", jenkins_bearer_tokens)
        pulumi.set(__self__, "jenkins_user_name_passwords", jenkins_user_name_passwords)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="jenkinsBearerTokens")
    def jenkins_bearer_tokens(self) -> Sequence['outputs.GetJenkinsConnectorAuthJenkinsBearerTokenResult']:
        """
        Authenticate to App Dynamics using bearer token.
        """
        return pulumi.get(self, "jenkins_bearer_tokens")

    @property
    @pulumi.getter(name="jenkinsUserNamePasswords")
    def jenkins_user_name_passwords(self) -> Sequence['outputs.GetJenkinsConnectorAuthJenkinsUserNamePasswordResult']:
        """
        Authenticate to App Dynamics using user name and password.
        """
        return pulumi.get(self, "jenkins_user_name_passwords")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be one of UsernamePassword, Anonymous, BearerToken
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetJenkinsConnectorAuthJenkinsBearerTokenResult(dict):
    def __init__(__self__, *,
                 token_ref: str):
        """
        :param str token_ref: Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "token_ref", token_ref)

    @property
    @pulumi.getter(name="tokenRef")
    def token_ref(self) -> str:
        """
        Reference of the token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "token_ref")


@pulumi.output_type
class GetJenkinsConnectorAuthJenkinsUserNamePasswordResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Username reference to use for authentication.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Username reference to use for authentication.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetJiraConnectorAuthResult(dict):
    def __init__(__self__, *,
                 auth_type: str,
                 personal_access_tokens: Sequence['outputs.GetJiraConnectorAuthPersonalAccessTokenResult'],
                 username_passwords: Sequence['outputs.GetJiraConnectorAuthUsernamePasswordResult']):
        """
        :param str auth_type: Authentication types for Jira connector
        :param Sequence['GetJiraConnectorAuthPersonalAccessTokenArgs'] personal_access_tokens: Authenticate using personal access token.
        :param Sequence['GetJiraConnectorAuthUsernamePasswordArgs'] username_passwords: Authenticate using username password.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "personal_access_tokens", personal_access_tokens)
        pulumi.set(__self__, "username_passwords", username_passwords)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication types for Jira connector
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="personalAccessTokens")
    def personal_access_tokens(self) -> Sequence['outputs.GetJiraConnectorAuthPersonalAccessTokenResult']:
        """
        Authenticate using personal access token.
        """
        return pulumi.get(self, "personal_access_tokens")

    @property
    @pulumi.getter(name="usernamePasswords")
    def username_passwords(self) -> Sequence['outputs.GetJiraConnectorAuthUsernamePasswordResult']:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_passwords")


@pulumi.output_type
class GetJiraConnectorAuthPersonalAccessTokenResult(dict):
    def __init__(__self__, *,
                 pat_ref: str):
        """
        :param str pat_ref: Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "pat_ref", pat_ref)

    @property
    @pulumi.getter(name="patRef")
    def pat_ref(self) -> str:
        """
        Reference to a secret containing the personal access token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "pat_ref")


@pulumi.output_type
class GetJiraConnectorAuthUsernamePasswordResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetKubernetesConnectorClientKeyCertResult(dict):
    def __init__(__self__, *,
                 ca_cert_ref: str,
                 client_cert_ref: str,
                 client_key_algorithm: str,
                 client_key_passphrase_ref: str,
                 client_key_ref: str,
                 master_url: str):
        """
        :param str ca_cert_ref: Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_cert_ref: Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_key_algorithm: The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        :param str client_key_passphrase_ref: Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_key_ref: Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str master_url: The URL of the Kubernetes cluster.
        """
        pulumi.set(__self__, "ca_cert_ref", ca_cert_ref)
        pulumi.set(__self__, "client_cert_ref", client_cert_ref)
        pulumi.set(__self__, "client_key_algorithm", client_key_algorithm)
        pulumi.set(__self__, "client_key_passphrase_ref", client_key_passphrase_ref)
        pulumi.set(__self__, "client_key_ref", client_key_ref)
        pulumi.set(__self__, "master_url", master_url)

    @property
    @pulumi.getter(name="caCertRef")
    def ca_cert_ref(self) -> str:
        """
        Reference to the secret containing the CA certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "ca_cert_ref")

    @property
    @pulumi.getter(name="clientCertRef")
    def client_cert_ref(self) -> str:
        """
        Reference to the secret containing the client certificate for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_cert_ref")

    @property
    @pulumi.getter(name="clientKeyAlgorithm")
    def client_key_algorithm(self) -> str:
        """
        The algorithm used to generate the client key for the connector. Valid values are RSA, EC
        """
        return pulumi.get(self, "client_key_algorithm")

    @property
    @pulumi.getter(name="clientKeyPassphraseRef")
    def client_key_passphrase_ref(self) -> str:
        """
        Reference to the secret containing the client key passphrase for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_key_passphrase_ref")

    @property
    @pulumi.getter(name="clientKeyRef")
    def client_key_ref(self) -> str:
        """
        Reference to the secret containing the client key for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_key_ref")

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")


@pulumi.output_type
class GetKubernetesConnectorInheritFromDelegateResult(dict):
    def __init__(__self__, *,
                 delegate_selectors: Sequence[str]):
        """
        :param Sequence[str] delegate_selectors: Selectors to use for the delegate.
        """
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        Selectors to use for the delegate.
        """
        return pulumi.get(self, "delegate_selectors")


@pulumi.output_type
class GetKubernetesConnectorOpenidConnectResult(dict):
    def __init__(__self__, *,
                 client_id_ref: str,
                 issuer_url: str,
                 master_url: str,
                 password_ref: str,
                 scopes: Sequence[str],
                 secret_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str client_id_ref: Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str issuer_url: The URL of the OpenID Connect issuer.
        :param str master_url: The URL of the Kubernetes cluster.
        :param str password_ref: Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] scopes: Scopes to request for the connector.
        :param str secret_ref: Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username for the connector.
        :param str username_ref: Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "issuer_url", issuer_url)
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "scopes", scopes)
        pulumi.set(__self__, "secret_ref", secret_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> str:
        """
        Reference to the secret containing the client ID for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @property
    @pulumi.getter(name="issuerUrl")
    def issuer_url(self) -> str:
        """
        The URL of the OpenID Connect issuer.
        """
        return pulumi.get(self, "issuer_url")

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def scopes(self) -> Sequence[str]:
        """
        Scopes to request for the connector.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> str:
        """
        Reference to the secret containing the client secret for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "secret_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for the connector.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetKubernetesConnectorServiceAccountResult(dict):
    def __init__(__self__, *,
                 master_url: str,
                 service_account_token_ref: str):
        """
        :param str master_url: The URL of the Kubernetes cluster.
        :param str service_account_token_ref: Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "service_account_token_ref", service_account_token_ref)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="serviceAccountTokenRef")
    def service_account_token_ref(self) -> str:
        """
        Reference to the secret containing the service account token for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "service_account_token_ref")


@pulumi.output_type
class GetKubernetesConnectorUsernamePasswordResult(dict):
    def __init__(__self__, *,
                 master_url: str,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str master_url: The URL of the Kubernetes cluster.
        :param str password_ref: Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username for the connector.
        :param str username_ref: Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "master_url", master_url)
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="masterUrl")
    def master_url(self) -> str:
        """
        The URL of the Kubernetes cluster.
        """
        return pulumi.get(self, "master_url")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to the secret containing the password for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for the connector.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to the secret containing the username for the connector. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetManualFreezeCurrentOrUpcomingWindowResult(dict):
    def __init__(__self__, *,
                 end_time: int,
                 start_time: int):
        """
        :param int end_time: End time of the freeze
        :param int start_time: Start time of the freeze
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> int:
        """
        End time of the freeze
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> int:
        """
        Start time of the freeze
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetManualFreezeFreezeWindowResult(dict):
    def __init__(__self__, *,
                 duration: str,
                 end_time: str,
                 recurrences: Sequence['outputs.GetManualFreezeFreezeWindowRecurrenceResult'],
                 start_time: str,
                 time_zone: str):
        """
        :param str duration: Duration of the freeze
        :param str end_time: End time of the freeze
        :param Sequence['GetManualFreezeFreezeWindowRecurrenceArgs'] recurrences: Recurrence of the freeze window
        :param str start_time: Start time of the freeze
        :param str time_zone: Timezone
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "recurrences", recurrences)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        Duration of the freeze
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> str:
        """
        End time of the freeze
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter
    def recurrences(self) -> Sequence['outputs.GetManualFreezeFreezeWindowRecurrenceResult']:
        """
        Recurrence of the freeze window
        """
        return pulumi.get(self, "recurrences")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> str:
        """
        Start time of the freeze
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> str:
        """
        Timezone
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class GetManualFreezeFreezeWindowRecurrenceResult(dict):
    def __init__(__self__, *,
                 recurrence_specs: Sequence['outputs.GetManualFreezeFreezeWindowRecurrenceRecurrenceSpecResult'],
                 type: str):
        """
        :param Sequence['GetManualFreezeFreezeWindowRecurrenceRecurrenceSpecArgs'] recurrence_specs: Used to filter resources on their attributes
        :param str type: Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
        pulumi.set(__self__, "recurrence_specs", recurrence_specs)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="recurrenceSpecs")
    def recurrence_specs(self) -> Sequence['outputs.GetManualFreezeFreezeWindowRecurrenceRecurrenceSpecResult']:
        """
        Used to filter resources on their attributes
        """
        return pulumi.get(self, "recurrence_specs")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Recurrence type(Daily, Weekly, Monthly, Yearly)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetManualFreezeFreezeWindowRecurrenceRecurrenceSpecResult(dict):
    def __init__(__self__, *,
                 until: str,
                 value: int):
        """
        :param str until: Recurrence until timestamp
        :param int value: Value of n, for n months recurrence
        """
        pulumi.set(__self__, "until", until)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def until(self) -> str:
        """
        Recurrence until timestamp
        """
        return pulumi.get(self, "until")

    @property
    @pulumi.getter
    def value(self) -> int:
        """
        Value of n, for n months recurrence
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetNexusConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetOciHelmConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetOverridesGitDetailsResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 load_from_cache: bool,
                 load_from_fallback_branch: bool,
                 repo_name: str):
        """
        :param str branch: Name of the branch.
        :param bool load_from_cache: Load service yaml from fallback branch
        :param bool load_from_fallback_branch: Load service yaml from fallback branch
        :param str repo_name: Repo name of remote service override
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_cache", load_from_cache)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Repo name of remote service override
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetPermissionsPermissionResult(dict):
    def __init__(__self__, *,
                 action: str,
                 allowed_scope_levels: Sequence[str],
                 identifier: str,
                 include_in_all_roles: bool,
                 name: str,
                 resource_type: str,
                 status: str):
        """
        :param str action: Action performed by the permission
        :param Sequence[str] allowed_scope_levels: The scope levels at which this resource group can be used
        :param str identifier: Identifier of the permission
        :param bool include_in_all_roles: Is included in all roles
        :param str name: Name of the permission
        :param str resource_type: Resource type for the given permission
        :param str status: Status of the permission
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "allowed_scope_levels", allowed_scope_levels)
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "include_in_all_roles", include_in_all_roles)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action performed by the permission
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="allowedScopeLevels")
    def allowed_scope_levels(self) -> Sequence[str]:
        """
        The scope levels at which this resource group can be used
        """
        return pulumi.get(self, "allowed_scope_levels")

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifier of the permission
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="includeInAllRoles")
    def include_in_all_roles(self) -> bool:
        """
        Is included in all roles
        """
        return pulumi.get(self, "include_in_all_roles")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the permission
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Resource type for the given permission
        """
        return pulumi.get(self, "resource_type")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the permission
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetPipelineFiltersFilterPropertyResult(dict):
    def __init__(__self__, *,
                 description: str,
                 filter_type: str,
                 module_properties: 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesResult',
                 name: str,
                 pipeline_identifiers: Sequence[str],
                 pipeline_tags: Sequence[Mapping[str, str]],
                 tags: Sequence[str]):
        """
        :param str description: description of the pipline filter.
        :param str filter_type: Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        :param 'GetPipelineFiltersFilterPropertyModulePropertiesArgs' module_properties: module properties of the pipline filter.
        :param str name: Name of the pipeline filter.
        :param Sequence[str] pipeline_identifiers: Pipeline identifiers to filter on.
        :param Sequence[Mapping[str, str]] pipeline_tags: Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "module_properties", module_properties)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pipeline_identifiers", pipeline_identifiers)
        pulumi.set(__self__, "pipeline_tags", pipeline_tags)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        description of the pipline filter.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, PipelineSetup, PipelineExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter(name="moduleProperties")
    def module_properties(self) -> 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesResult':
        """
        module properties of the pipline filter.
        """
        return pulumi.get(self, "module_properties")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the pipeline filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pipelineIdentifiers")
    def pipeline_identifiers(self) -> Sequence[str]:
        """
        Pipeline identifiers to filter on.
        """
        return pulumi.get(self, "pipeline_identifiers")

    @property
    @pulumi.getter(name="pipelineTags")
    def pipeline_tags(self) -> Sequence[Mapping[str, str]]:
        """
        Tags to associate with the pipeline. tags should be in the form of `{key:key1, value:key1value}`
        """
        return pulumi.get(self, "pipeline_tags")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetPipelineFiltersFilterPropertyModulePropertiesResult(dict):
    def __init__(__self__, *,
                 cd: 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCdResult',
                 ci: 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCiResult'):
        """
        :param 'GetPipelineFiltersFilterPropertyModulePropertiesCdArgs' cd: CD related properties to be filtered on.
        :param 'GetPipelineFiltersFilterPropertyModulePropertiesCiArgs' ci: CI related properties to be filtered on.
        """
        pulumi.set(__self__, "cd", cd)
        pulumi.set(__self__, "ci", ci)

    @property
    @pulumi.getter
    def cd(self) -> 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCdResult':
        """
        CD related properties to be filtered on.
        """
        return pulumi.get(self, "cd")

    @property
    @pulumi.getter
    def ci(self) -> 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCiResult':
        """
        CI related properties to be filtered on.
        """
        return pulumi.get(self, "ci")


@pulumi.output_type
class GetPipelineFiltersFilterPropertyModulePropertiesCdResult(dict):
    def __init__(__self__, *,
                 artifact_display_names: Sequence[str],
                 deployment_types: str,
                 environment_names: Sequence[str],
                 service_identifiers: Sequence[str],
                 service_names: Sequence[str]):
        """
        :param Sequence[str] artifact_display_names: Artifact display names of the CD pipeline.
        :param str deployment_types: Deployment type of the CD pipeline, eg. Kubernetes
        :param Sequence[str] environment_names: Environment names of the CD pipeline.
        :param Sequence[str] service_identifiers: Service identifiers of the CD pipeline.
        :param Sequence[str] service_names: Service names of the CD pipeline.
        """
        pulumi.set(__self__, "artifact_display_names", artifact_display_names)
        pulumi.set(__self__, "deployment_types", deployment_types)
        pulumi.set(__self__, "environment_names", environment_names)
        pulumi.set(__self__, "service_identifiers", service_identifiers)
        pulumi.set(__self__, "service_names", service_names)

    @property
    @pulumi.getter(name="artifactDisplayNames")
    def artifact_display_names(self) -> Sequence[str]:
        """
        Artifact display names of the CD pipeline.
        """
        return pulumi.get(self, "artifact_display_names")

    @property
    @pulumi.getter(name="deploymentTypes")
    def deployment_types(self) -> str:
        """
        Deployment type of the CD pipeline, eg. Kubernetes
        """
        return pulumi.get(self, "deployment_types")

    @property
    @pulumi.getter(name="environmentNames")
    def environment_names(self) -> Sequence[str]:
        """
        Environment names of the CD pipeline.
        """
        return pulumi.get(self, "environment_names")

    @property
    @pulumi.getter(name="serviceIdentifiers")
    def service_identifiers(self) -> Sequence[str]:
        """
        Service identifiers of the CD pipeline.
        """
        return pulumi.get(self, "service_identifiers")

    @property
    @pulumi.getter(name="serviceNames")
    def service_names(self) -> Sequence[str]:
        """
        Service names of the CD pipeline.
        """
        return pulumi.get(self, "service_names")


@pulumi.output_type
class GetPipelineFiltersFilterPropertyModulePropertiesCiResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 build_type: str,
                 ci_execution_info: 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoResult',
                 repo_names: str,
                 tag: str):
        """
        :param str branch: Branch which was used while building.
        :param str build_type: Build type of the pipeline. Possible values: branch.
        :param 'GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoArgs' ci_execution_info: CI execution info for the pipeline.
        :param str repo_names: name of the repository used in the pipeline.
        :param str tag: Tags to associate with the CI pipeline resource.
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "build_type", build_type)
        pulumi.set(__self__, "ci_execution_info", ci_execution_info)
        pulumi.set(__self__, "repo_names", repo_names)
        pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Branch which was used while building.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="buildType")
    def build_type(self) -> str:
        """
        Build type of the pipeline. Possible values: branch.
        """
        return pulumi.get(self, "build_type")

    @property
    @pulumi.getter(name="ciExecutionInfo")
    def ci_execution_info(self) -> 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoResult':
        """
        CI execution info for the pipeline.
        """
        return pulumi.get(self, "ci_execution_info")

    @property
    @pulumi.getter(name="repoNames")
    def repo_names(self) -> str:
        """
        name of the repository used in the pipeline.
        """
        return pulumi.get(self, "repo_names")

    @property
    @pulumi.getter
    def tag(self) -> str:
        """
        Tags to associate with the CI pipeline resource.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoResult(dict):
    def __init__(__self__, *,
                 event: str,
                 pull_request: 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoPullRequestResult'):
        """
        :param str event: Event for the ci execution, Possible values: pullRequest.
        :param 'GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoPullRequestArgs' pull_request: The pull request details of the CI pipeline.
        """
        pulumi.set(__self__, "event", event)
        pulumi.set(__self__, "pull_request", pull_request)

    @property
    @pulumi.getter
    def event(self) -> str:
        """
        Event for the ci execution, Possible values: pullRequest.
        """
        return pulumi.get(self, "event")

    @property
    @pulumi.getter(name="pullRequest")
    def pull_request(self) -> 'outputs.GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoPullRequestResult':
        """
        The pull request details of the CI pipeline.
        """
        return pulumi.get(self, "pull_request")


@pulumi.output_type
class GetPipelineFiltersFilterPropertyModulePropertiesCiCiExecutionInfoPullRequestResult(dict):
    def __init__(__self__, *,
                 source_branch: str,
                 target_branch: str):
        """
        :param str source_branch: Source branch of the pull request.
        :param str target_branch: Target branch of the pull request.
        """
        pulumi.set(__self__, "source_branch", source_branch)
        pulumi.set(__self__, "target_branch", target_branch)

    @property
    @pulumi.getter(name="sourceBranch")
    def source_branch(self) -> str:
        """
        Source branch of the pull request.
        """
        return pulumi.get(self, "source_branch")

    @property
    @pulumi.getter(name="targetBranch")
    def target_branch(self) -> str:
        """
        Target branch of the pull request.
        """
        return pulumi.get(self, "target_branch")


@pulumi.output_type
class GetPipelineGitDetailsResult(dict):
    def __init__(__self__, *,
                 base_branch: str,
                 branch_name: str,
                 commit_message: str,
                 connector_ref: str,
                 file_path: str,
                 last_commit_id: str,
                 last_object_id: str,
                 repo_name: str,
                 store_type: str):
        """
        :param str base_branch: Name of the default branch (this checks out a new branch titled by branch_name).
        :param str branch_name: Name of the branch.
        :param str commit_message: Commit message used for the merge commit.
        :param str connector_ref: Identifier of the Harness Connector used for CRUD operations on the Entity.
        :param str file_path: File path of the Entity in the repository.
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param str repo_name: Name of the repository.
        :param str store_type: Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        pulumi.set(__self__, "base_branch", base_branch)
        pulumi.set(__self__, "branch_name", branch_name)
        pulumi.set(__self__, "commit_message", commit_message)
        pulumi.set(__self__, "connector_ref", connector_ref)
        pulumi.set(__self__, "file_path", file_path)
        pulumi.set(__self__, "last_commit_id", last_commit_id)
        pulumi.set(__self__, "last_object_id", last_object_id)
        pulumi.set(__self__, "repo_name", repo_name)
        pulumi.set(__self__, "store_type", store_type)

    @property
    @pulumi.getter(name="baseBranch")
    def base_branch(self) -> str:
        """
        Name of the default branch (this checks out a new branch titled by branch_name).
        """
        return pulumi.get(self, "base_branch")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="commitMessage")
    def commit_message(self) -> str:
        """
        Commit message used for the merge commit.
        """
        return pulumi.get(self, "commit_message")

    @property
    @pulumi.getter(name="connectorRef")
    def connector_ref(self) -> str:
        """
        Identifier of the Harness Connector used for CRUD operations on the Entity.
        """
        return pulumi.get(self, "connector_ref")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> str:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> str:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> str:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="storeType")
    def store_type(self) -> str:
        """
        Specifies whether the Entity is to be stored in Git or not. Possible values: INLINE, REMOTE.
        """
        return pulumi.get(self, "store_type")


@pulumi.output_type
class GetPipelineListPipelineResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 name: str):
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicySetPolicyResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 severity: str):
        """
        :param str identifier: Account Identifier of the account
        :param str severity: Policy failure response - 'warning' for continuation, 'error' for exit
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def severity(self) -> str:
        """
        Policy failure response - 'warning' for continuation, 'error' for exit
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class GetProjectListProjectResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 name: str):
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPrometheusConnectorHeaderResult(dict):
    def __init__(__self__, *,
                 encrypted_value_ref: str,
                 key: str,
                 value: str,
                 value_encrypted: bool):
        """
        :param str encrypted_value_ref: Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str key: Key.
        :param str value: Value.
        :param bool value_encrypted: Encrypted value.
        """
        pulumi.set(__self__, "encrypted_value_ref", encrypted_value_ref)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_encrypted", value_encrypted)

    @property
    @pulumi.getter(name="encryptedValueRef")
    def encrypted_value_ref(self) -> str:
        """
        Reference to the Harness secret containing the encrypted value. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "encrypted_value_ref")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueEncrypted")
    def value_encrypted(self) -> bool:
        """
        Encrypted value.
        """
        return pulumi.get(self, "value_encrypted")


@pulumi.output_type
class GetRepoRuleBranchBypassResult(dict):
    def __init__(__self__, *,
                 repo_owners: Optional[bool] = None,
                 user_ids: Optional[Sequence[str]] = None):
        """
        :param bool repo_owners: Allow users with repository edit permission to bypass.
        :param Sequence[str] user_ids: List of user ids with who can bypass.
        """
        if repo_owners is not None:
            pulumi.set(__self__, "repo_owners", repo_owners)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @property
    @pulumi.getter(name="repoOwners")
    def repo_owners(self) -> Optional[bool]:
        """
        Allow users with repository edit permission to bypass.
        """
        return pulumi.get(self, "repo_owners")

    @property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[Sequence[str]]:
        """
        List of user ids with who can bypass.
        """
        return pulumi.get(self, "user_ids")


@pulumi.output_type
class GetRepoRuleBranchPatternResult(dict):
    def __init__(__self__, *,
                 default_branch: Optional[bool] = None,
                 excludes: Optional[Sequence[str]] = None,
                 includes: Optional[Sequence[str]] = None):
        """
        :param bool default_branch: Should rule apply to default branch of the repository.
        :param Sequence[str] excludes: Globstar branch patterns on which rules will NOT be applied.
        :param Sequence[str] includes: Globstar branch patterns on which rules will be applied.
        """
        if default_branch is not None:
            pulumi.set(__self__, "default_branch", default_branch)
        if excludes is not None:
            pulumi.set(__self__, "excludes", excludes)
        if includes is not None:
            pulumi.set(__self__, "includes", includes)

    @property
    @pulumi.getter(name="defaultBranch")
    def default_branch(self) -> Optional[bool]:
        """
        Should rule apply to default branch of the repository.
        """
        return pulumi.get(self, "default_branch")

    @property
    @pulumi.getter
    def excludes(self) -> Optional[Sequence[str]]:
        """
        Globstar branch patterns on which rules will NOT be applied.
        """
        return pulumi.get(self, "excludes")

    @property
    @pulumi.getter
    def includes(self) -> Optional[Sequence[str]]:
        """
        Globstar branch patterns on which rules will be applied.
        """
        return pulumi.get(self, "includes")


@pulumi.output_type
class GetRepoRuleBranchPolicyResult(dict):
    def __init__(__self__, *,
                 allow_merge_strategies: Optional[Sequence[str]] = None,
                 block_branch_creation: Optional[bool] = None,
                 block_branch_deletion: Optional[bool] = None,
                 delete_branch_on_merge: Optional[bool] = None,
                 require_code_owners: Optional[bool] = None,
                 require_latest_commit_approval: Optional[bool] = None,
                 require_minimum_approval_count: Optional[int] = None,
                 require_no_change_request: Optional[bool] = None,
                 require_pull_request: Optional[bool] = None,
                 require_resolve_all_comments: Optional[bool] = None,
                 require_status_checks: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] allow_merge_strategies: Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        :param bool block_branch_creation: Only allow users with bypass permission to create matching branches.
        :param bool block_branch_deletion: Only allow users with bypass permission to delete matching branches.
        :param bool delete_branch_on_merge: Automatically delete the source branch of a pull request after it is merged.
        :param bool require_code_owners: Require approval on pull requests from one reviewer for each codeowner rule.
        :param bool require_latest_commit_approval: Require re-approval when there are new changes in the pull request.
        :param int require_minimum_approval_count: Require approval on pull requests from a minimum number of reviewers.
        :param bool require_no_change_request: Require all request for changes have been resolved.
        :param bool require_pull_request: Do not allow any changes to matching branches without a pull request.
        :param bool require_resolve_all_comments: All comments on a pull request must be resolved before it can be merged.
        :param Sequence[str] require_status_checks: Selected status checks must pass before a pull request can be merged.
        """
        if allow_merge_strategies is not None:
            pulumi.set(__self__, "allow_merge_strategies", allow_merge_strategies)
        if block_branch_creation is not None:
            pulumi.set(__self__, "block_branch_creation", block_branch_creation)
        if block_branch_deletion is not None:
            pulumi.set(__self__, "block_branch_deletion", block_branch_deletion)
        if delete_branch_on_merge is not None:
            pulumi.set(__self__, "delete_branch_on_merge", delete_branch_on_merge)
        if require_code_owners is not None:
            pulumi.set(__self__, "require_code_owners", require_code_owners)
        if require_latest_commit_approval is not None:
            pulumi.set(__self__, "require_latest_commit_approval", require_latest_commit_approval)
        if require_minimum_approval_count is not None:
            pulumi.set(__self__, "require_minimum_approval_count", require_minimum_approval_count)
        if require_no_change_request is not None:
            pulumi.set(__self__, "require_no_change_request", require_no_change_request)
        if require_pull_request is not None:
            pulumi.set(__self__, "require_pull_request", require_pull_request)
        if require_resolve_all_comments is not None:
            pulumi.set(__self__, "require_resolve_all_comments", require_resolve_all_comments)
        if require_status_checks is not None:
            pulumi.set(__self__, "require_status_checks", require_status_checks)

    @property
    @pulumi.getter(name="allowMergeStrategies")
    def allow_merge_strategies(self) -> Optional[Sequence[str]]:
        """
        Limit which merge strategies are available to merge a pull request(Any of squash, rebase, merge).
        """
        return pulumi.get(self, "allow_merge_strategies")

    @property
    @pulumi.getter(name="blockBranchCreation")
    def block_branch_creation(self) -> Optional[bool]:
        """
        Only allow users with bypass permission to create matching branches.
        """
        return pulumi.get(self, "block_branch_creation")

    @property
    @pulumi.getter(name="blockBranchDeletion")
    def block_branch_deletion(self) -> Optional[bool]:
        """
        Only allow users with bypass permission to delete matching branches.
        """
        return pulumi.get(self, "block_branch_deletion")

    @property
    @pulumi.getter(name="deleteBranchOnMerge")
    def delete_branch_on_merge(self) -> Optional[bool]:
        """
        Automatically delete the source branch of a pull request after it is merged.
        """
        return pulumi.get(self, "delete_branch_on_merge")

    @property
    @pulumi.getter(name="requireCodeOwners")
    def require_code_owners(self) -> Optional[bool]:
        """
        Require approval on pull requests from one reviewer for each codeowner rule.
        """
        return pulumi.get(self, "require_code_owners")

    @property
    @pulumi.getter(name="requireLatestCommitApproval")
    def require_latest_commit_approval(self) -> Optional[bool]:
        """
        Require re-approval when there are new changes in the pull request.
        """
        return pulumi.get(self, "require_latest_commit_approval")

    @property
    @pulumi.getter(name="requireMinimumApprovalCount")
    def require_minimum_approval_count(self) -> Optional[int]:
        """
        Require approval on pull requests from a minimum number of reviewers.
        """
        return pulumi.get(self, "require_minimum_approval_count")

    @property
    @pulumi.getter(name="requireNoChangeRequest")
    def require_no_change_request(self) -> Optional[bool]:
        """
        Require all request for changes have been resolved.
        """
        return pulumi.get(self, "require_no_change_request")

    @property
    @pulumi.getter(name="requirePullRequest")
    def require_pull_request(self) -> Optional[bool]:
        """
        Do not allow any changes to matching branches without a pull request.
        """
        return pulumi.get(self, "require_pull_request")

    @property
    @pulumi.getter(name="requireResolveAllComments")
    def require_resolve_all_comments(self) -> Optional[bool]:
        """
        All comments on a pull request must be resolved before it can be merged.
        """
        return pulumi.get(self, "require_resolve_all_comments")

    @property
    @pulumi.getter(name="requireStatusChecks")
    def require_status_checks(self) -> Optional[Sequence[str]]:
        """
        Selected status checks must pass before a pull request can be merged.
        """
        return pulumi.get(self, "require_status_checks")


@pulumi.output_type
class GetRepoSourceResult(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 password: Optional[str] = None,
                 repo: Optional[str] = None,
                 type: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str host: The host URL for the import source.
        :param str password: The password for authentication when importing.
        :param str repo: The full identifier of the repository on the SCM provider's platform.
        :param str type: The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        :param str username: The username for authentication when importing.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The host URL for the import source.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        The password for authentication when importing.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def repo(self) -> Optional[str]:
        """
        The full identifier of the repository on the SCM provider's platform.
        """
        return pulumi.get(self, "repo")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of SCM provider (github, gitlab, bitbucket, stash, gitea, gogs) when importing.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        The username for authentication when importing.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class GetResourceGroupIncludedScopeResult(dict):
    def __init__(__self__, *,
                 account_id: str,
                 filter: str,
                 org_id: str,
                 project_id: str):
        """
        :param str account_id: Account Identifier of the account
        :param str filter: Can be one of these 2 EXCLUDING_CHILD_SCOPES or INCLUDING_CHILD_SCOPES
        :param str org_id: Organization Identifier
        :param str project_id: Project Identifier
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "org_id", org_id)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Account Identifier of the account
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def filter(self) -> str:
        """
        Can be one of these 2 EXCLUDING_CHILD_SCOPES or INCLUDING_CHILD_SCOPES
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="orgId")
    def org_id(self) -> str:
        """
        Organization Identifier
        """
        return pulumi.get(self, "org_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Project Identifier
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class GetResourceGroupResourceFilterResult(dict):
    def __init__(__self__, *,
                 include_all_resources: bool,
                 resources: Sequence['outputs.GetResourceGroupResourceFilterResourceResult']):
        """
        :param bool include_all_resources: Include all resource or not
        :param Sequence['GetResourceGroupResourceFilterResourceArgs'] resources: Resources for a resource group
        """
        pulumi.set(__self__, "include_all_resources", include_all_resources)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter(name="includeAllResources")
    def include_all_resources(self) -> bool:
        """
        Include all resource or not
        """
        return pulumi.get(self, "include_all_resources")

    @property
    @pulumi.getter
    def resources(self) -> Sequence['outputs.GetResourceGroupResourceFilterResourceResult']:
        """
        Resources for a resource group
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class GetResourceGroupResourceFilterResourceResult(dict):
    def __init__(__self__, *,
                 attribute_filters: Sequence['outputs.GetResourceGroupResourceFilterResourceAttributeFilterResult'],
                 identifiers: Sequence[str],
                 resource_type: str):
        """
        :param Sequence['GetResourceGroupResourceFilterResourceAttributeFilterArgs'] attribute_filters: Used to filter resources on their attributes
        :param Sequence[str] identifiers: List of the identifiers
        :param str resource_type: Type of the resource
        """
        pulumi.set(__self__, "attribute_filters", attribute_filters)
        pulumi.set(__self__, "identifiers", identifiers)
        pulumi.set(__self__, "resource_type", resource_type)

    @property
    @pulumi.getter(name="attributeFilters")
    def attribute_filters(self) -> Sequence['outputs.GetResourceGroupResourceFilterResourceAttributeFilterResult']:
        """
        Used to filter resources on their attributes
        """
        return pulumi.get(self, "attribute_filters")

    @property
    @pulumi.getter
    def identifiers(self) -> Sequence[str]:
        """
        List of the identifiers
        """
        return pulumi.get(self, "identifiers")

    @property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> str:
        """
        Type of the resource
        """
        return pulumi.get(self, "resource_type")


@pulumi.output_type
class GetResourceGroupResourceFilterResourceAttributeFilterResult(dict):
    def __init__(__self__, *,
                 attribute_name: str,
                 attribute_values: Sequence[str]):
        """
        :param str attribute_name: Name of the attribute
        :param Sequence[str] attribute_values: Value of the attributes
        """
        pulumi.set(__self__, "attribute_name", attribute_name)
        pulumi.set(__self__, "attribute_values", attribute_values)

    @property
    @pulumi.getter(name="attributeName")
    def attribute_name(self) -> str:
        """
        Name of the attribute
        """
        return pulumi.get(self, "attribute_name")

    @property
    @pulumi.getter(name="attributeValues")
    def attribute_values(self) -> Sequence[str]:
        """
        Value of the attributes
        """
        return pulumi.get(self, "attribute_values")


@pulumi.output_type
class GetRoleAssignmentsPrincipalResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 scope_level: str,
                 type: str):
        """
        :param str identifier: Identifier.
        :param str scope_level: Scope level.
        :param str type: Type.
        """
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "scope_level", scope_level)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        """
        Identifier.
        """
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter(name="scopeLevel")
    def scope_level(self) -> str:
        """
        Scope level.
        """
        return pulumi.get(self, "scope_level")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSecretSshkeyKerberoResult(dict):
    def __init__(__self__, *,
                 principal: str,
                 realm: str,
                 tgt_generation_method: str,
                 tgt_key_tab_file_path_specs: Sequence['outputs.GetSecretSshkeyKerberoTgtKeyTabFilePathSpecResult'],
                 tgt_password_specs: Sequence['outputs.GetSecretSshkeyKerberoTgtPasswordSpecResult']):
        """
        :param str principal: Username to use for authentication.
        :param str realm: Reference to a secret containing the password to use for authentication.
        :param str tgt_generation_method: Method to generate tgt
        :param Sequence['GetSecretSshkeyKerberoTgtKeyTabFilePathSpecArgs'] tgt_key_tab_file_path_specs: Authenticate to App Dynamics using username and password.
        :param Sequence['GetSecretSshkeyKerberoTgtPasswordSpecArgs'] tgt_password_specs: Authenticate to App Dynamics using username and password.
        """
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "realm", realm)
        pulumi.set(__self__, "tgt_generation_method", tgt_generation_method)
        pulumi.set(__self__, "tgt_key_tab_file_path_specs", tgt_key_tab_file_path_specs)
        pulumi.set(__self__, "tgt_password_specs", tgt_password_specs)

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "principal")

    @property
    @pulumi.getter
    def realm(self) -> str:
        """
        Reference to a secret containing the password to use for authentication.
        """
        return pulumi.get(self, "realm")

    @property
    @pulumi.getter(name="tgtGenerationMethod")
    def tgt_generation_method(self) -> str:
        """
        Method to generate tgt
        """
        return pulumi.get(self, "tgt_generation_method")

    @property
    @pulumi.getter(name="tgtKeyTabFilePathSpecs")
    def tgt_key_tab_file_path_specs(self) -> Sequence['outputs.GetSecretSshkeyKerberoTgtKeyTabFilePathSpecResult']:
        """
        Authenticate to App Dynamics using username and password.
        """
        return pulumi.get(self, "tgt_key_tab_file_path_specs")

    @property
    @pulumi.getter(name="tgtPasswordSpecs")
    def tgt_password_specs(self) -> Sequence['outputs.GetSecretSshkeyKerberoTgtPasswordSpecResult']:
        """
        Authenticate to App Dynamics using username and password.
        """
        return pulumi.get(self, "tgt_password_specs")


@pulumi.output_type
class GetSecretSshkeyKerberoTgtKeyTabFilePathSpecResult(dict):
    def __init__(__self__, *,
                 key_path: str):
        """
        :param str key_path: key path
        """
        pulumi.set(__self__, "key_path", key_path)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> str:
        """
        key path
        """
        return pulumi.get(self, "key_path")


@pulumi.output_type
class GetSecretSshkeyKerberoTgtPasswordSpecResult(dict):
    def __init__(__self__, *,
                 password: str):
        """
        :param str password: password
        """
        pulumi.set(__self__, "password", password)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        password
        """
        return pulumi.get(self, "password")


@pulumi.output_type
class GetSecretSshkeySshResult(dict):
    def __init__(__self__, *,
                 credential_type: str,
                 ssh_password_credentials: Sequence['outputs.GetSecretSshkeySshSshPasswordCredentialResult'],
                 sshkey_path_credentials: Sequence['outputs.GetSecretSshkeySshSshkeyPathCredentialResult'],
                 sshkey_reference_credentials: Sequence['outputs.GetSecretSshkeySshSshkeyReferenceCredentialResult']):
        """
        :param str credential_type: This specifies SSH credential type as Password, KeyPath or KeyReference
        :param Sequence['GetSecretSshkeySshSshPasswordCredentialArgs'] ssh_password_credentials: SSH credential of type keyReference
        :param Sequence['GetSecretSshkeySshSshkeyPathCredentialArgs'] sshkey_path_credentials: SSH credential of type keyPath
        :param Sequence['GetSecretSshkeySshSshkeyReferenceCredentialArgs'] sshkey_reference_credentials: SSH credential of type keyReference
        """
        pulumi.set(__self__, "credential_type", credential_type)
        pulumi.set(__self__, "ssh_password_credentials", ssh_password_credentials)
        pulumi.set(__self__, "sshkey_path_credentials", sshkey_path_credentials)
        pulumi.set(__self__, "sshkey_reference_credentials", sshkey_reference_credentials)

    @property
    @pulumi.getter(name="credentialType")
    def credential_type(self) -> str:
        """
        This specifies SSH credential type as Password, KeyPath or KeyReference
        """
        return pulumi.get(self, "credential_type")

    @property
    @pulumi.getter(name="sshPasswordCredentials")
    def ssh_password_credentials(self) -> Sequence['outputs.GetSecretSshkeySshSshPasswordCredentialResult']:
        """
        SSH credential of type keyReference
        """
        return pulumi.get(self, "ssh_password_credentials")

    @property
    @pulumi.getter(name="sshkeyPathCredentials")
    def sshkey_path_credentials(self) -> Sequence['outputs.GetSecretSshkeySshSshkeyPathCredentialResult']:
        """
        SSH credential of type keyPath
        """
        return pulumi.get(self, "sshkey_path_credentials")

    @property
    @pulumi.getter(name="sshkeyReferenceCredentials")
    def sshkey_reference_credentials(self) -> Sequence['outputs.GetSecretSshkeySshSshkeyReferenceCredentialResult']:
        """
        SSH credential of type keyReference
        """
        return pulumi.get(self, "sshkey_reference_credentials")


@pulumi.output_type
class GetSecretSshkeySshSshPasswordCredentialResult(dict):
    def __init__(__self__, *,
                 password: str,
                 user_name: str):
        """
        :param str password: SSH Password.
        :param str user_name: SSH Username.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        SSH Password.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetSecretSshkeySshSshkeyPathCredentialResult(dict):
    def __init__(__self__, *,
                 encrypted_passphrase: str,
                 key_path: str,
                 user_name: str):
        """
        :param str encrypted_passphrase: Encrypted Passphrase
        :param str key_path: Path of the key file.
        :param str user_name: SSH Username.
        """
        pulumi.set(__self__, "encrypted_passphrase", encrypted_passphrase)
        pulumi.set(__self__, "key_path", key_path)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="encryptedPassphrase")
    def encrypted_passphrase(self) -> str:
        """
        Encrypted Passphrase
        """
        return pulumi.get(self, "encrypted_passphrase")

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> str:
        """
        Path of the key file.
        """
        return pulumi.get(self, "key_path")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetSecretSshkeySshSshkeyReferenceCredentialResult(dict):
    def __init__(__self__, *,
                 encrypted_assphrase: str,
                 key: str,
                 user_name: str):
        """
        :param str encrypted_assphrase: Encrypted Passphrase
        :param str key: SSH key.
        :param str user_name: SSH Username.
        """
        pulumi.set(__self__, "encrypted_assphrase", encrypted_assphrase)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "user_name", user_name)

    @property
    @pulumi.getter(name="encryptedAssphrase")
    def encrypted_assphrase(self) -> str:
        """
        Encrypted Passphrase
        """
        return pulumi.get(self, "encrypted_assphrase")

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        SSH key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="userName")
    def user_name(self) -> str:
        """
        SSH Username.
        """
        return pulumi.get(self, "user_name")


@pulumi.output_type
class GetSecretTextAdditionalMetadataResult(dict):
    def __init__(__self__, *,
                 values: Optional[Sequence['outputs.GetSecretTextAdditionalMetadataValueResult']] = None):
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.GetSecretTextAdditionalMetadataValueResult']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GetSecretTextAdditionalMetadataValueResult(dict):
    def __init__(__self__, *,
                 version: Optional[str] = None):
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def version(self) -> Optional[str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class GetServiceGitDetailsResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 load_from_fallback_branch: bool,
                 repo_name: str):
        """
        :param str branch: Name of the branch.
        :param bool load_from_fallback_branch: Load service yaml from fallback branch
        :param str repo_name: Repo name of remote service
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Repo name of remote service
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetServiceListServiceResult(dict):
    def __init__(__self__, *,
                 identifier: str,
                 name: str):
        pulumi.set(__self__, "identifier", identifier)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def identifier(self) -> str:
        return pulumi.get(self, "identifier")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServiceNowConnectorAuthResult(dict):
    def __init__(__self__, *,
                 adfs: Sequence['outputs.GetServiceNowConnectorAuthAdfResult'],
                 auth_type: str,
                 refresh_tokens: Sequence['outputs.GetServiceNowConnectorAuthRefreshTokenResult'],
                 username_passwords: Sequence['outputs.GetServiceNowConnectorAuthUsernamePasswordResult']):
        """
        :param Sequence['GetServiceNowConnectorAuthAdfArgs'] adfs: Authenticate using adfs client credentials with certificate.
        :param str auth_type: Authentication types for Jira connector
        :param Sequence['GetServiceNowConnectorAuthRefreshTokenArgs'] refresh_tokens: Authenticate using refresh token grant type.
        :param Sequence['GetServiceNowConnectorAuthUsernamePasswordArgs'] username_passwords: Authenticate using username password.
        """
        pulumi.set(__self__, "adfs", adfs)
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "refresh_tokens", refresh_tokens)
        pulumi.set(__self__, "username_passwords", username_passwords)

    @property
    @pulumi.getter
    def adfs(self) -> Sequence['outputs.GetServiceNowConnectorAuthAdfResult']:
        """
        Authenticate using adfs client credentials with certificate.
        """
        return pulumi.get(self, "adfs")

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> str:
        """
        Authentication types for Jira connector
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="refreshTokens")
    def refresh_tokens(self) -> Sequence['outputs.GetServiceNowConnectorAuthRefreshTokenResult']:
        """
        Authenticate using refresh token grant type.
        """
        return pulumi.get(self, "refresh_tokens")

    @property
    @pulumi.getter(name="usernamePasswords")
    def username_passwords(self) -> Sequence['outputs.GetServiceNowConnectorAuthUsernamePasswordResult']:
        """
        Authenticate using username password.
        """
        return pulumi.get(self, "username_passwords")


@pulumi.output_type
class GetServiceNowConnectorAuthAdfResult(dict):
    def __init__(__self__, *,
                 adfs_url: str,
                 certificate_ref: str,
                 client_id_ref: str,
                 private_key_ref: str,
                 resource_id_ref: str):
        """
        :param str adfs_url: asdf URL.
        :param str certificate_ref: Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_id_ref: Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str private_key_ref: Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str resource_id_ref: Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "adfs_url", adfs_url)
        pulumi.set(__self__, "certificate_ref", certificate_ref)
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "private_key_ref", private_key_ref)
        pulumi.set(__self__, "resource_id_ref", resource_id_ref)

    @property
    @pulumi.getter(name="adfsUrl")
    def adfs_url(self) -> str:
        """
        asdf URL.
        """
        return pulumi.get(self, "adfs_url")

    @property
    @pulumi.getter(name="certificateRef")
    def certificate_ref(self) -> str:
        """
        Reference to a secret containing the certificate to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "certificate_ref")

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> str:
        """
        Reference to a secret containing the clientIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @property
    @pulumi.getter(name="privateKeyRef")
    def private_key_ref(self) -> str:
        """
        Reference to a secret containing the privateKeyRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "private_key_ref")

    @property
    @pulumi.getter(name="resourceIdRef")
    def resource_id_ref(self) -> str:
        """
        Reference to a secret containing the resourceIdRef to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "resource_id_ref")


@pulumi.output_type
class GetServiceNowConnectorAuthRefreshTokenResult(dict):
    def __init__(__self__, *,
                 client_id_ref: str,
                 client_secret_ref: str,
                 refresh_token_ref: str,
                 scope: str,
                 token_url: str):
        """
        :param str client_id_ref: Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str client_secret_ref: Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str refresh_token_ref: Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str scope: Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str token_url: Token url to use for authentication.
        """
        pulumi.set(__self__, "client_id_ref", client_id_ref)
        pulumi.set(__self__, "client_secret_ref", client_secret_ref)
        pulumi.set(__self__, "refresh_token_ref", refresh_token_ref)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "token_url", token_url)

    @property
    @pulumi.getter(name="clientIdRef")
    def client_id_ref(self) -> str:
        """
        Reference to a secret containing the client id to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_id_ref")

    @property
    @pulumi.getter(name="clientSecretRef")
    def client_secret_ref(self) -> str:
        """
        Reference to a secret containing the client secret to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "client_secret_ref")

    @property
    @pulumi.getter(name="refreshTokenRef")
    def refresh_token_ref(self) -> str:
        """
        Reference to a secret containing the refresh token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "refresh_token_ref")

    @property
    @pulumi.getter
    def scope(self) -> str:
        """
        Scope string to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="tokenUrl")
    def token_url(self) -> str:
        """
        Token url to use for authentication.
        """
        return pulumi.get(self, "token_url")


@pulumi.output_type
class GetServiceNowConnectorAuthUsernamePasswordResult(dict):
    def __init__(__self__, *,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str password_ref: Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference to a secret containing the password to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetServiceOverridesV2GitDetailsResult(dict):
    def __init__(__self__, *,
                 branch: str,
                 load_from_cache: bool,
                 load_from_fallback_branch: bool,
                 repo_name: str):
        """
        :param str branch: Name of the branch.
        :param bool load_from_cache: Load service yaml from fallback branch
        :param bool load_from_fallback_branch: Load service yaml from fallback branch
        :param str repo_name: Repo name of remote service override
        """
        pulumi.set(__self__, "branch", branch)
        pulumi.set(__self__, "load_from_cache", load_from_cache)
        pulumi.set(__self__, "load_from_fallback_branch", load_from_fallback_branch)
        pulumi.set(__self__, "repo_name", repo_name)

    @property
    @pulumi.getter
    def branch(self) -> str:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch")

    @property
    @pulumi.getter(name="loadFromCache")
    def load_from_cache(self) -> bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_cache")

    @property
    @pulumi.getter(name="loadFromFallbackBranch")
    def load_from_fallback_branch(self) -> bool:
        """
        Load service yaml from fallback branch
        """
        return pulumi.get(self, "load_from_fallback_branch")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> str:
        """
        Repo name of remote service override
        """
        return pulumi.get(self, "repo_name")


@pulumi.output_type
class GetSpotConnectorPermanentTokenResult(dict):
    def __init__(__self__, *,
                 api_token_ref: str,
                 delegate_selectors: Sequence[str],
                 execute_on_delegate: bool,
                 spot_account_id: str,
                 spot_account_id_ref: str):
        """
        :param str api_token_ref: Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        :param Sequence[str] delegate_selectors: Connect only using delegates with these tags.
        :param bool execute_on_delegate: Execute on delegate or not.
        :param str spot_account_id: Spot account id.
        :param str spot_account_id_ref: Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "api_token_ref", api_token_ref)
        pulumi.set(__self__, "delegate_selectors", delegate_selectors)
        pulumi.set(__self__, "execute_on_delegate", execute_on_delegate)
        pulumi.set(__self__, "spot_account_id", spot_account_id)
        pulumi.set(__self__, "spot_account_id_ref", spot_account_id_ref)

    @property
    @pulumi.getter(name="apiTokenRef")
    def api_token_ref(self) -> str:
        """
        Reference to the Harness secret containing the permanent api token. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "api_token_ref")

    @property
    @pulumi.getter(name="delegateSelectors")
    def delegate_selectors(self) -> Sequence[str]:
        """
        Connect only using delegates with these tags.
        """
        return pulumi.get(self, "delegate_selectors")

    @property
    @pulumi.getter(name="executeOnDelegate")
    def execute_on_delegate(self) -> bool:
        """
        Execute on delegate or not.
        """
        return pulumi.get(self, "execute_on_delegate")

    @property
    @pulumi.getter(name="spotAccountId")
    def spot_account_id(self) -> str:
        """
        Spot account id.
        """
        return pulumi.get(self, "spot_account_id")

    @property
    @pulumi.getter(name="spotAccountIdRef")
    def spot_account_id_ref(self) -> str:
        """
        Reference to the Harness secret containing the spot account id. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "spot_account_id_ref")


@pulumi.output_type
class GetTasConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 tas_manual_details: Sequence['outputs.GetTasConnectorCredentialTasManualDetailResult'],
                 type: str):
        """
        :param Sequence['GetTasConnectorCredentialTasManualDetailArgs'] tas_manual_details: Authenticate to Tas using manual details.
        :param str type: Type can be ManualConfig.
        """
        pulumi.set(__self__, "tas_manual_details", tas_manual_details)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="tasManualDetails")
    def tas_manual_details(self) -> Sequence['outputs.GetTasConnectorCredentialTasManualDetailResult']:
        """
        Authenticate to Tas using manual details.
        """
        return pulumi.get(self, "tas_manual_details")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type can be ManualConfig.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTasConnectorCredentialTasManualDetailResult(dict):
    def __init__(__self__, *,
                 endpoint_url: str,
                 password_ref: str,
                 username: str,
                 username_ref: str):
        """
        :param str endpoint_url: URL of the Tas server.
        :param str password_ref: Reference of the secret for the password.
        :param str username: Username to use for authentication.
        :param str username_ref: Reference to a secret containing the username to use for authentication.
        """
        pulumi.set(__self__, "endpoint_url", endpoint_url)
        pulumi.set(__self__, "password_ref", password_ref)
        pulumi.set(__self__, "username", username)
        pulumi.set(__self__, "username_ref", username_ref)

    @property
    @pulumi.getter(name="endpointUrl")
    def endpoint_url(self) -> str:
        """
        URL of the Tas server.
        """
        return pulumi.get(self, "endpoint_url")

    @property
    @pulumi.getter(name="passwordRef")
    def password_ref(self) -> str:
        """
        Reference of the secret for the password.
        """
        return pulumi.get(self, "password_ref")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter(name="usernameRef")
    def username_ref(self) -> str:
        """
        Reference to a secret containing the username to use for authentication.
        """
        return pulumi.get(self, "username_ref")


@pulumi.output_type
class GetTemplateFiltersFilterPropertyResult(dict):
    def __init__(__self__, *,
                 filter_type: str,
                 tags: Sequence[str]):
        """
        :param str filter_type: Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, TemplateSetup, TemplateExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        :param Sequence[str] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        """
        Corresponding Entity of the filters. Currently supported types are {Connector, DelegateProfile, Delegate, TemplateSetup, TemplateExecution, Deployment, Audit, Template, EnvironmentGroup, FileStore, CCMRecommendation, Anomaly, Environment}.
        """
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def tags(self) -> Sequence[str]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetTemplateGitDetailsResult(dict):
    def __init__(__self__, *,
                 last_commit_id: str,
                 last_object_id: str,
                 branch_name: Optional[str] = None,
                 file_path: Optional[str] = None,
                 file_url: Optional[str] = None,
                 repo_name: Optional[str] = None,
                 repo_url: Optional[str] = None):
        """
        :param str last_commit_id: Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        :param str last_object_id: Last object identifier (for Github). To be provided only when updating Pipeline.
        :param str branch_name: Name of the branch.
        :param str file_path: File path of the Entity in the repository.
        :param str file_url: File url of the Entity in the repository.
        :param str repo_name: Name of the repository.
        :param str repo_url: Repo url of the Entity in the repository.
        """
        pulumi.set(__self__, "last_commit_id", last_commit_id)
        pulumi.set(__self__, "last_object_id", last_object_id)
        if branch_name is not None:
            pulumi.set(__self__, "branch_name", branch_name)
        if file_path is not None:
            pulumi.set(__self__, "file_path", file_path)
        if file_url is not None:
            pulumi.set(__self__, "file_url", file_url)
        if repo_name is not None:
            pulumi.set(__self__, "repo_name", repo_name)
        if repo_url is not None:
            pulumi.set(__self__, "repo_url", repo_url)

    @property
    @pulumi.getter(name="lastCommitId")
    def last_commit_id(self) -> str:
        """
        Last commit identifier (for Git Repositories other than Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_commit_id")

    @property
    @pulumi.getter(name="lastObjectId")
    def last_object_id(self) -> str:
        """
        Last object identifier (for Github). To be provided only when updating Pipeline.
        """
        return pulumi.get(self, "last_object_id")

    @property
    @pulumi.getter(name="branchName")
    def branch_name(self) -> Optional[str]:
        """
        Name of the branch.
        """
        return pulumi.get(self, "branch_name")

    @property
    @pulumi.getter(name="filePath")
    def file_path(self) -> Optional[str]:
        """
        File path of the Entity in the repository.
        """
        return pulumi.get(self, "file_path")

    @property
    @pulumi.getter(name="fileUrl")
    def file_url(self) -> Optional[str]:
        """
        File url of the Entity in the repository.
        """
        return pulumi.get(self, "file_url")

    @property
    @pulumi.getter(name="repoName")
    def repo_name(self) -> Optional[str]:
        """
        Name of the repository.
        """
        return pulumi.get(self, "repo_name")

    @property
    @pulumi.getter(name="repoUrl")
    def repo_url(self) -> Optional[str]:
        """
        Repo url of the Entity in the repository.
        """
        return pulumi.get(self, "repo_url")


@pulumi.output_type
class GetTerraformCloudConnectorCredentialResult(dict):
    def __init__(__self__, *,
                 api_tokens: Sequence['outputs.GetTerraformCloudConnectorCredentialApiTokenResult']):
        """
        :param Sequence['GetTerraformCloudConnectorCredentialApiTokenArgs'] api_tokens: API token credentials to use for authentication.
        """
        pulumi.set(__self__, "api_tokens", api_tokens)

    @property
    @pulumi.getter(name="apiTokens")
    def api_tokens(self) -> Sequence['outputs.GetTerraformCloudConnectorCredentialApiTokenResult']:
        """
        API token credentials to use for authentication.
        """
        return pulumi.get(self, "api_tokens")


@pulumi.output_type
class GetTerraformCloudConnectorCredentialApiTokenResult(dict):
    def __init__(__self__, *,
                 api_token_ref: str):
        """
        :param str api_token_ref: Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        pulumi.set(__self__, "api_token_ref", api_token_ref)

    @property
    @pulumi.getter(name="apiTokenRef")
    def api_token_ref(self) -> str:
        """
        Reference to a secret containing the API token to use for authentication. To reference a secret at the organization scope, prefix 'org' to the expression: org.{identifier}. To reference a secret at the account scope, prefix 'account` to the expression: account.{identifier}.
        """
        return pulumi.get(self, "api_token_ref")


@pulumi.output_type
class GetUsergroupNotificationConfigResult(dict):
    def __init__(__self__, *,
                 group_email: str,
                 microsoft_teams_webhook_url: str,
                 pager_duty_key: str,
                 send_email_to_all_users: bool,
                 slack_webhook_url: str,
                 type: str):
        """
        :param str group_email: Group email.
        :param str microsoft_teams_webhook_url: Url of Microsoft teams webhook.
        :param str pager_duty_key: Pager duty key.
        :param bool send_email_to_all_users: Send email to all the group members.
        :param str slack_webhook_url: Url of slack webhook.
        :param str type: Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        pulumi.set(__self__, "group_email", group_email)
        pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        pulumi.set(__self__, "pager_duty_key", pager_duty_key)
        pulumi.set(__self__, "send_email_to_all_users", send_email_to_all_users)
        pulumi.set(__self__, "slack_webhook_url", slack_webhook_url)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="groupEmail")
    def group_email(self) -> str:
        """
        Group email.
        """
        return pulumi.get(self, "group_email")

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> str:
        """
        Url of Microsoft teams webhook.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @property
    @pulumi.getter(name="pagerDutyKey")
    def pager_duty_key(self) -> str:
        """
        Pager duty key.
        """
        return pulumi.get(self, "pager_duty_key")

    @property
    @pulumi.getter(name="sendEmailToAllUsers")
    def send_email_to_all_users(self) -> bool:
        """
        Send email to all the group members.
        """
        return pulumi.get(self, "send_email_to_all_users")

    @property
    @pulumi.getter(name="slackWebhookUrl")
    def slack_webhook_url(self) -> str:
        """
        Url of slack webhook.
        """
        return pulumi.get(self, "slack_webhook_url")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be one of EMAIL, SLACK, PAGERDUTY, MSTEAMS.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetVariablesSpecResult(dict):
    def __init__(__self__, *,
                 fixed_value: str,
                 value_type: str):
        """
        :param str fixed_value: FixedValue of the variable
        :param str value_type: Type of Value of the Variable. For now only FIXED is supported
        """
        pulumi.set(__self__, "fixed_value", fixed_value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter(name="fixedValue")
    def fixed_value(self) -> str:
        """
        FixedValue of the variable
        """
        return pulumi.get(self, "fixed_value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Type of Value of the Variable. For now only FIXED is supported
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetWorkspaceEnvironmentVariableResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable`
        :param str value: value is the value of the variable
        :param str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetWorkspaceOutputValueOutputValueResult(dict):
    def __init__(__self__, *,
                 name: str,
                 sensitive: bool,
                 value: str):
        """
        :param str name: Name associated with the output.
        :param bool sensitive: Indicates if the output is sensitive.
        :param str value: Value of the output.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sensitive", sensitive)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name associated with the output.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sensitive(self) -> bool:
        """
        Indicates if the output is sensitive.
        """
        return pulumi.get(self, "sensitive")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of the output.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetWorkspaceTerraformVariableResult(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 value_type: str):
        """
        :param str key: Key is the identifier for the variable`
        :param str value: value is the value of the variable
        :param str value_type: Value type indicates the value type of the variable, text or secret
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key is the identifier for the variable`
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        value is the value of the variable
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> str:
        """
        Value type indicates the value type of the variable, text or secret
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class GetWorkspaceTerraformVariableFileResult(dict):
    def __init__(__self__, *,
                 repository: str,
                 repository_branch: str,
                 repository_commit: str,
                 repository_connector: str,
                 repository_path: str,
                 repository_sha: str):
        """
        :param str repository: Repository is the name of the repository to fetch the code from.
        :param str repository_branch: Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        :param str repository_commit: Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        :param str repository_connector: Repository connector is the reference to the connector used to fetch the variables.
        :param str repository_path: Repository path is the path in which the variables reside.
        :param str repository_sha: Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        pulumi.set(__self__, "repository", repository)
        pulumi.set(__self__, "repository_branch", repository_branch)
        pulumi.set(__self__, "repository_commit", repository_commit)
        pulumi.set(__self__, "repository_connector", repository_connector)
        pulumi.set(__self__, "repository_path", repository_path)
        pulumi.set(__self__, "repository_sha", repository_sha)

    @property
    @pulumi.getter
    def repository(self) -> str:
        """
        Repository is the name of the repository to fetch the code from.
        """
        return pulumi.get(self, "repository")

    @property
    @pulumi.getter(name="repositoryBranch")
    def repository_branch(self) -> str:
        """
        Repository branch is the name of the branch to fetch the variables from. This cannot be set if repository commit or sha is set
        """
        return pulumi.get(self, "repository_branch")

    @property
    @pulumi.getter(name="repositoryCommit")
    def repository_commit(self) -> str:
        """
        Repository commit is tag to fetch the variables from. This cannot be set if repository branch or sha is set.
        """
        return pulumi.get(self, "repository_commit")

    @property
    @pulumi.getter(name="repositoryConnector")
    def repository_connector(self) -> str:
        """
        Repository connector is the reference to the connector used to fetch the variables.
        """
        return pulumi.get(self, "repository_connector")

    @property
    @pulumi.getter(name="repositoryPath")
    def repository_path(self) -> str:
        """
        Repository path is the path in which the variables reside.
        """
        return pulumi.get(self, "repository_path")

    @property
    @pulumi.getter(name="repositorySha")
    def repository_sha(self) -> str:
        """
        Repository commit is sha to fetch the variables from. This cannot be set if repository branch or commit is set.
        """
        return pulumi.get(self, "repository_sha")


