# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'EncryptedTextUsageScopeArgs',
    'EncryptedTextUsageScopeArgsDict',
    'EnvironmentVariableOverrideArgs',
    'EnvironmentVariableOverrideArgsDict',
    'GitConnectorCommitDetailsArgs',
    'GitConnectorCommitDetailsArgsDict',
    'GitConnectorUsageScopeArgs',
    'GitConnectorUsageScopeArgsDict',
    'InfrastructureDefinitionAwsAmiArgs',
    'InfrastructureDefinitionAwsAmiArgsDict',
    'InfrastructureDefinitionAwsEcsArgs',
    'InfrastructureDefinitionAwsEcsArgsDict',
    'InfrastructureDefinitionAwsLambdaArgs',
    'InfrastructureDefinitionAwsLambdaArgsDict',
    'InfrastructureDefinitionAwsSshArgs',
    'InfrastructureDefinitionAwsSshArgsDict',
    'InfrastructureDefinitionAwsSshTagArgs',
    'InfrastructureDefinitionAwsSshTagArgsDict',
    'InfrastructureDefinitionAwsWinrmArgs',
    'InfrastructureDefinitionAwsWinrmArgsDict',
    'InfrastructureDefinitionAzureVmssArgs',
    'InfrastructureDefinitionAzureVmssArgsDict',
    'InfrastructureDefinitionAzureWebappArgs',
    'InfrastructureDefinitionAzureWebappArgsDict',
    'InfrastructureDefinitionCustomArgs',
    'InfrastructureDefinitionCustomArgsDict',
    'InfrastructureDefinitionCustomVariableArgs',
    'InfrastructureDefinitionCustomVariableArgsDict',
    'InfrastructureDefinitionDatacenterSshArgs',
    'InfrastructureDefinitionDatacenterSshArgsDict',
    'InfrastructureDefinitionDatacenterWinrmArgs',
    'InfrastructureDefinitionDatacenterWinrmArgsDict',
    'InfrastructureDefinitionKubernetesArgs',
    'InfrastructureDefinitionKubernetesArgsDict',
    'InfrastructureDefinitionKubernetesGcpArgs',
    'InfrastructureDefinitionKubernetesGcpArgsDict',
    'InfrastructureDefinitionTanzuArgs',
    'InfrastructureDefinitionTanzuArgsDict',
    'PlatformCcmFiltersFilterPropertiesArgs',
    'PlatformCcmFiltersFilterPropertiesArgsDict',
    'SshCredentialKerberosAuthenticationArgs',
    'SshCredentialKerberosAuthenticationArgsDict',
    'SshCredentialKerberosAuthenticationTgtGenerationMethodArgs',
    'SshCredentialKerberosAuthenticationTgtGenerationMethodArgsDict',
    'SshCredentialSshAuthenticationArgs',
    'SshCredentialSshAuthenticationArgsDict',
    'SshCredentialSshAuthenticationInlineSshArgs',
    'SshCredentialSshAuthenticationInlineSshArgsDict',
    'SshCredentialSshAuthenticationServerPasswordArgs',
    'SshCredentialSshAuthenticationServerPasswordArgsDict',
    'SshCredentialSshAuthenticationSshKeyFileArgs',
    'SshCredentialSshAuthenticationSshKeyFileArgsDict',
    'SshCredentialUsageScopeArgs',
    'SshCredentialUsageScopeArgsDict',
    'UserGroupLdapSettingsArgs',
    'UserGroupLdapSettingsArgsDict',
    'UserGroupNotificationSettingsArgs',
    'UserGroupNotificationSettingsArgsDict',
    'UserGroupPermissionsArgs',
    'UserGroupPermissionsArgsDict',
    'UserGroupPermissionsAppPermissionsArgs',
    'UserGroupPermissionsAppPermissionsArgsDict',
    'UserGroupPermissionsAppPermissionsAllArgs',
    'UserGroupPermissionsAppPermissionsAllArgsDict',
    'UserGroupPermissionsAppPermissionsDeploymentArgs',
    'UserGroupPermissionsAppPermissionsDeploymentArgsDict',
    'UserGroupPermissionsAppPermissionsEnvironmentArgs',
    'UserGroupPermissionsAppPermissionsEnvironmentArgsDict',
    'UserGroupPermissionsAppPermissionsPipelineArgs',
    'UserGroupPermissionsAppPermissionsPipelineArgsDict',
    'UserGroupPermissionsAppPermissionsProvisionerArgs',
    'UserGroupPermissionsAppPermissionsProvisionerArgsDict',
    'UserGroupPermissionsAppPermissionsServiceArgs',
    'UserGroupPermissionsAppPermissionsServiceArgsDict',
    'UserGroupPermissionsAppPermissionsTemplateArgs',
    'UserGroupPermissionsAppPermissionsTemplateArgsDict',
    'UserGroupPermissionsAppPermissionsWorkflowArgs',
    'UserGroupPermissionsAppPermissionsWorkflowArgsDict',
    'UserGroupSamlSettingsArgs',
    'UserGroupSamlSettingsArgsDict',
    'GetEncryptedTextUsageScopeArgs',
    'GetEncryptedTextUsageScopeArgsDict',
    'GetEnvironmentVariableOverrideArgs',
    'GetEnvironmentVariableOverrideArgsDict',
    'GetSecretManagerUsageScopeArgs',
    'GetSecretManagerUsageScopeArgsDict',
    'GetSshCredentialUsageScopeArgs',
    'GetSshCredentialUsageScopeArgsDict',
]

MYPY = False

if not MYPY:
    class EncryptedTextUsageScopeArgsDict(TypedDict):
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        environment_filter_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        environment_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
elif False:
    EncryptedTextUsageScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptedTextUsageScopeArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 environment_filter_type: Optional[pulumi.Input[builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] application_id: Id of the application to scope to. If empty then this scope applies to all applications.
        :param pulumi.Input[builtins.str] environment_filter_type: Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        :param pulumi.Input[builtins.str] environment_id: Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if environment_filter_type is not None:
            pulumi.set(__self__, "environment_filter_type", environment_filter_type)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="environmentFilterType")
    def environment_filter_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "environment_filter_type")

    @environment_filter_type.setter
    def environment_filter_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment_filter_type", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment_id", value)


if not MYPY:
    class EnvironmentVariableOverrideArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        The name of the variable
        """
        type: pulumi.Input[builtins.str]
        """
        The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the service variable
        """
        service_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the service
        """
elif False:
    EnvironmentVariableOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentVariableOverrideArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 type: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str],
                 service_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] name: The name of the variable
        :param pulumi.Input[builtins.str] type: The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
        :param pulumi.Input[builtins.str] value: The value of the service variable
        :param pulumi.Input[builtins.str] service_name: The name of the service
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[builtins.str]:
        """
        The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the service variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the service
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class GitConnectorCommitDetailsArgsDict(TypedDict):
        author_email_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The email id of the author
        """
        author_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the author
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        Commit message
        """
elif False:
    GitConnectorCommitDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitConnectorCommitDetailsArgs:
    def __init__(__self__, *,
                 author_email_id: Optional[pulumi.Input[builtins.str]] = None,
                 author_name: Optional[pulumi.Input[builtins.str]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] author_email_id: The email id of the author
        :param pulumi.Input[builtins.str] author_name: The name of the author
        :param pulumi.Input[builtins.str] message: Commit message
        """
        if author_email_id is not None:
            pulumi.set(__self__, "author_email_id", author_email_id)
        if author_name is not None:
            pulumi.set(__self__, "author_name", author_name)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter(name="authorEmailId")
    def author_email_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The email id of the author
        """
        return pulumi.get(self, "author_email_id")

    @author_email_id.setter
    def author_email_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "author_email_id", value)

    @property
    @pulumi.getter(name="authorName")
    def author_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the author
        """
        return pulumi.get(self, "author_name")

    @author_name.setter
    def author_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "author_name", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Commit message
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class GitConnectorUsageScopeArgsDict(TypedDict):
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        environment_filter_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        environment_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
elif False:
    GitConnectorUsageScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GitConnectorUsageScopeArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 environment_filter_type: Optional[pulumi.Input[builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] application_id: Id of the application to scope to. If empty then this scope applies to all applications.
        :param pulumi.Input[builtins.str] environment_filter_type: Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        :param pulumi.Input[builtins.str] environment_id: Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if environment_filter_type is not None:
            pulumi.set(__self__, "environment_filter_type", environment_filter_type)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="environmentFilterType")
    def environment_filter_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "environment_filter_type")

    @environment_filter_type.setter
    def environment_filter_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment_filter_type", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment_id", value)


if not MYPY:
    class InfrastructureDefinitionAwsAmiArgsDict(TypedDict):
        ami_deployment_type: pulumi.Input[builtins.str]
        """
        The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
        """
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        region: pulumi.Input[builtins.str]
        """
        The region to deploy to.
        """
        asg_identifies_workload: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to indicate whether the autoscaling group identifies the workload.
        """
        autoscaling_group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the autoscaling group.
        """
        classic_loadbalancers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The classic load balancers to use.
        """
        hostname_convention: NotRequired[pulumi.Input[builtins.str]]
        """
        The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        """
        spotinst_cloud_provider_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the SpotInst cloud provider to connect with.
        """
        spotinst_config_json: NotRequired[pulumi.Input[builtins.str]]
        """
        The SpotInst configuration to use.
        """
        stage_classic_loadbalancers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The staging classic load balancers to use.
        """
        stage_target_group_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The staging classic load balancers to use.
        """
        target_group_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The ARN's of the target groups.
        """
        use_traffic_shift: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to enable traffic shifting.
        """
elif False:
    InfrastructureDefinitionAwsAmiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAwsAmiArgs:
    def __init__(__self__, *,
                 ami_deployment_type: pulumi.Input[builtins.str],
                 cloud_provider_name: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 asg_identifies_workload: Optional[pulumi.Input[builtins.bool]] = None,
                 autoscaling_group_name: Optional[pulumi.Input[builtins.str]] = None,
                 classic_loadbalancers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 hostname_convention: Optional[pulumi.Input[builtins.str]] = None,
                 spotinst_cloud_provider_name: Optional[pulumi.Input[builtins.str]] = None,
                 spotinst_config_json: Optional[pulumi.Input[builtins.str]] = None,
                 stage_classic_loadbalancers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 stage_target_group_arns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 target_group_arns: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 use_traffic_shift: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] ami_deployment_type: The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] region: The region to deploy to.
        :param pulumi.Input[builtins.bool] asg_identifies_workload: Flag to indicate whether the autoscaling group identifies the workload.
        :param pulumi.Input[builtins.str] autoscaling_group_name: The name of the autoscaling group.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] classic_loadbalancers: The classic load balancers to use.
        :param pulumi.Input[builtins.str] hostname_convention: The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        :param pulumi.Input[builtins.str] spotinst_cloud_provider_name: The name of the SpotInst cloud provider to connect with.
        :param pulumi.Input[builtins.str] spotinst_config_json: The SpotInst configuration to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] stage_classic_loadbalancers: The staging classic load balancers to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] stage_target_group_arns: The staging classic load balancers to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] target_group_arns: The ARN's of the target groups.
        :param pulumi.Input[builtins.bool] use_traffic_shift: Flag to enable traffic shifting.
        """
        pulumi.set(__self__, "ami_deployment_type", ami_deployment_type)
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "region", region)
        if asg_identifies_workload is not None:
            pulumi.set(__self__, "asg_identifies_workload", asg_identifies_workload)
        if autoscaling_group_name is not None:
            pulumi.set(__self__, "autoscaling_group_name", autoscaling_group_name)
        if classic_loadbalancers is not None:
            pulumi.set(__self__, "classic_loadbalancers", classic_loadbalancers)
        if hostname_convention is not None:
            pulumi.set(__self__, "hostname_convention", hostname_convention)
        if spotinst_cloud_provider_name is not None:
            pulumi.set(__self__, "spotinst_cloud_provider_name", spotinst_cloud_provider_name)
        if spotinst_config_json is not None:
            pulumi.set(__self__, "spotinst_config_json", spotinst_config_json)
        if stage_classic_loadbalancers is not None:
            pulumi.set(__self__, "stage_classic_loadbalancers", stage_classic_loadbalancers)
        if stage_target_group_arns is not None:
            pulumi.set(__self__, "stage_target_group_arns", stage_target_group_arns)
        if target_group_arns is not None:
            pulumi.set(__self__, "target_group_arns", target_group_arns)
        if use_traffic_shift is not None:
            pulumi.set(__self__, "use_traffic_shift", use_traffic_shift)

    @property
    @pulumi.getter(name="amiDeploymentType")
    def ami_deployment_type(self) -> pulumi.Input[builtins.str]:
        """
        The ami deployment type to use. Valid options are AWS_ASG, SPOTINST
        """
        return pulumi.get(self, "ami_deployment_type")

    @ami_deployment_type.setter
    def ami_deployment_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ami_deployment_type", value)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region to deploy to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="asgIdentifiesWorkload")
    def asg_identifies_workload(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to indicate whether the autoscaling group identifies the workload.
        """
        return pulumi.get(self, "asg_identifies_workload")

    @asg_identifies_workload.setter
    def asg_identifies_workload(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "asg_identifies_workload", value)

    @property
    @pulumi.getter(name="autoscalingGroupName")
    def autoscaling_group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the autoscaling group.
        """
        return pulumi.get(self, "autoscaling_group_name")

    @autoscaling_group_name.setter
    def autoscaling_group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "autoscaling_group_name", value)

    @property
    @pulumi.getter(name="classicLoadbalancers")
    def classic_loadbalancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The classic load balancers to use.
        """
        return pulumi.get(self, "classic_loadbalancers")

    @classic_loadbalancers.setter
    def classic_loadbalancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "classic_loadbalancers", value)

    @property
    @pulumi.getter(name="hostnameConvention")
    def hostname_convention(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        """
        return pulumi.get(self, "hostname_convention")

    @hostname_convention.setter
    def hostname_convention(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hostname_convention", value)

    @property
    @pulumi.getter(name="spotinstCloudProviderName")
    def spotinst_cloud_provider_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the SpotInst cloud provider to connect with.
        """
        return pulumi.get(self, "spotinst_cloud_provider_name")

    @spotinst_cloud_provider_name.setter
    def spotinst_cloud_provider_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spotinst_cloud_provider_name", value)

    @property
    @pulumi.getter(name="spotinstConfigJson")
    def spotinst_config_json(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The SpotInst configuration to use.
        """
        return pulumi.get(self, "spotinst_config_json")

    @spotinst_config_json.setter
    def spotinst_config_json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spotinst_config_json", value)

    @property
    @pulumi.getter(name="stageClassicLoadbalancers")
    def stage_classic_loadbalancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The staging classic load balancers to use.
        """
        return pulumi.get(self, "stage_classic_loadbalancers")

    @stage_classic_loadbalancers.setter
    def stage_classic_loadbalancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "stage_classic_loadbalancers", value)

    @property
    @pulumi.getter(name="stageTargetGroupArns")
    def stage_target_group_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The staging classic load balancers to use.
        """
        return pulumi.get(self, "stage_target_group_arns")

    @stage_target_group_arns.setter
    def stage_target_group_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "stage_target_group_arns", value)

    @property
    @pulumi.getter(name="targetGroupArns")
    def target_group_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The ARN's of the target groups.
        """
        return pulumi.get(self, "target_group_arns")

    @target_group_arns.setter
    def target_group_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "target_group_arns", value)

    @property
    @pulumi.getter(name="useTrafficShift")
    def use_traffic_shift(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to enable traffic shifting.
        """
        return pulumi.get(self, "use_traffic_shift")

    @use_traffic_shift.setter
    def use_traffic_shift(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_traffic_shift", value)


if not MYPY:
    class InfrastructureDefinitionAwsEcsArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        cluster_name: pulumi.Input[builtins.str]
        """
        The name of the ECS cluster to use.
        """
        launch_type: pulumi.Input[builtins.str]
        """
        The type of launch configuration to use. Valid options are FARGATE
        """
        region: pulumi.Input[builtins.str]
        """
        The region to deploy to.
        """
        assign_public_ip: NotRequired[pulumi.Input[builtins.bool]]
        """
        Flag to assign a public IP address.
        """
        execution_role: NotRequired[pulumi.Input[builtins.str]]
        """
        The ARN of the role to use for execution.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The security group ids to apply to the ecs service.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The subnet ids to apply to the ecs service.
        """
        vpc_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The VPC ids to use when selecting the instances.
        """
elif False:
    InfrastructureDefinitionAwsEcsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAwsEcsArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 cluster_name: pulumi.Input[builtins.str],
                 launch_type: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 assign_public_ip: Optional[pulumi.Input[builtins.bool]] = None,
                 execution_role: Optional[pulumi.Input[builtins.str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vpc_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] cluster_name: The name of the ECS cluster to use.
        :param pulumi.Input[builtins.str] launch_type: The type of launch configuration to use. Valid options are FARGATE
        :param pulumi.Input[builtins.str] region: The region to deploy to.
        :param pulumi.Input[builtins.bool] assign_public_ip: Flag to assign a public IP address.
        :param pulumi.Input[builtins.str] execution_role: The ARN of the role to use for execution.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] security_group_ids: The security group ids to apply to the ecs service.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnet_ids: The subnet ids to apply to the ecs service.
        :param pulumi.Input[builtins.str] vpc_id: The VPC ids to use when selecting the instances.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "launch_type", launch_type)
        pulumi.set(__self__, "region", region)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if execution_role is not None:
            pulumi.set(__self__, "execution_role", execution_role)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the ECS cluster to use.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="launchType")
    def launch_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of launch configuration to use. Valid options are FARGATE
        """
        return pulumi.get(self, "launch_type")

    @launch_type.setter
    def launch_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "launch_type", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region to deploy to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Flag to assign a public IP address.
        """
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @property
    @pulumi.getter(name="executionRole")
    def execution_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ARN of the role to use for execution.
        """
        return pulumi.get(self, "execution_role")

    @execution_role.setter
    def execution_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "execution_role", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The security group ids to apply to the ecs service.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The subnet ids to apply to the ecs service.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The VPC ids to use when selecting the instances.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class InfrastructureDefinitionAwsLambdaArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        region: pulumi.Input[builtins.str]
        """
        The region to deploy to.
        """
        iam_role: NotRequired[pulumi.Input[builtins.str]]
        """
        The IAM role to use.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The security group ids to apply to the ecs service.
        """
        subnet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The subnet ids to apply to the ecs service.
        """
        vpc_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The VPC ids to use when selecting the instances.
        """
elif False:
    InfrastructureDefinitionAwsLambdaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAwsLambdaArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 iam_role: Optional[pulumi.Input[builtins.str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subnet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 vpc_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] region: The region to deploy to.
        :param pulumi.Input[builtins.str] iam_role: The IAM role to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] security_group_ids: The security group ids to apply to the ecs service.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subnet_ids: The subnet ids to apply to the ecs service.
        :param pulumi.Input[builtins.str] vpc_id: The VPC ids to use when selecting the instances.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "region", region)
        if iam_role is not None:
            pulumi.set(__self__, "iam_role", iam_role)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if subnet_ids is not None:
            pulumi.set(__self__, "subnet_ids", subnet_ids)
        if vpc_id is not None:
            pulumi.set(__self__, "vpc_id", vpc_id)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region to deploy to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="iamRole")
    def iam_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The IAM role to use.
        """
        return pulumi.get(self, "iam_role")

    @iam_role.setter
    def iam_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "iam_role", value)

    @property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The security group ids to apply to the ecs service.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The subnet ids to apply to the ecs service.
        """
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subnet_ids", value)

    @property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The VPC ids to use when selecting the instances.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vpc_id", value)


if not MYPY:
    class InfrastructureDefinitionAwsSshArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        host_connection_type: pulumi.Input[builtins.str]
        """
        The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
        """
        region: pulumi.Input[builtins.str]
        """
        The region to deploy to.
        """
        autoscaling_group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the autoscaling group.
        """
        desired_capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        The desired capacity of the auto scaling group.
        """
        host_connection_attrs_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the host connection attributes to use.
        """
        hostname_convention: NotRequired[pulumi.Input[builtins.str]]
        """
        The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        """
        loadbalancer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the load balancer to use.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionAwsSshTagArgsDict']]]]
        """
        The tags to use when selecting the instances.
        """
        vpc_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The VPC ids to use when selecting the instances.
        """
elif False:
    InfrastructureDefinitionAwsSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAwsSshArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 host_connection_type: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 autoscaling_group_name: Optional[pulumi.Input[builtins.str]] = None,
                 desired_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 host_connection_attrs_name: Optional[pulumi.Input[builtins.str]] = None,
                 hostname_convention: Optional[pulumi.Input[builtins.str]] = None,
                 loadbalancer_name: Optional[pulumi.Input[builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionAwsSshTagArgs']]]] = None,
                 vpc_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] host_connection_type: The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
        :param pulumi.Input[builtins.str] region: The region to deploy to.
        :param pulumi.Input[builtins.str] autoscaling_group_name: The name of the autoscaling group.
        :param pulumi.Input[builtins.int] desired_capacity: The desired capacity of the auto scaling group.
        :param pulumi.Input[builtins.str] host_connection_attrs_name: The name of the host connection attributes to use.
        :param pulumi.Input[builtins.str] hostname_convention: The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        :param pulumi.Input[builtins.str] loadbalancer_name: The name of the load balancer to use.
        :param pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionAwsSshTagArgs']]] tags: The tags to use when selecting the instances.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] vpc_ids: The VPC ids to use when selecting the instances.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "host_connection_type", host_connection_type)
        pulumi.set(__self__, "region", region)
        if autoscaling_group_name is not None:
            pulumi.set(__self__, "autoscaling_group_name", autoscaling_group_name)
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if host_connection_attrs_name is not None:
            pulumi.set(__self__, "host_connection_attrs_name", host_connection_attrs_name)
        if hostname_convention is not None:
            pulumi.set(__self__, "hostname_convention", hostname_convention)
        if loadbalancer_name is not None:
            pulumi.set(__self__, "loadbalancer_name", loadbalancer_name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if vpc_ids is not None:
            pulumi.set(__self__, "vpc_ids", vpc_ids)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="hostConnectionType")
    def host_connection_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
        """
        return pulumi.get(self, "host_connection_type")

    @host_connection_type.setter
    def host_connection_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_connection_type", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region to deploy to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="autoscalingGroupName")
    def autoscaling_group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the autoscaling group.
        """
        return pulumi.get(self, "autoscaling_group_name")

    @autoscaling_group_name.setter
    def autoscaling_group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "autoscaling_group_name", value)

    @property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The desired capacity of the auto scaling group.
        """
        return pulumi.get(self, "desired_capacity")

    @desired_capacity.setter
    def desired_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "desired_capacity", value)

    @property
    @pulumi.getter(name="hostConnectionAttrsName")
    def host_connection_attrs_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the host connection attributes to use.
        """
        return pulumi.get(self, "host_connection_attrs_name")

    @host_connection_attrs_name.setter
    def host_connection_attrs_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host_connection_attrs_name", value)

    @property
    @pulumi.getter(name="hostnameConvention")
    def hostname_convention(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        """
        return pulumi.get(self, "hostname_convention")

    @hostname_convention.setter
    def hostname_convention(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hostname_convention", value)

    @property
    @pulumi.getter(name="loadbalancerName")
    def loadbalancer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the load balancer to use.
        """
        return pulumi.get(self, "loadbalancer_name")

    @loadbalancer_name.setter
    def loadbalancer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "loadbalancer_name", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionAwsSshTagArgs']]]]:
        """
        The tags to use when selecting the instances.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionAwsSshTagArgs']]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="vpcIds")
    def vpc_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The VPC ids to use when selecting the instances.
        """
        return pulumi.get(self, "vpc_ids")

    @vpc_ids.setter
    def vpc_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "vpc_ids", value)


if not MYPY:
    class InfrastructureDefinitionAwsSshTagArgsDict(TypedDict):
        key: pulumi.Input[builtins.str]
        """
        The key of the tag.
        """
        value: pulumi.Input[builtins.str]
        """
        The value of the tag.
        """
elif False:
    InfrastructureDefinitionAwsSshTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAwsSshTagArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] key: The key of the tag.
        :param pulumi.Input[builtins.str] value: The value of the tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[builtins.str]:
        """
        The key of the tag.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        The value of the tag.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InfrastructureDefinitionAwsWinrmArgsDict(TypedDict):
        autoscaling_group_name: pulumi.Input[builtins.str]
        """
        The name of the autoscaling group.
        """
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        host_connection_attrs_name: pulumi.Input[builtins.str]
        """
        The name of the host connection attributes to use.
        """
        host_connection_type: pulumi.Input[builtins.str]
        """
        The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
        """
        region: pulumi.Input[builtins.str]
        """
        The region to deploy to.
        """
        desired_capacity: NotRequired[pulumi.Input[builtins.int]]
        """
        The desired capacity of the autoscaling group.
        """
        hostname_convention: NotRequired[pulumi.Input[builtins.str]]
        """
        The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        """
        loadbalancer_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the load balancer to use.
        """
elif False:
    InfrastructureDefinitionAwsWinrmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAwsWinrmArgs:
    def __init__(__self__, *,
                 autoscaling_group_name: pulumi.Input[builtins.str],
                 cloud_provider_name: pulumi.Input[builtins.str],
                 host_connection_attrs_name: pulumi.Input[builtins.str],
                 host_connection_type: pulumi.Input[builtins.str],
                 region: pulumi.Input[builtins.str],
                 desired_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 hostname_convention: Optional[pulumi.Input[builtins.str]] = None,
                 loadbalancer_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] autoscaling_group_name: The name of the autoscaling group.
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] host_connection_attrs_name: The name of the host connection attributes to use.
        :param pulumi.Input[builtins.str] host_connection_type: The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
        :param pulumi.Input[builtins.str] region: The region to deploy to.
        :param pulumi.Input[builtins.int] desired_capacity: The desired capacity of the autoscaling group.
        :param pulumi.Input[builtins.str] hostname_convention: The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        :param pulumi.Input[builtins.str] loadbalancer_name: The name of the load balancer to use.
        """
        pulumi.set(__self__, "autoscaling_group_name", autoscaling_group_name)
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "host_connection_attrs_name", host_connection_attrs_name)
        pulumi.set(__self__, "host_connection_type", host_connection_type)
        pulumi.set(__self__, "region", region)
        if desired_capacity is not None:
            pulumi.set(__self__, "desired_capacity", desired_capacity)
        if hostname_convention is not None:
            pulumi.set(__self__, "hostname_convention", hostname_convention)
        if loadbalancer_name is not None:
            pulumi.set(__self__, "loadbalancer_name", loadbalancer_name)

    @property
    @pulumi.getter(name="autoscalingGroupName")
    def autoscaling_group_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the autoscaling group.
        """
        return pulumi.get(self, "autoscaling_group_name")

    @autoscaling_group_name.setter
    def autoscaling_group_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "autoscaling_group_name", value)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="hostConnectionAttrsName")
    def host_connection_attrs_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the host connection attributes to use.
        """
        return pulumi.get(self, "host_connection_attrs_name")

    @host_connection_attrs_name.setter
    def host_connection_attrs_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_connection_attrs_name", value)

    @property
    @pulumi.getter(name="hostConnectionType")
    def host_connection_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of host connection to use. Valid options are PRIVATE*DNS, PUBLIC*DNS, PRIVATE*IP, PUBLIC*IP
        """
        return pulumi.get(self, "host_connection_type")

    @host_connection_type.setter
    def host_connection_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_connection_type", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[builtins.str]:
        """
        The region to deploy to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="desiredCapacity")
    def desired_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The desired capacity of the autoscaling group.
        """
        return pulumi.get(self, "desired_capacity")

    @desired_capacity.setter
    def desired_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "desired_capacity", value)

    @property
    @pulumi.getter(name="hostnameConvention")
    def hostname_convention(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The naming convention to use for the hostname. Defaults to ${host.ec2Instance.privateDnsName.split('.')[0]}
        """
        return pulumi.get(self, "hostname_convention")

    @hostname_convention.setter
    def hostname_convention(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "hostname_convention", value)

    @property
    @pulumi.getter(name="loadbalancerName")
    def loadbalancer_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the load balancer to use.
        """
        return pulumi.get(self, "loadbalancer_name")

    @loadbalancer_name.setter
    def loadbalancer_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "loadbalancer_name", value)


if not MYPY:
    class InfrastructureDefinitionAzureVmssArgsDict(TypedDict):
        auth_type: pulumi.Input[builtins.str]
        """
        The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
        """
        base_name: pulumi.Input[builtins.str]
        """
        Base name.
        """
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        deployment_type: pulumi.Input[builtins.str]
        """
        The type of deployment. Valid options are NATIVE_VMSS
        """
        resource_group_name: pulumi.Input[builtins.str]
        """
        The name of the resource group.
        """
        subscription_id: pulumi.Input[builtins.str]
        """
        The unique id of the azure subscription.
        """
        username: pulumi.Input[builtins.str]
        """
        The username to connect with.
        """
        host_connection_attrs_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the host connection attributes to use.
        """
elif False:
    InfrastructureDefinitionAzureVmssArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAzureVmssArgs:
    def __init__(__self__, *,
                 auth_type: pulumi.Input[builtins.str],
                 base_name: pulumi.Input[builtins.str],
                 cloud_provider_name: pulumi.Input[builtins.str],
                 deployment_type: pulumi.Input[builtins.str],
                 resource_group_name: pulumi.Input[builtins.str],
                 subscription_id: pulumi.Input[builtins.str],
                 username: pulumi.Input[builtins.str],
                 host_connection_attrs_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] auth_type: The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
        :param pulumi.Input[builtins.str] base_name: Base name.
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] deployment_type: The type of deployment. Valid options are NATIVE_VMSS
        :param pulumi.Input[builtins.str] resource_group_name: The name of the resource group.
        :param pulumi.Input[builtins.str] subscription_id: The unique id of the azure subscription.
        :param pulumi.Input[builtins.str] username: The username to connect with.
        :param pulumi.Input[builtins.str] host_connection_attrs_name: The name of the host connection attributes to use.
        """
        pulumi.set(__self__, "auth_type", auth_type)
        pulumi.set(__self__, "base_name", base_name)
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "deployment_type", deployment_type)
        pulumi.set(__self__, "resource_group_name", resource_group_name)
        pulumi.set(__self__, "subscription_id", subscription_id)
        pulumi.set(__self__, "username", username)
        if host_connection_attrs_name is not None:
            pulumi.set(__self__, "host_connection_attrs_name", host_connection_attrs_name)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of authentication to use. Valid options are SSH*PUBLIC*KEY.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="baseName")
    def base_name(self) -> pulumi.Input[builtins.str]:
        """
        Base name.
        """
        return pulumi.get(self, "base_name")

    @base_name.setter
    def base_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "base_name", value)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="deploymentType")
    def deployment_type(self) -> pulumi.Input[builtins.str]:
        """
        The type of deployment. Valid options are NATIVE_VMSS
        """
        return pulumi.get(self, "deployment_type")

    @deployment_type.setter
    def deployment_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "deployment_type", value)

    @property
    @pulumi.getter(name="resourceGroupName")
    def resource_group_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the resource group.
        """
        return pulumi.get(self, "resource_group_name")

    @resource_group_name.setter
    def resource_group_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_group_name", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[builtins.str]:
        """
        The unique id of the azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        The username to connect with.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="hostConnectionAttrsName")
    def host_connection_attrs_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the host connection attributes to use.
        """
        return pulumi.get(self, "host_connection_attrs_name")

    @host_connection_attrs_name.setter
    def host_connection_attrs_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "host_connection_attrs_name", value)


if not MYPY:
    class InfrastructureDefinitionAzureWebappArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        resource_group: pulumi.Input[builtins.str]
        """
        The name of the resource group.
        """
        subscription_id: pulumi.Input[builtins.str]
        """
        The unique id of the azure subscription.
        """
elif False:
    InfrastructureDefinitionAzureWebappArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionAzureWebappArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 resource_group: pulumi.Input[builtins.str],
                 subscription_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] resource_group: The name of the resource group.
        :param pulumi.Input[builtins.str] subscription_id: The unique id of the azure subscription.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "subscription_id", subscription_id)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> pulumi.Input[builtins.str]:
        """
        The name of the resource group.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[builtins.str]:
        """
        The unique id of the azure subscription.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "subscription_id", value)


if not MYPY:
    class InfrastructureDefinitionCustomArgsDict(TypedDict):
        deployment_type_template_version: pulumi.Input[builtins.str]
        """
        The template version
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionCustomVariableArgsDict']]]]
        """
        Variables to be used in the service
        """
elif False:
    InfrastructureDefinitionCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionCustomArgs:
    def __init__(__self__, *,
                 deployment_type_template_version: pulumi.Input[builtins.str],
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionCustomVariableArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] deployment_type_template_version: The template version
        :param pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionCustomVariableArgs']]] variables: Variables to be used in the service
        """
        pulumi.set(__self__, "deployment_type_template_version", deployment_type_template_version)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="deploymentTypeTemplateVersion")
    def deployment_type_template_version(self) -> pulumi.Input[builtins.str]:
        """
        The template version
        """
        return pulumi.get(self, "deployment_type_template_version")

    @deployment_type_template_version.setter
    def deployment_type_template_version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "deployment_type_template_version", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionCustomVariableArgs']]]]:
        """
        Variables to be used in the service
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InfrastructureDefinitionCustomVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class InfrastructureDefinitionCustomVariableArgsDict(TypedDict):
        name: pulumi.Input[builtins.str]
        """
        Name of the variable
        """
        value: pulumi.Input[builtins.str]
        """
        Value of the variable
        """
elif False:
    InfrastructureDefinitionCustomVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionCustomVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[builtins.str],
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] name: Name of the variable
        :param pulumi.Input[builtins.str] value: Value of the variable
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Value of the variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InfrastructureDefinitionDatacenterSshArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        host_connection_attributes_name: pulumi.Input[builtins.str]
        """
        The name of the SSH connection attributes to use.
        """
        hostnames: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of hosts to deploy to.
        """
elif False:
    InfrastructureDefinitionDatacenterSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionDatacenterSshArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 host_connection_attributes_name: pulumi.Input[builtins.str],
                 hostnames: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] host_connection_attributes_name: The name of the SSH connection attributes to use.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hostnames: A list of hosts to deploy to.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "host_connection_attributes_name", host_connection_attributes_name)
        pulumi.set(__self__, "hostnames", hostnames)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="hostConnectionAttributesName")
    def host_connection_attributes_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the SSH connection attributes to use.
        """
        return pulumi.get(self, "host_connection_attributes_name")

    @host_connection_attributes_name.setter
    def host_connection_attributes_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "host_connection_attributes_name", value)

    @property
    @pulumi.getter
    def hostnames(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of hosts to deploy to.
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hostnames", value)


if not MYPY:
    class InfrastructureDefinitionDatacenterWinrmArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        hostnames: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of hosts to deploy to.
        """
        winrm_connection_attributes_name: pulumi.Input[builtins.str]
        """
        The name of the WinRM connection attributes to use.
        """
elif False:
    InfrastructureDefinitionDatacenterWinrmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionDatacenterWinrmArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 hostnames: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 winrm_connection_attributes_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] hostnames: A list of hosts to deploy to.
        :param pulumi.Input[builtins.str] winrm_connection_attributes_name: The name of the WinRM connection attributes to use.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "hostnames", hostnames)
        pulumi.set(__self__, "winrm_connection_attributes_name", winrm_connection_attributes_name)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter
    def hostnames(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of hosts to deploy to.
        """
        return pulumi.get(self, "hostnames")

    @hostnames.setter
    def hostnames(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "hostnames", value)

    @property
    @pulumi.getter(name="winrmConnectionAttributesName")
    def winrm_connection_attributes_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the WinRM connection attributes to use.
        """
        return pulumi.get(self, "winrm_connection_attributes_name")

    @winrm_connection_attributes_name.setter
    def winrm_connection_attributes_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "winrm_connection_attributes_name", value)


if not MYPY:
    class InfrastructureDefinitionKubernetesArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        namespace: pulumi.Input[builtins.str]
        """
        The namespace in Kubernetes to deploy to.
        """
        release_name: pulumi.Input[builtins.str]
        """
        The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
        """
elif False:
    InfrastructureDefinitionKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionKubernetesArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 namespace: pulumi.Input[builtins.str],
                 release_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] namespace: The namespace in Kubernetes to deploy to.
        :param pulumi.Input[builtins.str] release_name: The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "release_name", release_name)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[builtins.str]:
        """
        The namespace in Kubernetes to deploy to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> pulumi.Input[builtins.str]:
        """
        The naming convention of the release. When using Helm Native the default is ${infra.kubernetes.infraId}. For standard Kubernetes manifests the default is release-${infra.kubernetes.infraId}
        """
        return pulumi.get(self, "release_name")

    @release_name.setter
    def release_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "release_name", value)


if not MYPY:
    class InfrastructureDefinitionKubernetesGcpArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        cluster_name: pulumi.Input[builtins.str]
        """
        The name of the cluster being deployed to.
        """
        namespace: pulumi.Input[builtins.str]
        """
        The namespace in Kubernetes to deploy to.
        """
        release_name: pulumi.Input[builtins.str]
        """
        The naming convention of the release.
        """
elif False:
    InfrastructureDefinitionKubernetesGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionKubernetesGcpArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 cluster_name: pulumi.Input[builtins.str],
                 namespace: pulumi.Input[builtins.str],
                 release_name: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] cluster_name: The name of the cluster being deployed to.
        :param pulumi.Input[builtins.str] namespace: The namespace in Kubernetes to deploy to.
        :param pulumi.Input[builtins.str] release_name: The naming convention of the release.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "cluster_name", cluster_name)
        pulumi.set(__self__, "namespace", namespace)
        pulumi.set(__self__, "release_name", release_name)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cluster being deployed to.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def namespace(self) -> pulumi.Input[builtins.str]:
        """
        The namespace in Kubernetes to deploy to.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="releaseName")
    def release_name(self) -> pulumi.Input[builtins.str]:
        """
        The naming convention of the release.
        """
        return pulumi.get(self, "release_name")

    @release_name.setter
    def release_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "release_name", value)


if not MYPY:
    class InfrastructureDefinitionTanzuArgsDict(TypedDict):
        cloud_provider_name: pulumi.Input[builtins.str]
        """
        The name of the cloud provider to connect with.
        """
        organization: pulumi.Input[builtins.str]
        """
        The PCF organization to use.
        """
        space: pulumi.Input[builtins.str]
        """
        The PCF space to deploy to.
        """
elif False:
    InfrastructureDefinitionTanzuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InfrastructureDefinitionTanzuArgs:
    def __init__(__self__, *,
                 cloud_provider_name: pulumi.Input[builtins.str],
                 organization: pulumi.Input[builtins.str],
                 space: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] cloud_provider_name: The name of the cloud provider to connect with.
        :param pulumi.Input[builtins.str] organization: The PCF organization to use.
        :param pulumi.Input[builtins.str] space: The PCF space to deploy to.
        """
        pulumi.set(__self__, "cloud_provider_name", cloud_provider_name)
        pulumi.set(__self__, "organization", organization)
        pulumi.set(__self__, "space", space)

    @property
    @pulumi.getter(name="cloudProviderName")
    def cloud_provider_name(self) -> pulumi.Input[builtins.str]:
        """
        The name of the cloud provider to connect with.
        """
        return pulumi.get(self, "cloud_provider_name")

    @cloud_provider_name.setter
    def cloud_provider_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cloud_provider_name", value)

    @property
    @pulumi.getter
    def organization(self) -> pulumi.Input[builtins.str]:
        """
        The PCF organization to use.
        """
        return pulumi.get(self, "organization")

    @organization.setter
    def organization(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "organization", value)

    @property
    @pulumi.getter
    def space(self) -> pulumi.Input[builtins.str]:
        """
        The PCF space to deploy to.
        """
        return pulumi.get(self, "space")

    @space.setter
    def space(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "space", value)


if not MYPY:
    class PlatformCcmFiltersFilterPropertiesArgsDict(TypedDict):
        filter_type: pulumi.Input[builtins.str]
        """
        Type of CCM filters.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
elif False:
    PlatformCcmFiltersFilterPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PlatformCcmFiltersFilterPropertiesArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[builtins.str],
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] filter_type: Type of CCM filters.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] tags: Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[builtins.str]:
        """
        Type of CCM filters.
        """
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Tags to associate with the resource. Tags should be in the form `name:value`.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class SshCredentialKerberosAuthenticationArgsDict(TypedDict):
        port: pulumi.Input[builtins.int]
        """
        Port to use for Kerberos authentication
        """
        principal: pulumi.Input[builtins.str]
        """
        Name of the principal for authentication
        """
        realm: pulumi.Input[builtins.str]
        """
        Realm associated with the Kerberos authentication
        """
        tgt_generation_method: NotRequired[pulumi.Input['SshCredentialKerberosAuthenticationTgtGenerationMethodArgsDict']]
        """
        TGT generation method
        """
elif False:
    SshCredentialKerberosAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialKerberosAuthenticationArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.int],
                 principal: pulumi.Input[builtins.str],
                 realm: pulumi.Input[builtins.str],
                 tgt_generation_method: Optional[pulumi.Input['SshCredentialKerberosAuthenticationTgtGenerationMethodArgs']] = None):
        """
        :param pulumi.Input[builtins.int] port: Port to use for Kerberos authentication
        :param pulumi.Input[builtins.str] principal: Name of the principal for authentication
        :param pulumi.Input[builtins.str] realm: Realm associated with the Kerberos authentication
        :param pulumi.Input['SshCredentialKerberosAuthenticationTgtGenerationMethodArgs'] tgt_generation_method: TGT generation method
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "principal", principal)
        pulumi.set(__self__, "realm", realm)
        if tgt_generation_method is not None:
            pulumi.set(__self__, "tgt_generation_method", tgt_generation_method)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        Port to use for Kerberos authentication
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def principal(self) -> pulumi.Input[builtins.str]:
        """
        Name of the principal for authentication
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "principal", value)

    @property
    @pulumi.getter
    def realm(self) -> pulumi.Input[builtins.str]:
        """
        Realm associated with the Kerberos authentication
        """
        return pulumi.get(self, "realm")

    @realm.setter
    def realm(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "realm", value)

    @property
    @pulumi.getter(name="tgtGenerationMethod")
    def tgt_generation_method(self) -> Optional[pulumi.Input['SshCredentialKerberosAuthenticationTgtGenerationMethodArgs']]:
        """
        TGT generation method
        """
        return pulumi.get(self, "tgt_generation_method")

    @tgt_generation_method.setter
    def tgt_generation_method(self, value: Optional[pulumi.Input['SshCredentialKerberosAuthenticationTgtGenerationMethodArgs']]):
        pulumi.set(self, "tgt_generation_method", value)


if not MYPY:
    class SshCredentialKerberosAuthenticationTgtGenerationMethodArgsDict(TypedDict):
        kerberos_password_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the encrypted text secret
        """
        key_tab_file_path: NotRequired[pulumi.Input[builtins.str]]
        """
        The path to the key tab file
        """
elif False:
    SshCredentialKerberosAuthenticationTgtGenerationMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialKerberosAuthenticationTgtGenerationMethodArgs:
    def __init__(__self__, *,
                 kerberos_password_id: Optional[pulumi.Input[builtins.str]] = None,
                 key_tab_file_path: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] kerberos_password_id: The id of the encrypted text secret
        :param pulumi.Input[builtins.str] key_tab_file_path: The path to the key tab file
        """
        if kerberos_password_id is not None:
            pulumi.set(__self__, "kerberos_password_id", kerberos_password_id)
        if key_tab_file_path is not None:
            pulumi.set(__self__, "key_tab_file_path", key_tab_file_path)

    @property
    @pulumi.getter(name="kerberosPasswordId")
    def kerberos_password_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the encrypted text secret
        """
        return pulumi.get(self, "kerberos_password_id")

    @kerberos_password_id.setter
    def kerberos_password_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kerberos_password_id", value)

    @property
    @pulumi.getter(name="keyTabFilePath")
    def key_tab_file_path(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The path to the key tab file
        """
        return pulumi.get(self, "key_tab_file_path")

    @key_tab_file_path.setter
    def key_tab_file_path(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "key_tab_file_path", value)


if not MYPY:
    class SshCredentialSshAuthenticationArgsDict(TypedDict):
        port: pulumi.Input[builtins.int]
        """
        The port to connect to
        """
        username: pulumi.Input[builtins.str]
        """
        The username to use when connecting to ssh
        """
        inline_ssh: NotRequired[pulumi.Input['SshCredentialSshAuthenticationInlineSshArgsDict']]
        """
        Inline SSH authentication configuration. Only ond of `passphrase_secret_id` or `ssh_key_file_id` should be used
        """
        server_password: NotRequired[pulumi.Input['SshCredentialSshAuthenticationServerPasswordArgsDict']]
        """
        Server password authentication configuration
        """
        ssh_key_file: NotRequired[pulumi.Input['SshCredentialSshAuthenticationSshKeyFileArgsDict']]
        """
        Use ssh key file for authentication
        """
elif False:
    SshCredentialSshAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialSshAuthenticationArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[builtins.int],
                 username: pulumi.Input[builtins.str],
                 inline_ssh: Optional[pulumi.Input['SshCredentialSshAuthenticationInlineSshArgs']] = None,
                 server_password: Optional[pulumi.Input['SshCredentialSshAuthenticationServerPasswordArgs']] = None,
                 ssh_key_file: Optional[pulumi.Input['SshCredentialSshAuthenticationSshKeyFileArgs']] = None):
        """
        :param pulumi.Input[builtins.int] port: The port to connect to
        :param pulumi.Input[builtins.str] username: The username to use when connecting to ssh
        :param pulumi.Input['SshCredentialSshAuthenticationInlineSshArgs'] inline_ssh: Inline SSH authentication configuration. Only ond of `passphrase_secret_id` or `ssh_key_file_id` should be used
        :param pulumi.Input['SshCredentialSshAuthenticationServerPasswordArgs'] server_password: Server password authentication configuration
        :param pulumi.Input['SshCredentialSshAuthenticationSshKeyFileArgs'] ssh_key_file: Use ssh key file for authentication
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)
        if inline_ssh is not None:
            pulumi.set(__self__, "inline_ssh", inline_ssh)
        if server_password is not None:
            pulumi.set(__self__, "server_password", server_password)
        if ssh_key_file is not None:
            pulumi.set(__self__, "ssh_key_file", ssh_key_file)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[builtins.int]:
        """
        The port to connect to
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[builtins.str]:
        """
        The username to use when connecting to ssh
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="inlineSsh")
    def inline_ssh(self) -> Optional[pulumi.Input['SshCredentialSshAuthenticationInlineSshArgs']]:
        """
        Inline SSH authentication configuration. Only ond of `passphrase_secret_id` or `ssh_key_file_id` should be used
        """
        return pulumi.get(self, "inline_ssh")

    @inline_ssh.setter
    def inline_ssh(self, value: Optional[pulumi.Input['SshCredentialSshAuthenticationInlineSshArgs']]):
        pulumi.set(self, "inline_ssh", value)

    @property
    @pulumi.getter(name="serverPassword")
    def server_password(self) -> Optional[pulumi.Input['SshCredentialSshAuthenticationServerPasswordArgs']]:
        """
        Server password authentication configuration
        """
        return pulumi.get(self, "server_password")

    @server_password.setter
    def server_password(self, value: Optional[pulumi.Input['SshCredentialSshAuthenticationServerPasswordArgs']]):
        pulumi.set(self, "server_password", value)

    @property
    @pulumi.getter(name="sshKeyFile")
    def ssh_key_file(self) -> Optional[pulumi.Input['SshCredentialSshAuthenticationSshKeyFileArgs']]:
        """
        Use ssh key file for authentication
        """
        return pulumi.get(self, "ssh_key_file")

    @ssh_key_file.setter
    def ssh_key_file(self, value: Optional[pulumi.Input['SshCredentialSshAuthenticationSshKeyFileArgs']]):
        pulumi.set(self, "ssh_key_file", value)


if not MYPY:
    class SshCredentialSshAuthenticationInlineSshArgsDict(TypedDict):
        ssh_key_file_id: pulumi.Input[builtins.str]
        """
        The id of the secret containing the SSH key
        """
        passphrase_secret_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the encrypted secret to use
        """
elif False:
    SshCredentialSshAuthenticationInlineSshArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialSshAuthenticationInlineSshArgs:
    def __init__(__self__, *,
                 ssh_key_file_id: pulumi.Input[builtins.str],
                 passphrase_secret_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ssh_key_file_id: The id of the secret containing the SSH key
        :param pulumi.Input[builtins.str] passphrase_secret_id: The id of the encrypted secret to use
        """
        pulumi.set(__self__, "ssh_key_file_id", ssh_key_file_id)
        if passphrase_secret_id is not None:
            pulumi.set(__self__, "passphrase_secret_id", passphrase_secret_id)

    @property
    @pulumi.getter(name="sshKeyFileId")
    def ssh_key_file_id(self) -> pulumi.Input[builtins.str]:
        """
        The id of the secret containing the SSH key
        """
        return pulumi.get(self, "ssh_key_file_id")

    @ssh_key_file_id.setter
    def ssh_key_file_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ssh_key_file_id", value)

    @property
    @pulumi.getter(name="passphraseSecretId")
    def passphrase_secret_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the encrypted secret to use
        """
        return pulumi.get(self, "passphrase_secret_id")

    @passphrase_secret_id.setter
    def passphrase_secret_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_secret_id", value)


if not MYPY:
    class SshCredentialSshAuthenticationServerPasswordArgsDict(TypedDict):
        password_secret_id: pulumi.Input[builtins.str]
        """
        The id of the encrypted secret
        """
elif False:
    SshCredentialSshAuthenticationServerPasswordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialSshAuthenticationServerPasswordArgs:
    def __init__(__self__, *,
                 password_secret_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] password_secret_id: The id of the encrypted secret
        """
        pulumi.set(__self__, "password_secret_id", password_secret_id)

    @property
    @pulumi.getter(name="passwordSecretId")
    def password_secret_id(self) -> pulumi.Input[builtins.str]:
        """
        The id of the encrypted secret
        """
        return pulumi.get(self, "password_secret_id")

    @password_secret_id.setter
    def password_secret_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "password_secret_id", value)


if not MYPY:
    class SshCredentialSshAuthenticationSshKeyFileArgsDict(TypedDict):
        path: pulumi.Input[builtins.str]
        """
        The path to the key file on the delegate
        """
        passphrase_secret_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The id of the secret containing the password to use for the ssh key
        """
elif False:
    SshCredentialSshAuthenticationSshKeyFileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialSshAuthenticationSshKeyFileArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[builtins.str],
                 passphrase_secret_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] path: The path to the key file on the delegate
        :param pulumi.Input[builtins.str] passphrase_secret_id: The id of the secret containing the password to use for the ssh key
        """
        pulumi.set(__self__, "path", path)
        if passphrase_secret_id is not None:
            pulumi.set(__self__, "passphrase_secret_id", passphrase_secret_id)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[builtins.str]:
        """
        The path to the key file on the delegate
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="passphraseSecretId")
    def passphrase_secret_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The id of the secret containing the password to use for the ssh key
        """
        return pulumi.get(self, "passphrase_secret_id")

    @passphrase_secret_id.setter
    def passphrase_secret_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "passphrase_secret_id", value)


if not MYPY:
    class SshCredentialUsageScopeArgsDict(TypedDict):
        application_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        environment_filter_type: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        environment_id: NotRequired[pulumi.Input[builtins.str]]
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
elif False:
    SshCredentialUsageScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SshCredentialUsageScopeArgs:
    def __init__(__self__, *,
                 application_id: Optional[pulumi.Input[builtins.str]] = None,
                 environment_filter_type: Optional[pulumi.Input[builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] application_id: Id of the application to scope to. If empty then this scope applies to all applications.
        :param pulumi.Input[builtins.str] environment_filter_type: Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        :param pulumi.Input[builtins.str] environment_id: Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if environment_filter_type is not None:
            pulumi.set(__self__, "environment_filter_type", environment_filter_type)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="environmentFilterType")
    def environment_filter_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "environment_filter_type")

    @environment_filter_type.setter
    def environment_filter_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment_filter_type", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "environment_id", value)


if not MYPY:
    class UserGroupLdapSettingsArgsDict(TypedDict):
        group_dn: NotRequired[pulumi.Input[builtins.str]]
        """
        The group DN of the LDAP user group.
        """
        group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The group name of the LDAP user group.
        """
        sso_provider_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the SSO provider.
        """
elif False:
    UserGroupLdapSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupLdapSettingsArgs:
    def __init__(__self__, *,
                 group_dn: Optional[pulumi.Input[builtins.str]] = None,
                 group_name: Optional[pulumi.Input[builtins.str]] = None,
                 sso_provider_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group_dn: The group DN of the LDAP user group.
        :param pulumi.Input[builtins.str] group_name: The group name of the LDAP user group.
        :param pulumi.Input[builtins.str] sso_provider_id: The ID of the SSO provider.
        """
        if group_dn is not None:
            pulumi.set(__self__, "group_dn", group_dn)
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if sso_provider_id is not None:
            pulumi.set(__self__, "sso_provider_id", sso_provider_id)

    @property
    @pulumi.getter(name="groupDn")
    def group_dn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group DN of the LDAP user group.
        """
        return pulumi.get(self, "group_dn")

    @group_dn.setter
    def group_dn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_dn", value)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group name of the LDAP user group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="ssoProviderId")
    def sso_provider_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the SSO provider.
        """
        return pulumi.get(self, "sso_provider_id")

    @sso_provider_id.setter
    def sso_provider_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_provider_id", value)


if not MYPY:
    class UserGroupNotificationSettingsArgsDict(TypedDict):
        group_email_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The email addresses of the user group.
        """
        microsoft_teams_webhook_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The Microsoft Teams webhook URL of the user group.
        """
        send_mail_to_new_members: NotRequired[pulumi.Input[builtins.bool]]
        """
        Indicates whether an email is sent when a new user is added to the group.
        """
        send_notifications_to_members: NotRequired[pulumi.Input[builtins.bool]]
        """
        Enable this setting to have notifications sent to the members of this group.
        """
        slack_channel: NotRequired[pulumi.Input[builtins.str]]
        """
        The Slack channel to send notifications to.
        """
        slack_webhook_url: NotRequired[pulumi.Input[builtins.str]]
        """
        The Slack webhook URL to send notifications to.
        """
elif False:
    UserGroupNotificationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupNotificationSettingsArgs:
    def __init__(__self__, *,
                 group_email_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 microsoft_teams_webhook_url: Optional[pulumi.Input[builtins.str]] = None,
                 send_mail_to_new_members: Optional[pulumi.Input[builtins.bool]] = None,
                 send_notifications_to_members: Optional[pulumi.Input[builtins.bool]] = None,
                 slack_channel: Optional[pulumi.Input[builtins.str]] = None,
                 slack_webhook_url: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] group_email_addresses: The email addresses of the user group.
        :param pulumi.Input[builtins.str] microsoft_teams_webhook_url: The Microsoft Teams webhook URL of the user group.
        :param pulumi.Input[builtins.bool] send_mail_to_new_members: Indicates whether an email is sent when a new user is added to the group.
        :param pulumi.Input[builtins.bool] send_notifications_to_members: Enable this setting to have notifications sent to the members of this group.
        :param pulumi.Input[builtins.str] slack_channel: The Slack channel to send notifications to.
        :param pulumi.Input[builtins.str] slack_webhook_url: The Slack webhook URL to send notifications to.
        """
        if group_email_addresses is not None:
            pulumi.set(__self__, "group_email_addresses", group_email_addresses)
        if microsoft_teams_webhook_url is not None:
            pulumi.set(__self__, "microsoft_teams_webhook_url", microsoft_teams_webhook_url)
        if send_mail_to_new_members is not None:
            pulumi.set(__self__, "send_mail_to_new_members", send_mail_to_new_members)
        if send_notifications_to_members is not None:
            pulumi.set(__self__, "send_notifications_to_members", send_notifications_to_members)
        if slack_channel is not None:
            pulumi.set(__self__, "slack_channel", slack_channel)
        if slack_webhook_url is not None:
            pulumi.set(__self__, "slack_webhook_url", slack_webhook_url)

    @property
    @pulumi.getter(name="groupEmailAddresses")
    def group_email_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The email addresses of the user group.
        """
        return pulumi.get(self, "group_email_addresses")

    @group_email_addresses.setter
    def group_email_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "group_email_addresses", value)

    @property
    @pulumi.getter(name="microsoftTeamsWebhookUrl")
    def microsoft_teams_webhook_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Microsoft Teams webhook URL of the user group.
        """
        return pulumi.get(self, "microsoft_teams_webhook_url")

    @microsoft_teams_webhook_url.setter
    def microsoft_teams_webhook_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "microsoft_teams_webhook_url", value)

    @property
    @pulumi.getter(name="sendMailToNewMembers")
    def send_mail_to_new_members(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Indicates whether an email is sent when a new user is added to the group.
        """
        return pulumi.get(self, "send_mail_to_new_members")

    @send_mail_to_new_members.setter
    def send_mail_to_new_members(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "send_mail_to_new_members", value)

    @property
    @pulumi.getter(name="sendNotificationsToMembers")
    def send_notifications_to_members(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Enable this setting to have notifications sent to the members of this group.
        """
        return pulumi.get(self, "send_notifications_to_members")

    @send_notifications_to_members.setter
    def send_notifications_to_members(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "send_notifications_to_members", value)

    @property
    @pulumi.getter(name="slackChannel")
    def slack_channel(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "slack_channel")

    @slack_channel.setter
    def slack_channel(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "slack_channel", value)

    @property
    @pulumi.getter(name="slackWebhookUrl")
    def slack_webhook_url(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Slack webhook URL to send notifications to.
        """
        return pulumi.get(self, "slack_webhook_url")

    @slack_webhook_url.setter
    def slack_webhook_url(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "slack_webhook_url", value)


if not MYPY:
    class UserGroupPermissionsArgsDict(TypedDict):
        account_permissions: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
        """
        app_permissions: NotRequired[pulumi.Input['UserGroupPermissionsAppPermissionsArgsDict']]
        """
        Application specific permissions
        """
elif False:
    UserGroupPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsArgs:
    def __init__(__self__, *,
                 account_permissions: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 app_permissions: Optional[pulumi.Input['UserGroupPermissionsAppPermissionsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] account_permissions: The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
        :param pulumi.Input['UserGroupPermissionsAppPermissionsArgs'] app_permissions: Application specific permissions
        """
        if account_permissions is not None:
            pulumi.set(__self__, "account_permissions", account_permissions)
        if app_permissions is not None:
            pulumi.set(__self__, "app_permissions", app_permissions)

    @property
    @pulumi.getter(name="accountPermissions")
    def account_permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The account permissions of the user group. Valid options are ADMINISTER*OTHER*ACCOUNT*FUNCTIONS, CREATE*AND*DELETE*APPLICATION, CREATE*CUSTOM*DASHBOARDS, MANAGE*ALERT*NOTIFICATION*RULES, MANAGE*API*KEYS, MANAGE*APPLICATION*STACKS, MANAGE*AUTHENTICATION*SETTINGS, MANAGE*CLOUD*PROVIDERS, MANAGE*CONFIG*AS*CODE, MANAGE*CONNECTORS, MANAGE*CUSTOM*DASHBOARDS, MANAGE*DELEGATE*PROFILES, MANAGE*DELEGATES, MANAGE*DEPLOYMENT*FREEZES, MANAGE*IP*WHITELIST, MANAGE*PIPELINE*GOVERNANCE*STANDARDS, MANAGE*RESTRICTED*ACCESS, MANAGE*SECRET*MANAGERS, MANAGE*SECRETS, MANAGE*SSH*AND*WINRM, MANAGE*TAGS, MANAGE*TEMPLATE*LIBRARY, MANAGE*USER*AND*USER*GROUPS*AND*API*KEYS, MANAGE*USERS*AND*GROUPS, READ*USERS*AND*GROUPS, VIEW*AUDITS, VIEW*USER*AND*USER*GROUPS*AND*API_KEYS
        """
        return pulumi.get(self, "account_permissions")

    @account_permissions.setter
    def account_permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "account_permissions", value)

    @property
    @pulumi.getter(name="appPermissions")
    def app_permissions(self) -> Optional[pulumi.Input['UserGroupPermissionsAppPermissionsArgs']]:
        """
        Application specific permissions
        """
        return pulumi.get(self, "app_permissions")

    @app_permissions.setter
    def app_permissions(self, value: Optional[pulumi.Input['UserGroupPermissionsAppPermissionsArgs']]):
        pulumi.set(self, "app_permissions", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsArgsDict(TypedDict):
        alls: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsAllArgsDict']]]]
        """
        The permission to perform actions against all resources.
        """
        deployments: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsDeploymentArgsDict']]]]
        """
        Permission configuration to perform actions against deployments.
        """
        environments: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsEnvironmentArgsDict']]]]
        """
        Permission configuration to perform actions against workflows.
        """
        pipelines: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsPipelineArgsDict']]]]
        """
        Permission configuration to perform actions against pipelines.
        """
        provisioners: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsProvisionerArgsDict']]]]
        """
        Permission configuration to perform actions against provisioners.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsServiceArgsDict']]]]
        """
        Permission configuration to perform actions against services.
        """
        templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsTemplateArgsDict']]]]
        """
        Permission configuration to perform actions against templates.
        """
        workflows: NotRequired[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsWorkflowArgsDict']]]]
        """
        Permission configuration to perform actions against workflows.
        """
elif False:
    UserGroupPermissionsAppPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsArgs:
    def __init__(__self__, *,
                 alls: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsAllArgs']]]] = None,
                 deployments: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsDeploymentArgs']]]] = None,
                 environments: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsEnvironmentArgs']]]] = None,
                 pipelines: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsPipelineArgs']]]] = None,
                 provisioners: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsProvisionerArgs']]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsServiceArgs']]]] = None,
                 templates: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsTemplateArgs']]]] = None,
                 workflows: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsWorkflowArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsAllArgs']]] alls: The permission to perform actions against all resources.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsDeploymentArgs']]] deployments: Permission configuration to perform actions against deployments.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsEnvironmentArgs']]] environments: Permission configuration to perform actions against workflows.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsPipelineArgs']]] pipelines: Permission configuration to perform actions against pipelines.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsProvisionerArgs']]] provisioners: Permission configuration to perform actions against provisioners.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsServiceArgs']]] services: Permission configuration to perform actions against services.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsTemplateArgs']]] templates: Permission configuration to perform actions against templates.
        :param pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsWorkflowArgs']]] workflows: Permission configuration to perform actions against workflows.
        """
        if alls is not None:
            pulumi.set(__self__, "alls", alls)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if environments is not None:
            pulumi.set(__self__, "environments", environments)
        if pipelines is not None:
            pulumi.set(__self__, "pipelines", pipelines)
        if provisioners is not None:
            pulumi.set(__self__, "provisioners", provisioners)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)
        if workflows is not None:
            pulumi.set(__self__, "workflows", workflows)

    @property
    @pulumi.getter
    def alls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsAllArgs']]]]:
        """
        The permission to perform actions against all resources.
        """
        return pulumi.get(self, "alls")

    @alls.setter
    def alls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsAllArgs']]]]):
        pulumi.set(self, "alls", value)

    @property
    @pulumi.getter
    def deployments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsDeploymentArgs']]]]:
        """
        Permission configuration to perform actions against deployments.
        """
        return pulumi.get(self, "deployments")

    @deployments.setter
    def deployments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsDeploymentArgs']]]]):
        pulumi.set(self, "deployments", value)

    @property
    @pulumi.getter
    def environments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsEnvironmentArgs']]]]:
        """
        Permission configuration to perform actions against workflows.
        """
        return pulumi.get(self, "environments")

    @environments.setter
    def environments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsEnvironmentArgs']]]]):
        pulumi.set(self, "environments", value)

    @property
    @pulumi.getter
    def pipelines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsPipelineArgs']]]]:
        """
        Permission configuration to perform actions against pipelines.
        """
        return pulumi.get(self, "pipelines")

    @pipelines.setter
    def pipelines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsPipelineArgs']]]]):
        pulumi.set(self, "pipelines", value)

    @property
    @pulumi.getter
    def provisioners(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsProvisionerArgs']]]]:
        """
        Permission configuration to perform actions against provisioners.
        """
        return pulumi.get(self, "provisioners")

    @provisioners.setter
    def provisioners(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsProvisionerArgs']]]]):
        pulumi.set(self, "provisioners", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsServiceArgs']]]]:
        """
        Permission configuration to perform actions against services.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsTemplateArgs']]]]:
        """
        Permission configuration to perform actions against templates.
        """
        return pulumi.get(self, "templates")

    @templates.setter
    def templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsTemplateArgs']]]]):
        pulumi.set(self, "templates", value)

    @property
    @pulumi.getter
    def workflows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsWorkflowArgs']]]]:
        """
        Permission configuration to perform actions against workflows.
        """
        return pulumi.get(self, "workflows")

    @workflows.setter
    def workflows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UserGroupPermissionsAppPermissionsWorkflowArgs']]]]):
        pulumi.set(self, "workflows", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsAllArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK_WORKFLOW
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
elif False:
    UserGroupPermissionsAppPermissionsAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK_WORKFLOW
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK_WORKFLOW
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsDeploymentArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are READ, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK*WORKFLOW, ABORT*WORKFLOW
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        env_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The environment IDs to which the permission applies. Leave empty to apply to all environments.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
elif False:
    UserGroupPermissionsAppPermissionsDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsDeploymentArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 env_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are READ, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK*WORKFLOW, ABORT*WORKFLOW
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] env_ids: The environment IDs to which the permission applies. Leave empty to apply to all environments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] filters: The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if env_ids is not None:
            pulumi.set(__self__, "env_ids", env_ids)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are READ, EXECUTE*WORKFLOW, EXECUTE*PIPELINE, ROLLBACK*WORKFLOW, ABORT*WORKFLOW
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter(name="envIds")
    def env_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The environment IDs to which the permission applies. Leave empty to apply to all environments.
        """
        return pulumi.get(self, "env_ids")

    @env_ids.setter
    def env_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "env_ids", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsEnvironmentArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        env_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The environment IDs to which the permission applies. Leave empty to apply to all environments.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
elif False:
    UserGroupPermissionsAppPermissionsEnvironmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsEnvironmentArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 env_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] env_ids: The environment IDs to which the permission applies. Leave empty to apply to all environments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] filters: The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if env_ids is not None:
            pulumi.set(__self__, "env_ids", env_ids)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter(name="envIds")
    def env_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The environment IDs to which the permission applies. Leave empty to apply to all environments.
        """
        return pulumi.get(self, "env_ids")

    @env_ids.setter
    def env_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "env_ids", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsPipelineArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are [CREATE READ UPDATE DELETE]
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        env_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The environment IDs to which the permission applies. Leave empty to apply to all environments.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*PIPELINES, PRODUCTION_PIPELINES.
        """
elif False:
    UserGroupPermissionsAppPermissionsPipelineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsPipelineArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 env_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are [CREATE READ UPDATE DELETE]
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] env_ids: The environment IDs to which the permission applies. Leave empty to apply to all environments.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] filters: The filters to apply to the action. Valid options are: NON*PRODUCTION*PIPELINES, PRODUCTION_PIPELINES.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if env_ids is not None:
            pulumi.set(__self__, "env_ids", env_ids)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are [CREATE READ UPDATE DELETE]
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter(name="envIds")
    def env_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The environment IDs to which the permission applies. Leave empty to apply to all environments.
        """
        return pulumi.get(self, "env_ids")

    @env_ids.setter
    def env_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "env_ids", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*PIPELINES, PRODUCTION_PIPELINES.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsProvisionerArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        provisioner_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The provisioner IDs to which the permission applies. Leave empty to apply to all provisioners.
        """
elif False:
    UserGroupPermissionsAppPermissionsProvisionerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsProvisionerArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 provisioner_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] provisioner_ids: The provisioner IDs to which the permission applies. Leave empty to apply to all provisioners.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if provisioner_ids is not None:
            pulumi.set(__self__, "provisioner_ids", provisioner_ids)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter(name="provisionerIds")
    def provisioner_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The provisioner IDs to which the permission applies. Leave empty to apply to all provisioners.
        """
        return pulumi.get(self, "provisioner_ids")

    @provisioner_ids.setter
    def provisioner_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "provisioner_ids", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsServiceArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        service_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The service IDs to which the permission applies. Leave empty to apply to all services.
        """
elif False:
    UserGroupPermissionsAppPermissionsServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsServiceArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 service_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] service_ids: The service IDs to which the permission applies. Leave empty to apply to all services.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if service_ids is not None:
            pulumi.set(__self__, "service_ids", service_ids)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter(name="serviceIds")
    def service_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The service IDs to which the permission applies. Leave empty to apply to all services.
        """
        return pulumi.get(self, "service_ids")

    @service_ids.setter
    def service_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "service_ids", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsTemplateArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        template_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The template IDs to which the permission applies. Leave empty to apply to all environments.
        """
elif False:
    UserGroupPermissionsAppPermissionsTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsTemplateArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 template_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] template_ids: The template IDs to which the permission applies. Leave empty to apply to all environments.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if template_ids is not None:
            pulumi.set(__self__, "template_ids", template_ids)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter(name="templateIds")
    def template_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The template IDs to which the permission applies. Leave empty to apply to all environments.
        """
        return pulumi.get(self, "template_ids")

    @template_ids.setter
    def template_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "template_ids", value)


if not MYPY:
    class UserGroupPermissionsAppPermissionsWorkflowArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        app_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*WORKFLOWS, PRODUCTION*WORKFLOWS, WORKFLOW*TEMPLATES.
        """
elif False:
    UserGroupPermissionsAppPermissionsWorkflowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupPermissionsAppPermissionsWorkflowArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 app_ids: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 filters: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] actions: The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] app_ids: The application IDs to which the permission applies. Leave empty to apply to all applications.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] filters: The filters to apply to the action. Valid options are: NON*PRODUCTION*WORKFLOWS, PRODUCTION*WORKFLOWS, WORKFLOW*TEMPLATES.
        """
        pulumi.set(__self__, "actions", actions)
        if app_ids is not None:
            pulumi.set(__self__, "app_ids", app_ids)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        The actions allowed to be performed. Valid options are CREATE, READ, UPDATE, DELETE
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="appIds")
    def app_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The application IDs to which the permission applies. Leave empty to apply to all applications.
        """
        return pulumi.get(self, "app_ids")

    @app_ids.setter
    def app_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "app_ids", value)

    @property
    @pulumi.getter
    def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The filters to apply to the action. Valid options are: NON*PRODUCTION*WORKFLOWS, PRODUCTION*WORKFLOWS, WORKFLOW*TEMPLATES.
        """
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "filters", value)


if not MYPY:
    class UserGroupSamlSettingsArgsDict(TypedDict):
        group_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The group name of the SAML user group.
        """
        sso_provider_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The ID of the SSO provider.
        """
elif False:
    UserGroupSamlSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserGroupSamlSettingsArgs:
    def __init__(__self__, *,
                 group_name: Optional[pulumi.Input[builtins.str]] = None,
                 sso_provider_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] group_name: The group name of the SAML user group.
        :param pulumi.Input[builtins.str] sso_provider_id: The ID of the SSO provider.
        """
        if group_name is not None:
            pulumi.set(__self__, "group_name", group_name)
        if sso_provider_id is not None:
            pulumi.set(__self__, "sso_provider_id", sso_provider_id)

    @property
    @pulumi.getter(name="groupName")
    def group_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The group name of the SAML user group.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "group_name", value)

    @property
    @pulumi.getter(name="ssoProviderId")
    def sso_provider_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The ID of the SSO provider.
        """
        return pulumi.get(self, "sso_provider_id")

    @sso_provider_id.setter
    def sso_provider_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "sso_provider_id", value)


if not MYPY:
    class GetEncryptedTextUsageScopeArgsDict(TypedDict):
        application_id: NotRequired[builtins.str]
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        environment_filter_type: NotRequired[builtins.str]
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        environment_id: NotRequired[builtins.str]
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
elif False:
    GetEncryptedTextUsageScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEncryptedTextUsageScopeArgs:
    def __init__(__self__, *,
                 application_id: Optional[builtins.str] = None,
                 environment_filter_type: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None):
        """
        :param builtins.str application_id: Id of the application to scope to. If empty then this scope applies to all applications.
        :param builtins.str environment_filter_type: Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        :param builtins.str environment_id: Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if environment_filter_type is not None:
            pulumi.set(__self__, "environment_filter_type", environment_filter_type)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[builtins.str]:
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="environmentFilterType")
    def environment_filter_type(self) -> Optional[builtins.str]:
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "environment_filter_type")

    @environment_filter_type.setter
    def environment_filter_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "environment_filter_type", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "environment_id", value)


if not MYPY:
    class GetEnvironmentVariableOverrideArgsDict(TypedDict):
        name: builtins.str
        """
        The name of the variable
        """
        service_name: builtins.str
        """
        The name of the service
        """
        type: builtins.str
        """
        The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
        """
        value: builtins.str
        """
        The value of the service variable
        """
elif False:
    GetEnvironmentVariableOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEnvironmentVariableOverrideArgs:
    def __init__(__self__, *,
                 name: builtins.str,
                 service_name: builtins.str,
                 type: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: The name of the variable
        :param builtins.str service_name: The name of the service
        :param builtins.str type: The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
        :param builtins.str value: The value of the service variable
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service_name", service_name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: builtins.str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> builtins.str:
        """
        The name of the service
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: builtins.str):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        The type of the service variable. Valid values are `TEXT` and `ENCRYPTED_TEXT`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: builtins.str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The value of the service variable
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: builtins.str):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetSecretManagerUsageScopeArgsDict(TypedDict):
        application_id: NotRequired[builtins.str]
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        environment_filter_type: NotRequired[builtins.str]
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        environment_id: NotRequired[builtins.str]
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
elif False:
    GetSecretManagerUsageScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretManagerUsageScopeArgs:
    def __init__(__self__, *,
                 application_id: Optional[builtins.str] = None,
                 environment_filter_type: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None):
        """
        :param builtins.str application_id: Id of the application to scope to. If empty then this scope applies to all applications.
        :param builtins.str environment_filter_type: Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        :param builtins.str environment_id: Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if environment_filter_type is not None:
            pulumi.set(__self__, "environment_filter_type", environment_filter_type)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[builtins.str]:
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="environmentFilterType")
    def environment_filter_type(self) -> Optional[builtins.str]:
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "environment_filter_type")

    @environment_filter_type.setter
    def environment_filter_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "environment_filter_type", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "environment_id", value)


if not MYPY:
    class GetSshCredentialUsageScopeArgsDict(TypedDict):
        application_id: NotRequired[builtins.str]
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        environment_filter_type: NotRequired[builtins.str]
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        environment_id: NotRequired[builtins.str]
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
elif False:
    GetSshCredentialUsageScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSshCredentialUsageScopeArgs:
    def __init__(__self__, *,
                 application_id: Optional[builtins.str] = None,
                 environment_filter_type: Optional[builtins.str] = None,
                 environment_id: Optional[builtins.str] = None):
        """
        :param builtins.str application_id: Id of the application to scope to. If empty then this scope applies to all applications.
        :param builtins.str environment_filter_type: Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        :param builtins.str environment_id: Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if environment_filter_type is not None:
            pulumi.set(__self__, "environment_filter_type", environment_filter_type)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[builtins.str]:
        """
        Id of the application to scope to. If empty then this scope applies to all applications.
        """
        return pulumi.get(self, "application_id")

    @application_id.setter
    def application_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "application_id", value)

    @property
    @pulumi.getter(name="environmentFilterType")
    def environment_filter_type(self) -> Optional[builtins.str]:
        """
        Type of environment filter applied. Cannot be used with `environment_id`. Valid options are NON*PRODUCTION*ENVIRONMENTS, PRODUCTION_ENVIRONMENTS.
        """
        return pulumi.get(self, "environment_filter_type")

    @environment_filter_type.setter
    def environment_filter_type(self, value: Optional[builtins.str]):
        pulumi.set(self, "environment_filter_type", value)

    @property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[builtins.str]:
        """
        Id of the id of the specific environment to scope to. Cannot be used with `environment_filter_type`.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[builtins.str]):
        pulumi.set(self, "environment_id", value)


